|** bot40.mac
 **
 ** From MMOBugs.com
 ** Original Author: PeteSampras 
 ** Updates by: [40oz], [ChatWithThisName], [Poly], [htw]
 **
 ** TODO:
 **   - Fix SK AE Aggro - WIP - Needs More Testing
 **   - Fix duplicate Pull Conditions
 **   - Fix buff spam when not enough mana
 **   - Fix quiescent harvest trying to cast when not ready yet
 **   - Target Switching needs help (broke on chanters for sure) (Artemus)
 **   - Test shaman mana gain changes
 **
 ** Change List:
 ** Of note, bugs reporters will be credited by the change that fixes their bug in paranthesis.
 **
 ** 2018-11-27 - htw
 **   - Started overhaul for not defined issues and various bugs
 ** 2017-10-07 - Chatwiththisname
 **   - Fixed buff logic
 **   - Fixed Buff durations to use Buff Extension modifiers. 
 **   - Updated from depreciated syntax of ${InvSlot[back].Item.AugSlot1} == 7 to ${Inventory[back].AugSlot1} == 7
 **   - Added base case in the event character has no back item at all
 **   - Checked to verify that the character which has a back item with an AugSlot to also check
 **      AugSlot2 and Augslot3 as I've seen cases where the 7 or 8 augslot could be any of those. 
 **   - Checked that the item with an Augslot of 7 or 8 also has an effect on it to avoid false positives
 **    	 using a ${Bool[${Me.Inventory[back].Spell}]} check to return true or false to avoid false positive. 
 **   - Changed to If/then/else type statements for all buff loading events to avoid unnessesary parsing. 
 **   - Changed debug 3 for spell timer to reflect the time in minutes based on the existing formula to 
 **      convert from milliseconds for readability.}
 **
 ** 2017-10-04 - 40oz
 **   - Reviewed changes and merged in to master doc
 **   - Reverted MyIni changes
 **   - Removed unnecessary comments
 **   - Updated some decisions made
 **
 ** 2017-10-01 - Chatwiththisname
 **	  - Changed a lot more lines to get rid of /goto commands and replaced with 
 **		appropriate /continue or /break as per previous corrections.} As opposed to noting
 **		line numbers I've added a note with my name in it for easy location for using find
 **		as line numbers change as code is edited.} There is 135 /goto commands, 244 /next commands,
 **		498 :keywords and over 9000 lines of code.} I may have missed something. But I'm not sure.
 **
 ** 2017-09-29 - Chatwiththisname
 **	  - Changed lines 1955, 3366, 5529, and 7740 to /continue from /next var 
 **		as needed as per fix by eqmule /next mid /for loop does 
 **		NOT work and will fail to iterate through the loop. 
 **	  - Change to when no AssistPC (Param0) is used/defined
 **		to reflect proper fix instead of referencing INI
 **
 ** 2017-09-29 - Nightmare327
 **	  - Started with Poly's updated version of 40oz's beta version
 **	  - Fixed a few more undeclared variable issues 
 **	  - PullingLoad, SpellLoad2, AggroLoad, EnduranceLoad, RootLoad
 **	  - Load section tested on Warrior, Shaman
 **
 ** 2017-09-19 - 40oz
 **   - First round of fixes for the new variable handling in MQ2 Core
 **     - THESE ARE NOT COMPLETE CHANGES TO MAKE IT WORK
 **     - Only basic functionality was tested with SelfBuff alone.
 **     - Will need error reports for other broken sections with INIs to test against.
 **
 ** 2017-08-23 - 40oz
 **   - Fix Auras to work with the 8/17/2017 MQ2 patch's new handling of ${Me.Aura}
 **
 ** 2017-08-07 - 40oz
 **   - Updated the level check for the bard mez AA Dirge of the Sleepwalker (poly)
 **   - maybe some other undocumented changes that were sitting in my local codebase (man I need to move this to version control)
 **
 ** 2017-03-10 - 40oz
 **   - Updated for compatibility with MQ2Nav as MQ2Navigation is now deprecated (needs testing)
 **   - Added entry point (SetupCustomEvents) for custom code in the bot_custom_events.inc include
 **   - Fixed Advanced Pet Discipline to ranks of Pet Discipline
 **   - Added /pet swarm for anyone with Pet Discipline AA >= Rank 4
 **
 ** 2017-02-05 - 40oz
 **   - Added Giant Modulation Shard to autoinventory list
 **
 ** 2017-02-03 - 40oz
 **   - Fix logic bug related to entering combat in a rare instance involving netbots assist type (islandgirl671)
 **
 ** 2017-02-02 - 40oz
 **   - Fixed AEMezzing Max NPC Level detection
 **   - Changed hardcoded spell attribute values in mez load to subcategory enthrall checks
 **   - Fixed AE Mezzing type-o (islandgirl671)
 **
 ** 2017-01-13 - 40oz
 **   - Removed self-targetting on shaman mana gain spells (MyEmQueTwo) (Needs Testing)
 **
 ** 2016-11-23 - 40oz
 **   - Fixed /toggle to be case insensitive (MyEmQueTwo)
 **   - Removed unnecessary debug spam from mod rod summoning
 **
 ** 2016-11-21 - 40oz
 **   - Removed AutoClickies from the default Options List
 **   - Added Giant Modulation Shard to usable mod rods
 **   - Hopefully fixed up mod rod summoning (can only test giant shard, don't have a mage with lesser ranks)
 **   - Fix to detect low level Shaman Cannibalization spells (MyEmQueTwo)
 **
 ** 2016-10-09 - 40oz
 **   - Bumped Macro Version to v2016.1009 (new aliases require this)
 **   - Fixed new version detection
 **   - Standardized debugging, see notes after change list in comments
 **   - Added /debuglevel command to change spam real time
 **   - Changed XTarget aggro detection to also use AggroAtAggroPct
 **   - Updated aggro sub for SK AA Changes to not have Improved Explosion of [Spite/Hatred]
 **   - Started adding debugging for Mez Routine
 **
 ** 2016-09-11 - 40oz
 **   - Potential fix for mana spell spam bug (Artemus)
 **
 ** 2016-07-12 - 40oz
 **   - Some cleanup of bard twisting in an attempt to get to reset the list less often
 **   - Continued crusade to remove gotos
 **
 ** 2016-07-11 - 40oz
 **   - Added PetFocusItem to be equipped before summoning pet
 **
 ** 2016-07-10 - 40oz
 **   - Added a PullCondition to override the pull sub if needed
 **   - Fixed another PetBuff loop bug
 **
 ** 2016-07-03 - 40oz
 **   - Fixed a looping issue in PetBuffs causing an invalid /next macro breakage
 **
 ** 2016-06-28 - 40oz
 **   - Fix mismatched brackers in Sub SpellLoad (ticker000)
 **   - Fixed double INI creation when running "/mac bot40" and no INI existed.
 **   - Cleaned up TODO for Sub SpellLoad and fixed mismatched brackets + tested.
 **
 ** 2016-06-21 - 40oz
 **   - Fixed MyGemTotal calculation to look at Mnemonic Retention Rank, not some weird hardcoded value
 **   - Standardized how we look through spell effects to match 2016 FEB 12 patch notes
 **   - Fixed Harvest Spell detection, at least on wizards.  Untested on other classes, but the changes should be safe for all
 **   - Fixed Type-O COMAT => COMBAT (Thanks for the report, Fyf19)
 **
 ** 2016-06-18 - 40oz
 **   - Fixed some bugs from the loop cleanup over the week while i was testing
 **   - Made the bot automatically set up xtarget1 to group assist target when it's not in a raid
 **
 ** 2016-06-10 - 40oz
 **   - Standardized for loops to not use brackets, as per documentation
 **   - Began modifying early for loop exits to use `/next iterator` instead of `/goto`
 **   - Some logic cleanup in `Sub Main` for readability
 **   - Removed patch note functionality
 **   - Changed AliasLoad to only load aliases when there's a new bot version
 **   - Added some Debugging
 **   - Added a custom bot events include, with TBM Innoruuk "Doom" handled
 **
 ** 2016-06-09 - 40oz
 **   - Cleaned up indentation throughout whole macro
 **   - Changed MyIni to include server name
 **   - Began labeling some TODO: statements as I worked on cleanup
 **
 **
 ** Debug Levels:
 ** In general I try to stay consistent with debug levels.  Set DebugLevel at the top of
 ** Sub Main to one of the following as needed:
 **    0 - Standard information and errors only (anything using /echo in the mac)
 **    1 - Minor Debugging - basic debugging statements are logged
 **    2 - Major Debugging - most debugging statements are logged
 **    3 - Spam Central    - every debug statement is logged
 ** Use the debug function like this (you must use quotation marks):
 **    /call Debug <1-3> "message"
 **|

#turbo 80
#warning
#define MyIni Bot_${Me.CleanName}_${MacroQuest.Server}_${Me.Class}.ini
#define MobIni Camps.ini
#define LootIni Loot.ini
#define ThisMac bot40

#include spell_routines.inc
#include bot_custom_events.inc

Sub Main(string Param0, string Param1)
	/if (!${Defined[NeedLoad]}) /declare NeedLoad bool outer FALSE
	/if (!${Defined[doBurn]}) /declare doBurn int outer 0
	/if (${Plugin[Navigation].Name.NotEqual[Navigation]}) /declare Navigation bool outer FALSE
	/if (${Plugin[MQ2Cecho].Name.Equal[MQ2Cecho]}) {
		/cechob \agStarting ThisMac
	} else {
		/plugin MQ2Cecho
		/cechob \arStarting ThisMac
	}
	/declare AssistPC string outer ${Param0}
	|** If Param0 isn't blank or NULL etc and evaluates to have some value - Change the INI to hold last Assist Target **|
	/if (${Bool[${Param0}]}) {
		/if (${Param0.NotEqual[load]}) {
			/ini "MyIni" "Assist" "AssistPC" ${Param0}
		}
	}
	/declare AssistPC2 string outer 
	/if (!${Defined[DebugLevel]}) /declare DebugLevel int outer ${Ini[MyIni,Settings,DebugLevel,0]}
	|** Changed the BotVersion: vYear.MonthDayHour (CST) Because I live in Texas ~Chat**|
	/declare BotVersion string outer v2018.11271900
	/declare MyVersion string local ${Ini[MyIni,Settings,BotVersion]}
	/declare NewVersion bool outer ${BotVersion.NotEqual[${MyVersion}]}
	
	/if (${DebugLevel}!=0) /call Debug 1 "Debug Level is set to ${DebugLevel}"
	/call Debug 2 "BotVersion: ${BotVersion} | MyVersion: ${MyVersion} | NewVersion: ${NewVersion}"
    /if (${Param0.Equal[load]}) {
		/varset NeedLoad TRUE
		/call Load
		/if (${NeedLoad}) {
			/echo Macro INI finished.  Edit MyIni in your macros folder.
			/endmac
			/return
		}
	}
	/call Load
	/doevents flush
	

	/if ((${Ini[MyIni,AA,AATotal,123456].Equal[123456]} && ${Ini[MyIni,Settings,OptionsCheck].Find[|AA|]}||${MyVersion.Equal[NULL]}) && !${NeedLoad}) {
		/cecho \aw(\ayIni[MyIni,AA,AATotal] && Ini[MyIni,Settings,OptionCheck.Find[AA] || MyVersion==NULL && !NeedLoad) \aw=== \ar(${Ini[MyIni,AA,AATotal,123456].Equal[123456]} && ${Ini[MyIni,Settings,OptionsCheck].Find[|AA|]}||${MyVersion.Equal[NULL]}) && !${NeedLoad})
		/beep
		/cecho \atInitial set up:
		/cecho \aw1. \agSet up your group puller/tank as intended.
		/cecho \aw2. \agSet XTarget1 to your main/group tank's/assist's target.
		/cecho \aw3. \ao/mac ThisMac load
		/cecho \aw4. \agThis will create an ini in your Macros folder: \ayMyIni
		/cecho \aw5. \agEdit the ini to desired settings. Note that AAs, Auras, Discs, SelfBuffs, Buffs are set to FALSE by default to prevent issues. Also note that ALL pet information must be done manually for now. Ensure SpellIcon names are correct. For group Buffs they will almost certainly be wrong. I suggest using single target buffs for best results and most efficiency. (make sure to edit to proper classes)
		/cecho \aw6. \agStart \aoThisMac \gagain \arper these instructions starting from step 1.
		/beep
		/mmoini "MyIni" "Settings" "BotVersion" "Initial"
		/endmac
	}


	/call ${EchoSub} "${Red}ThisMac ${Green} Loaded ${White} ${BotVersion}"
	/cechob \ay/helpme \aw- Shows available options and commands

	

	/if (!${Defined[AssistType]}) /declare AssistType int outer 3
	/if (!${Raid.Members} && ${Me.XTarget[1].TargetType.NotEqual[Group Assist Target]} && ${Me.XTarget[1].TargetType.NotEqual[Group Tank's Target]} && ${AssistType}==3) {
		/echo Setting Xtarget1 to group assist target, be sure to have your group roles set	
		/xtarget set 1 groupassisttarget
	}
	/if (!${Defined[AssistType]}) /declare AssistType int outer 3
	/if (${Raid.Members} && !${Select[${Me.XTarget[1].TargetType},Raid Assist 1 Target,Raid Assist 2 Target,Raid Assist 3 Target]} && ${AssistType}==3) {
		/cechob \ar!!! WARNING !!! \atXTarget1 set to ${Me.XTarget[1].TargetType}, if you aren't the main assist, you need to change it
	}
	/if (!${Defined[AssistPC]}) /declare AssistPC string outer
	/if (!${Bool[${AssistPC}]}) {
		/if (!${Bool[${Ini[MyIni,Assist,AssistPC,FALSE]}]}) {
			/echo \arError: No AssistPC identified. Macro will not function, /ending.
			/beep
			/end
		} else {
			/varset AssistPC ${Ini[MyIni,Assist,AssistPC]}
			/echo \agUsing previous AssistPC.
		}
	}
	/if (!${Defined[AssistAt]}) /declare AssistAt int outer
	/if (${Me.Name.Equal[${AssistPC}]}) {
		/varset AssistAt 100
	} else {
		/varset AssistAt ${Ini[MyIni,Assist,AssistAt,95]}
	}
	/echo \arAssisting: \ag${AssistPC}
	/echo \arAssisting at: \ag${AssistAt}
	/echo \arUsing AssistType: \ag${AssistType}
	

	
	/if (!${Defined[ErrorFound]}) /declare ErrorFound bool outer
	/if (${ErrorFound}) {
		/echo Errors found in MyIni. See messages above or look in your MQ2 Logs directory for ThisMac.mac.log to review errors encountered.
		/beep
	}
	
	/doevents flush
	
	/echo Beginning main bot loop
	/while (TRUE) {
		/if (${EverQuest.GameState.NotEqual[INGAME]}) {
			/call Debug 3 "Game State no longer 'INGAME', bailing."
			/endmacro
		}

		/if (!${Defined[GMAction]}) /declare GMAction string outer
		/if (${GMCheck} && ${GMAction.Left[1].Equal[/]}) {
			/mqlog ${Me.Class} -  GM ${GMCheck.Names} popped in
			/docommand ${GMAction}
		}
		
		/if (!${Defined[TarID]}) /declare TarID int outer
		/if (${Me.Hovering} && ${TarID}) /call ClearTarget
		
		|** Zone IDs Here:
			344 - Guild Lobby
			202 - Plane of Knowledge
			151 - The Bazaar
			345 - Guild Hall
		**|  
		/if (!${Defined[AutoUseCampfire]}) /declare AutoUseCampfire bool outer ${Ini[MyIni,Campfire,AutoUseCampfire,FALSE]}
		/if (${Select[${Zone.ID},344,202,151,345]} && ${AutoUseCampfire}) /call AutoUseCampfire
		/doevents
		
		/if (!${Defined[RestrictedZones]}) /declare RestrictedZones string outer
		/if (!${Defined[NeedLoad]}) /declare NeedLoad bool outer FALSE
		/if (${Me.Hovering} || ${Window[tradewnd].Open} || ${Window[lootwnd].Open} || ${Me.State.Equal[BIND]} || ${Select[${Zone.ID},${RestrictedZones}]} && !${NeedLoad}) {
			| do nothing
		} else {
			/call Always
			/doevents
			
			/if (${Me.CombatState.Equal[Combat]} || ${Me.Combat} || ${AddListPriority}) {
				/call Combat
				/doevents
			}
			
			/if (${Me.CombatState.NotEqual[Combat]} || !${Me.XTarget} || !${AddCount}) {
				/call Rest
				/doevents
			}
		}
	}
/return

Sub Debug(int level, string message)
	/if (!${Defined[DebugLevel]}) /declare DebugLevel int outer ${Ini[MyIni,Settings,DebugLevel,0]}
	/if (${DebugLevel} >= ${level}) /echo DBG${level}: ${message}
/return

|################> Sub Always <#######################
Sub Always
	/call Debug 4 "Entering Sub Always"
	/if (${Select[${Cursor.ID},9963,76504,79322,79321,79320,6346,64953,64954,64955,64979,64980,64981,64982,64983,64984,52817,64951,52709,3426,57264,52674,76503,121336,64978,77613,77678,77681,57265,52818,52710,77679,64952,77682,52701,76501,79497]}) /autoinventory

	/if (!${Plugin[MQ2Twist].Name.Length}) {
		/if (${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && !${Me.Casting.ID} && ${Spawn[${TarID}].ID}) /squelch /tar id ${TarID}
	} else {
		/if (${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && (!${Me.Casting.ID}||${Twist.Twisting}) && ${Spawn[${TarID}].ID}) /squelch /tar id ${TarID}
	}
	/if (${OptionsCheckCurrent.Equal[Group]} && ${Raid.Members} && ${OptionsCheckRaid.NotEqual[123456]}) {
		/varset OptionsCheck ${Ini[MyIni,Settings,OptionsCheckRaid]}
		/varset OptionsCheckCurrent Raid
	}
	/if (${OptionsCheckCurrent.Equal[Raid]} && !${Raid.Members}) {
		/varset OptionsCheck ${Ini[MyIni,Settings,OptionsCheck]}
		/varset OptionsCheckCurrent Group
	}
	/varset XTargetList1 ${XTargetList}
	/if (${XTargetList1.NotEqual[${XTargetList2}]}) {
		/varset XTargetList2 ${XTargetList}
		/call AddHandler
	}
	/call CheckTarget${AssistType}
	/if (!${Plugin[MQ2Twist].Name.Length}) {
		/if (${AssistType} && ${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && !${Me.Casting.ID} && ${Spawn[${TarID}].ID}) /squelch /tar id ${TarID}
	} else {
		/if (${AssistType} && ${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && (!${Me.Casting.ID}||${Twist.Twisting}) && ${Spawn[${TarID}].ID}) /squelch /tar id ${TarID}
	}

	/if (!${Defined[MainTankPetMaster]}) /declare MainTankPetMaster string outer NULL
	
	/if (${MainTankPetMaster.Length} && ${MainTankPetMaster.NotEqual[NULL]}) /call CastOnPets MainTankBuff
	/call Debug 4 "Leaving Sub Always"
/return

|################> Sub Combat <#######################
Sub Combat
	/call Debug 4 "Entering Sub Combat"
	/if (!${Defined[CombatLoaded]}) /call CombatLoad
	/if (${Me.Hovering}||${Pulling}) /return
	/if (${Target.ID} && ${Target.Distance}>100 && ${SpawnCount[group ${AssistPC}]} && ${Defined[XTargetRadiusList]}||!${Me.XTarget}||!${TarID} && ${Me.XTarget}<${AddCount}) /call Event_ClearTargetData
	/if (${Target.ID} && ${Target.Distance}>100 && !${SpawnCount[group ${AssistPC}]} && ${Defined[XTargetRadiusList]}||!${Me.XTarget}||!${TarID} && ${Me.XTarget}<${AddCount}) /squelch /tar clear

	
	/if (${Target.Type.Equal[corpse]}) /squelch /tar clear
	/if (${AssistType} && ${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && ${Spawn[${TarID}].ID}||${Target.Type.Equal[corpse]}) /squelch /tar id ${TarID}
	/if (!${Range.Between[0,20:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Me.Heading.Degrees}]}]}]} && ${Target.ID} && ${AmIPuller}) /face
	/declare i int local
	/varset XTargetList1 ${XTargetList}
	/if (${XTargetList1.NotEqual[${XTargetList2}]}) {
		/varset XTargetList2 ${XTargetList}
		/call AddHandler
	}
	/if (${OptionsCheck.Find[|Aggro|]}) /call Aggro
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${BardMezTotal} && ${UseSingleMez} && ${AddCount}>1) /call BardMez
	}	
	/if (${OptionsCheck.Find[|Mez|]}||${OptionsCheck.Find[|Root|]}||${OptionsCheck.Find[|Debuff|]}) {
		/if (${OptionsCheck.Find[|Mez|]}) {
			/if ((${MezTotal}||${AEMezTotal}||${PBAEMezTotal})) /call Mez
		}
		/if (${OptionsCheck.Find[|Root|]}) {
			/if (${RootTotal}) /call Root
		}
		/if (${OptionsCheck.Find[|Debuff|]}) {
			/if (${DebuffTotal}) /call Debuff
		}
	}
	
	/if (${Me.Class.ShortName.Equal[BRD]} && ${Plugin[MQ2Twist].Name.Length}) {
		/if (!${Me.GemTimer[${PBAEMezSpellGem}]} && ${PBAEMezSpellName.NotEqual[NULL]} && ${Me.Gem[${PBAEMezSpellName}]} && ${Spawn[${Me.XTarget[2].ID}].Distance}<35 && ${Me.XTarget[2].ID} && ${Me.CurrentMana}>${Spell[${PBAEMezSpellName}].Mana}) {
			/twist once ${PBAEMezSpellGem}
			/echo PBAEMEZ is firing.
			/delay 35
			/call ${EchoSub} "${DarkYellow} ${PBAEMezSpellName} --> ${White} PBAE Mez"
			/varset BeamUsed 1
			/varset BeamTimer ${BeamTimer.OriginalValue}
			/doevents
			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${PBAEMezSpellName}
		}
	}
	
	/if (!${Defined[FadeLoaded]}) /call FadeLoad
    /for i 0 to ${FadeTotal}
		/if (${Defined[FadeUseAtMyHP${i}]}) {
			/if (${OptionsCheck.Find[|Fade|]} && ${Math.Max[${FadeUseAtMyHP${i}}]}<=${Me.PctHPs}) /call Fade
		}
	/next i
	
	/if (!${Defined[FeignDeathLoaded]}) /call FeignDeathLoad
	/for i 1 to ${FeignDeathTotal}
		/if (${Defined[FeignDeathUseAtMyHP${i}]}) {
			/if (${OptionsCheck.Find[|FeignDeath|]} && ${Math.Max[${FeignDeathUseAtMyHP}]}<=${Me.PctHPs}||${Me.Feigning} && ${FeignDeathStandAtMyHP}<=${Me.PctHPs}) /call FeignDeath
		}
	/next i
	
	/for i 1 to ${CombatRoutines.Count[|]}
		/if (${Me.Hovering}||${Pulling}) /return
		/if (${AddCount}>1 && (${OptionsCheck.Find[|Mez|]}||${OptionsCheck.Find[|Root|]}||${OptionsCheck.Find[|Debuff|]})) {
			/call MezLoad
			/if (${OptionsCheck.Find[|Mez|]}) {
				/if (!${Defined[MezLoaded]}) /declare MezLoaded bool outer FALSE
				/if (${MezLoaded}) {
					/if (${MezTotal}||${AEMezTotal}||${PBAEMezTotal}) /call Mez
				}
			}
			
			/if (!${Defined[RootTotal]}) /declare RootTotal ${Ini[MyIni,Root,RootTotal,0]}
			/if (${Defined[RootTotal]}) {
				/if (${RootTotal} > 0) {
					/if (${OptionsCheck.Find[|Root|]} && ${RootTotal}) /call Root
				}
			}
			
			/if (${Defined[DebuffAdds]}) {
				/if (${DebuffAdds}) {
					/if (${OptionsCheck.Find[|Debuff|]} && ${DebuffTotal}) /call Debuff
				}
			}
		}
		/if (${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && !${Me.Casting.ID} && ${Spawn[${TarID}].ID}) /squelch /tar id ${TarID}
		/if (!${Defined[InterruptToHealAt]}) /declare InterruptToHealAt int outer 0
		/if (${Group.Member[${Group.Min}].PctHPs}<=${InterruptToHealAt} && ${OptionsCheck.Find[|Heal|]}||${Me.PctHPs}<=${InterruptToHealAt} && ${OptionsCheck.Find[Lifetap]}) /call Heal
		/if (${Spawn[${SummonTankTarget}].ID}==${Target.ID} && ${Target.ID}) /call SummonTank
		/if (${Spawn[${LeapTarget}].ID}==${Target.ID} && ${Target.ID}) /call Leap
		/if (!${Defined[PetAttackAt]}) /declare PetAttackAt int outer 0
		/if (${Me.Pet.Following.ID}!=${TarID} && ${Me.Pet.ID} && ${Target.ID} && ${Target.PctHPs}<=${PetAttackAt} && ${Target.ID}==${TarID} && ${Target.Distance}<=${AttackRange}) {
			/pet back off
			/pet attack
		}
		/doevents
		/varset XTargetList1 ${XTargetList}
			/if (${XTargetList1.NotEqual[${XTargetList2}]}) {
			/varset XTargetList2 ${XTargetList}
			/call AddHandler
		}
		/if (${OptionsCheck.Find[|${CombatRoutines.Arg[${i},|]}|]} && ${CombatRoutines.Arg[${i},|].NotEqual[NULL]}) {
			/if (!${Defined[${CombatRoutines.Arg[${i},|]}UseAtMobPctHP]}) /declare ${CombatRoutines.Arg[${i},|]}UseAtMobPctHP int outer
			/if (!${Defined[${CombatRoutines.Arg[${i},|]}StopAtMobPctHP]}) /declare ${CombatRoutines.Arg[${i},|]}StopAtMobPctHP int outer
			/if (!${Defined[${CombatRoutines.Arg[${i},|]}UseAtMyHP]}) /declare ${CombatRoutines.Arg[${i},|]}UseAtMyHP int outer
			/if (${Range.Between[${Math.Min[${${CombatRoutines.Arg[${i},|]}StopAtMobPctHP}]},${Math.Max[${${CombatRoutines.Arg[${i},|]}UseAtMobPctHP}]}:${Target.PctHPs}]} && ${Select[${CombatRoutines.Arg[${i},|]},Dot,Nuke,AA,Stun,ClickyNuke,Jolt]}) /call ${CombatRoutines.Arg[${i},|]}
			/if (${Range.Between[1,${Math.Max[${${CombatRoutines.Arg[${i},|]}UseAtMobPctHP}]}:${Target.PctHPs}]} && ${Select[${CombatRoutines.Arg[${i},|]},Snare]})	/call ${CombatRoutines.Arg[${i},|]}
			/if (${Range.Between[1,${Math.Max[${${CombatRoutines.Arg[${i},|]}UseAtMyHP}]}:${Me.PctHPs}]} && ${Select[${CombatRoutines.Arg[${i},|]},Lifetap,FeignDeath,Fade]}) /call ${CombatRoutines.Arg[${i},|]}
			/if (!${Select[${CombatRoutines.Arg[${i},|]},Dot,Nuke,Stun,Snare,AA,Lifetap,FeignDeath,Fade,Jolt]})	/call ${CombatRoutines.Arg[${i},|]}
		}
	/next i
	
	/if (${CustomCombatTotal}) {
		/if (${Me.Hovering}||${Pulling}) /return
		/for i 1 to ${CustomCombatTotal}
			/if (!${Defined[CustomCombat${i}]}) /declare CustomCombat${i} string outer
				/varset CustomCombat${i} ${Ini[MyIni,Custom,CustomCombat${i}]}
			/docommand ${CustomCombat${i}}
		/next i
	}
	
	/if (${NeedLoad}||${SetCampfire}) /call Campfire
	
	/if (${Select[${Me.Class.ShortName},BRD]} && ${Plugin[MQ2Twist].Name.Length}) {
		/if (${Defined[CombatTwist]}) {
			/if (!${Defined[Mezzing]}) /declare Mezzing bool outer FALSE
			/if (!${Mezzing} && ${Twist.List} != ${CombatTwist} && ${Me.CombatState.Equal[COMBAT]} && !${Twist.Twisting}) {
				/if (${Me.Sitting}) /stand
				/squelch /twist ${CombatTwist}
				/cechob \agCombatTwist is firing!
			}
		}
	}
	/if (${Defined[MainTankPetMaster]}) {
		/if (${MainTankPetMaster.Length} && ${MainTankPetMaster.NotEqual[NULL]}) /call CastOnPets MainTankBuff
	}
/return

|################> Sub Rest <#######################
Sub Rest
	/call Debug 4 "Entered Sub Rest"
	/varset XTargetList1 ${XTargetList}
	/if (${XTargetList1.NotEqual[${XTargetList2}]}) {
		/varset XTargetList2 ${XTargetList}
		/call AddHandler
	}
	/if (${Pulling}) {
		/call Debug 3 "Pulling set to ${Pulling}, I should not be resting."
		/return
	}
	/doevents
	/if (${Camp_Zone}==${Zone.ID} && (!${Me.XTarget}||${Me.CombatState.Equal[ACTIVE]}||${Me.CombatState.Equal[COOLDOWN]}) && ${UseCamp} && ${Math.Distance[${Me.Y},${Me.X}:${YLOC},${XLOC}]}>${CampRadius} && !${Pulling} && ${Math.Distance[${Me.Y},${Me.X}:${YLOC},${XLOC}]}<${CampRadiusMax}) {
		/moveto loc ${YLOC} ${XLOC} loose
		/delay 2s ${Math.Distance[${Me.Y},${Me.X}:${YLOC},${XLOC}]}<${MoveTo.ArrivalDist}
		/if (!${AmIPuller}) /face heading ${MyHeading}
	}
	/declare i int local
	/if (${Me.Standing} && !${sitTimer} && !${Me.Mount.ID} && !${Me.Casting.ID} && !${Me.Moving} && !${Stick.Active} && !${MoveTo.Moving} && !${Me.CombatState.Equal[COMBAT]} && ${Me.Class.ShortName.NotEqual[BRD]}) {
		
		/varset sitTimer ${Ini[MyIni,General,SitTimer]}
	}
	/for i 1 to ${RestRoutines.Count[|]}
		/if (${Math.Max[${AddListPriority}]}) /return
		/if (${AddCount} && ${AssistType}) /call ClearAddList
		/if (${TarID} && (!${Target.ID}||${Target.ID}!=${TarID}) && ${Spawn[id ${TarID}].Type.NotEqual[corpse]} && !${Me.Casting.ID} && ${Spawn[${TarID}].ID}||${Target.Type.Equal[Corpse]}) /squelch /tar id ${TarID}
		/if (${Following}) /call Follow
		/if ((${OptionsCheck.Find[|${RestRoutines.Arg[${i},|]}|]} && !${RestRoutines.Arg[${i},|].Find[null]})||${Select[${RestRoutines.Arg[${i},|]},Heal,BardRest]}) {
			/call ${RestRoutines.Arg[${i},|]}
			/doevents
		}
	/next i
	/if (${Defined[UsePet]}) {
		/if (${UsePet}) /call PetBuffs
	}
	/if (${OptionsCheck.Find[SummonItem]}) /call SummonItem
	/if (${OptionsCheck.Find[Cure]}) /call Cure
	/if (!${HideCorpseTimer} && !${LootNPCs} && ${AutoHideNPCCorpses} && ${SpawnCount[npccorpse radius 200]}) {
		/varset HideCorpseTimer ${HideCorpseTimer.OriginalValue}
		/hidecorpse npc
	}
	/if (${LootNPCs} && !${AddCount}) /call LootMobs

	/if (${CustomRestTotal}) {
		/for i 1 to ${CustomRestTotal}
			/if (!${Defined[CustomRest${i}]}) /declare CustomRest${i} string outer
			|/noparse /varset CustomRest${i} ${Ini[MyIni,Custom,CustomRest${i}]}
			/varset CustomRest${i} ${Ini[MyIni,Custom,CustomRest${i}]}
			/docommand ${CustomRest${i}}
		/next i
	}

	/if (${Defined[RestTwist]} && ${Plugin[MQ2Twist].Name.Length}) {
		/if (${RestTwist.Equal[NULL]} && ${Twist.Twisting}) {
			/twist off
			/echo Turning off Twist RestTwist!= Twist.List and RestTwist is NULL
		}
		/if (${StopSongsIfPullerIsThisDistanceOrMore} && ${Group.Puller.Distance} > ${StopSongsIfPullerIsThisDistanceOrMore} && ${Twist.Twisting}) {
			/twist off
		}
		/if (${Defined[RestTwist]}) {
			/if (${Twist.List} != ${RestTwist} || !${Twist.Twisting} || !${StopSongsIfPullerIsThisDistanceOrMore} || ${Group.Puller.Distance} < ${StopSongsIfPullerIsThisDistanceOrMore}) {
				/echo Should be firing, past first test. 
				/if (!${NeedAura} && !${Twist.Twisting} || ${Twist.List} != ${RestTwist} && !${NeedAura}) {
					/cechob \agRestTwist is firing!
					/if (${Me.Sitting}) /stand
					/squelch /twist ${RestTwist}
				}
			}
		}
	}
	/if (!${Defined[UseSelos]}) /declare UseSelos bool outer FALSE
	/if (${UseSelos}) {
		/if (!${Me.Buff[${SelosSong}].ID}) {
			/if (${Me.AltAbility[${SelosSong}]}) {
				/alt act ${Me.AltAbility[${SelosSong}].ID}
			} else /if (${Me.Gem[${SelosSong}]} && ${Plugin[MQ2Twist].Name.Length}) {
				/twist once ${Me.Gem[${SelosSong}]}
			}
		}
	}
	/if (!${Me.Feigning} && ${AutoInvis} && !${Me.Invis} && ${AutoBreakInvis}  && ${SpawnCount[npc radius 100]} && (${Me.AltAbilityReady[${InvisSpell}]}||${Me.SpellReady[${InvisSpell}]}||${FindItemCount[=${InvisSpell}]})) {
		/call Cast "${InvisSpell}" ${InvisSpellGem} NULL NULL NULL
	}
	
	/if (${Defined[AABuy]}) {
		/if (!${Defined[lvl_aa]}) /call AABuy
		/if (${AABuy} && ${AACount} && ${Me.AAPoints}>${AABuyAt} && !${AACurrentMaxed} && (!${Defined[lvl_aa]}||${lvl_aa.NotEqual[${Me.Level}_${Me.AAPoints}]})) /call AABuy
		/if (${AABuy} && ${AACount} && ${Me.AAPoints}>${AABuyAt} && (!${AACurrentMaxed}||!${AABuyTimer})) {
			/varset AACurrentMaxed 0
			/varset AABuyTimer 5m
			/call AABuy
		}
	}
	/if (${Defined[AmIPuller]}) {
		/if (${AmIPuller}) /call Pulling
	}
	/if (${MainTankPetMaster.Length} && ${MainTankPetMaster.NotEqual[NULL]}) /call CastOnPets MainTankBuff
/return


|################> Sub Load <#######################
Sub Load
	/call Debug 3 "In Sub Load"
	/if (${Ini[MyIni,Initialize,Command1].Length}) /call Init2
	/if (!${Defined[sitTimer]}) {
		/declare sitTimer timer outer
	}
	/if (!${Bool[${Ini[MyIni,General,SitTimer]}]}) {
		/ini "MyIni" "General" "SitTimer" "2s"
		/varset sitTimer ${Ini[MyIni,General,SitTimer]}
	} else {
		/varset sitTimer ${Ini[MyIni,General,SitTimer]}
	}
	/cechob \arYou will sit ${Ini[MyIni,General,SitTimer]} after previous sit. 
	/declare SyntaxError string outer NULL
	/declare Error string outer NULL
	/declare MQ2DataError string outer NULL
	/declare i int local
	/declare CurrentSub string outer
	/declare CurrentSubHold string outer
	/declare debug int outer
	/declare tempsubtotal int outer
	/if (!${Defined[TarID]}) /declare TarID int outer
	/declare Hate int outer 0
	/declare ListVar string outer
	/declare ListVarType string outer
	/declare ListDefault string outer
	/declare ListSection string outer
	/if (!${Defined[GMAction]}) /declare GMAction string outer
	/declare LoadListVar string outer RestrictedZones|GMAction|LootNPCs|AuthorizedUsers|Verbose|MyChannel|AnnounceChannel|AnnounceEvents|EQBCAnnounceAdds|AutoHideNPCCorpses|ClearTargetDataAlias|EmergencyAlias|EmergencySkill|ImmunityCheck|
	/declare LoadListVarType string outer string|string|bool|string|bool|string|string|string|bool|bool|string|string|string|bool|
	/declare LoadListDefault string outer "344,202,151,345"|NULL|FALSE|NULL|FALSE|bc|bc|NULL|FALSE|FALSE|ClearTargetDataAlias|EmergencyAlias|EmergencySkill|TRUE|
	/declare LoadListSection string outer Settings
	/declare RestRoutines string outer Rez|AABuy|Heal|XHeal|Rez|SelfBuff|Aura|Rez|Buff|Endurance|Mana|ModRod|Merc|ClickyMaintenance|Rez|Heal|XHeal|FeignDeath|Rez|Cure|BardRest|Request|
	/declare aastart float outer 0
	/declare expstart float outer 0
	/varcalc aastart (${Me.AAPointsTotal} * 100) + ${Me.PctAAExp}
	/varcalc expstart (${Me.Level} * 100) + ${Me.PctExp}
	/if (!${Defined[Pulling]}) /declare Pulling bool outer
	
	/declare MyGemTotal int outer 8
	/if (${Me.AltAbility[Mnemonic Retention].Rank}>0) /varcalc MyGemTotal 8 + ${Me.AltAbility[Mnemonic Retention].Rank}

	/declare OptionsCheckCurrent string outer Group
	/declare HideCorpseTimer timer outer 2m
	/declare spellload2 string outer
	/declare Heals string outer HealBalance|HealGroup|HealSingle|HealSelf|HealSplash|
	/if (!${Defined[ErrorFound]}) /declare ErrorFound bool outer
	/declare ExitSubEarly int outer 1

	/noparse /declare Mezzer string outer (${SpawnCount[group enc]}||${SpawnCount[group brd]})
	/noparse /declare Thaumatize string outer (${Me.Buff[Thaumatize Pet Mana Regen Base].ID}||${Me.Buff[Thaumatize Pet Mana Regen Boost I].ID}||${Me.Buff[Thaumatize Pet Mana Regen Boost II].ID}||${Me.Buff[Thaumatize Pet Mana Regen Boost III].ID}||${Me.Buff[Thaumatize Pet Mana Regen Boost IV].ID})
	/noparse /declare GoM string outer (${Me.Song[Gracious Mana].ID}||${Me.Song[Gift of Mana].ID}||${Me.Song[Gift of Radiant Mana].ID}||${Me.Song[Gift of Dreamlike Exquisite Radiant Mana].ID}||${Me.Song[Gift of Exquisite Radiant Mana].ID}||${Me.Song[Gift of Amazing Exquisite Radiant Mana].ID}||${Me.Song[Gift of Phantasmal Exquisite Radiant Mana].ID})
	|** Attempting to add logic to declare missing GoMSpellName${i} variable. **|
	|/if (${Me.Song[Gracious Mana].ID}) {
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gracious Mana"
	|} else /if (${Me.Song[Gift of Mana].ID}) {
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gift of Mana"
	|} else /if (${Me.Song[Gift of Radiant Mana].ID})
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gift of Radiant Mana"
	|} else /if (${Me.Song[Gift of Dreamlike Exquisite Radiant Mana].ID}) {
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gift of Dreamlike Exquisite Radiant Mana"
	|} else /if (${Me.Song[Gift of Exquisite Radiant Mana].ID}) {
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gift of Exquisite Radiant Mana"
	|} else /if (${Me.Song[Gift of Amazing Exquisite Radiant Mana].ID}) {
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gift of Amazing Exquisite Radiant Mana"
	|} else /if (${Me.Song[Gift of Phantasmal Exquisite Radiant Mana].ID}) {
	|	/if (!${Defined[GoMSpellName1]}) /declare GoMSpellName1 string outer "Gift of Phantasmal Exquisite Radiant Mana"
	|}
	/noparse /declare CastCounts string outer (${Macro.Return.Equal[CAST_SUCCESS]}||${Macro.Return.Equal[CAST_IMMUNE]}||${Macro.Return.Equal[CAST_NOTHOLD]})
	/noparse /declare ImNotReady string outer (${Me.Casting.ID}||${Me.Invis} && !${AutoBreakInvis} && !${AutoInvis}||${Me.Moving}||${Me.Feigning}||${MMOBugs.ZoneSecs} && ${MMOBugs.ZoneSecs}<20||${Debuff.Invulnerable}||${Debuff.Silenced})
	/noparse /declare ValidEnemy string outer ((${Target.Type.Equal[npc]}||${Target.Master.Type.Equal[npc]}||${Target.Master.Type.Equal[corpse]})  && !${IgnoreList.Find[${Spawn[${Target.CleanName}]}]} && !${IgnoreAll.Find[${Spawn[${Target.CleanName}]}]} && ${Target.LineOfSight} && ${Target.ID}==${TarID} && ${Target.ID}!=${Me.Pet.ID})
	/noparse /declare ValidSpell string outer ((${FindItem[${${CurrentSub}SpellName${i}}].ItemSlot} && !${FindItem[${${CurrentSub}SpellName${i}}].Timer})||(${Me.CurrentMana}>=${Spell[${${CurrentSub}SpellName${i}}].Mana}||${Me.AltAbility[${${CurrentSub}SpellName${i}}]}) && ${${CurrentSub}Use${i}} && (!${${CurrentSub}Recast${i}}||${${CurrentSub}IgnoreRecast${i}}))
	/noparse /declare CanCastOnMob string outer (${Target.LineOfSight} && ((${Target.Distance}<=${Spell[${${CurrentSub}SpellName${i}}].AERange}||${Target.Distance}<=${Spell[${${CurrentSub}SpellName${i}}].Range}||${Target.Distance}<=${Me.AltAbility[${${CurrentSub}SpellName${i}}].Spell.AERange}||${Target.Distance}<=${Me.AltAbility[${${CurrentSub}SpellName${i}}].Spell.Range}||${Target.Distance}<=${FindItem[${${CurrentSub}SpellName${i}}].Spell.Range})||${Spell[${${CurrentSub}SpellName${i}}].SpellType.NotEqual[detrimental]} && ${FindItem[${${CurrentSub}SpellName${i}}].Spell.SpellType.NotEqual[detrimental]}))
	/noparse /declare ShouldCastOnMob string outer ((${Range.Between[${${CurrentSub}StopAtMobPctHP${i}},${${CurrentSub}UseAtMobPctHP${i}}:${Target.PctHPs}]}||!${Defined[${CurrentSub}UseAtMobPctHP${i}]}) && !${${CurrentSub}On${i}} && (!${${CurrentSub}MaxTries${i}}||${${CurrentSub}MaxTries${i}}>${${CurrentSub}Resisted${i}}) && (${Target.Type.Equal[npc]}||${Target.Master.Type.Equal[npc]}||${Target.Master.Type.Equal[corpse]}))
	/noparse /declare ResistCheck string outer (!${${Spell[${${CurrentSub}SpellName${i}}].ResistType}ImmuneList.Find[${Target.CleanName}]}||${Target.Name.Length}>${${Spell[${${CurrentSub}SpellName${i}}].ResistType}ImmuneList.Length})
	/noparse /declare GoMCheck string outer (${Me.Song[${GoMSpellIcon${i}}].ID} && ${Me.CurrentMana}>=${Spell[${GoMSpellName${i}}].Mana} && ${Me.SpellReady[${GoMSpellName${i}}]} && ${Target.Distance}<=${Spell[${GoMSpellName${i}}].Range} && ${Target.LineOfSight} && !${${Spell[${GoMSpellName${i}}].ResistType}ImmuneList.Find[${Target.CleanName}]})
	/noparse /declare ValidNamed string outer ((${Target.Named}||${Target.Name.Find[#]}) && ${TarID}==${Target.ID} && !${IgnoreList.Find[${Spawn[${Target.CleanName}]}]} && !${IgnoreAll.Find[${Spawn[${Target.CleanName}]}]})
	/noparse /declare CastIsReady string outer ((${Me.SpellReady[${${CurrentSub}SpellName${i}}]}||${Me.CombatAbilityReady[${${CurrentSub}SpellName${i}}]}||${Me.AltAbilityReady[${${CurrentSub}SpellName${i}}]})||(!${Me.Gem[${${CurrentSub}SpellName${i}}]} && (${ForceMem${CurrentSub}}||${CurrentSub.Equal[SelfBuff]}) && ${${CurrentSub}SpellGem${i}.Find[gem]})||(${FindItem[${${CurrentSub}SpellName${i}}].ItemSlot} && !${FindItem[${${CurrentSub}SpellName${i}}].Timer}))
	/noparse /declare SpellStacks string outer ((${Spell[${${CurrentSub}SpellIcon${i}}].Stacks}||${Spell[${${CurrentSub}SpellIcon${i}} ].Stacks}) && !${Me.Buff[${${CurrentSub}SpellIcon${i}}].ID} && !${Me.Song[${${CurrentSub}SpellIcon${i}}].ID})
	/noparse /declare NamedOk string outer (${Target.Named}||${Target.Name.Find[#]} && !${Target.Master.ID}||!${${CurrentSub}NamedOnly${i}})
	/noparse /declare Named string outer (${Target.Named}||${Target.Name.Find[#]} && !${Target.Master.ID})
	/noparse /declare AggroOk string outer (${Melee.AggroMode}||${Group.MainTank.ID}==${Me.ID}||!${${CurrentSub}ForAggro${i}})
	/noparse /declare ValidSpellType string outer ((${Spell[${${CurrentSub}SpellName${i}}].TargetType.Find[${Target.Body}]}||!${Select[${Spell[${${CurrentSub}SpellName${i}}].TargetType},Animal,Humanoid,Undead,Plant,Summoned,Uber Giants,Uber Dragons,AE Undead,AE Summoned]}) && (${Spell[${${CurrentSub}SpellName${i}}].ReagentID[1]}==NULL||${Spell[${${CurrentSub}SpellName${i}}].ReagentID[1]}>0 && ${FindItemCount[${Spell[${${CurrentSub}SpellName${i}}].ReagentID[1]}]}>=${Spell[${${CurrentSub}SpellName${i}}].ReagentCount[1]}||${Spell[${${CurrentSub}SpellName${i}}].ReagentID[1]}<0))
	/noparse /declare Twincast string outer (${Me.Song[Twincast].ID}||${Me.Song[Twincast Rk. II].ID}||${Me.Song[Twincast Rk. III].ID}||${Me.Song[Improved Twincast].ID}||${Me.Buff[Twincast].ID}||${Me.Buff[Improved Twincast].ID})
	/noparse /declare Facing string outer ${Range.Between[0,30:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Me.Heading.Degrees}]}]}]}
	/noparse /declare FacingMe string outer ${Range.Between[175,180:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Target.Heading.Degrees}]}]}]}
	/if (${NeedLoad}) /call NeedLoad
	/call OptionsLoad
	
	|Load calls for all items in OptionsCheck from a list |FINDME|
	/for i 1 to ${OptionsLoadList.Count[|]}
		/if (${OptionsLoadList.Arg[${i},|].NotEqual[NULL]}) /call ${OptionsLoadList.Arg[${i},|]}Load
	/next i
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
	/for i 1 to ${LoadListVar.Count[|]}
		/call IniLoad "MyIni" "${LoadListVar.Arg[${i},|]}" "${LoadListVarType.Arg[${i},|]}" "Settings" "${LoadListDefault.Arg[${i},|]}"
	/next i
	/call CombatLoad
	/call MakeList
	/if (${AnnounceEvents.Equal[NULL]}) /mmoini "MyIni" "Settings" "AnnounceEvents" "TRY|CAST_SUCCESS|CAST_IMMUNE|CAST_RESIST"
	/varset AssistAt ${MMOIni[MyIni,Assist,AssistAt,95]}
	/if (!${AssistAt}) /cechob \arNo \awAssistAt \aridentified.  Edit the [Assist] Section of your INI to show AssistAt=95, where 95 is the Percent Health to begin attacking. 
	/varset AssistAt ${MMOIni[MyIni,Assist,AssistPC,95]}
	/if (!${Bool[${AssistPC}]}) /cechob \arNo \awAssistPC \aridentified.  Assign one as a parameter. Usage: /mac ThisMac Asmallchild
	
	/call LootLoad
	/if (!${Defined[AEMode]}) /declare AEMode bool outer
	/declare TestVariable int outer 0
	
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/declare PBAEMezSpellName string outer NULL
		/declare PBAEMezSpellGem int outer 0
		/if (!${Defined[BeamTimer]}) /declare BeamTimer timer outer 5s
		/if (!${Defined[BeamUsed]}) /declare BeamUsed int outer 0
		/for i 1 to 12
			/if (${Spell[${Me.Gem[${i}]}]Attrib[1]}==35 && ${Spell[${Me.Gem[${i}]}].TargetType.Equal[PB AE]}) {
				/varset PBAEMezSpellName ${Me.Gem[${i}]}
				/varset PBAEMezSpellGem gem${i}
			}
		/next i
	}
	/if (${Defined[AABuy]}) /call AABuyLoad
	/call CampfireLoad
	/declare Outside bool outer TRUE

	/for i 1 to 10
		/declare Timer${i} timer outer
		/declare String${i} string outer
		/declare Float${i} float outer
		/declare Bool${i} bool outer
		/declare Int${i} int outer
	/next i

	/call EchoHandlerLoad

	/call Debug 3 "Leaving Sub Load"
/return

|################> Sub Conditions <#######################
Sub ConditionsLoad
	/call Debug 3 "In Sub ConditionsLoad"
	/declare i int local
	/declare ConditionsTotal int outer ${Ini[MyIni,Conditions,ConditionsTotal,0]}
	/if (!${ConditionsTotal}) {
		/mmoini "MyIni" "Conditions" "ConditionsTotal" "0"
		/for i 1 to 10
			/mmoini "MyIni" "Conditions" "Conditions${i}"
		/next i
	/if (!${ConditionsTotal}) /return

	/for i 1 to ${ConditionsTotal}
		/docommand /noparse ${Ini[MyIni,Conditions,Conditions${i},/echo Condition${i} is blank]}
	/next i
	/call Debug 3 "Leaving Sub ConditionsLoad"
/return

|##############################>  Misc Events and Load subs  <############################
Sub NeedLoad
	/call Debug 3 "In Sub NeedLoad"
	/cechob \agBuilding INI: MyIni
	/declare AASpire string outer |Fundament: Third Spire of Ancestors|Fundament: Second Spire of Arcanum|Fundament: Second Spire of Divinity|Fundament: Third Spire of Elements|Fundament: Second Spire of Enchantment|Fundament: First Spire of Holiness|Fundament: Third Spire of Nature|Fundament: Third Spire of Necromancy|Fundament: Third Spire of Savagery|Fundament: Second Spire of the Minstrels|Fundament: Third Spire of the Pathfinders|Fundament: Second Spire of the Rake|Fundament: First Spire of the Reavers|Fundament: Third Spire of the Savage Lord|Fundament: Second Spire of the Sensei|Fundament: Third Spire of the Warlord|
	/declare AASpire2 string outer Fundament: Second Spire of Ancestors|Fundament: Third Spire of Arcanum|Fundament: Third Spire of Divinity|Fundament: First Spire of Elements|Fundament: Third Spire of Enchantment|Fundament: Second Spire of Holiness|Fundament: Second Spire of Nature|Fundament: First Spire of Necromancy|Fundament: Second Spire of Savagery|Fundament: Third Spire of the Minstrels|Fundament: First Spire of the Pathfinders|Fundament: Third Spire of the Rake|Fundament: Third Spire of the Reavers|Fundament: Second Spire of the Savage Lord|Fundament: Third Spire of the Sensei|Fundament: Second Spire of the Warlord|
	/declare AASpire3 string outer Fundament: First Spire of Ancestors|Fundament: First Spire of Arcanum|Fundament: First Spire of Divinity|Fundament: Second Spire of Elements|Fundament: First Spire of Enchantment|Fundament: Third Spire of Holiness|Fundament: First Spire of Nature|Fundament: Second Spire of Necromancy|Fundament: First Spire of Savagery|Fundament: First Spire of the Minstrels|Fundament: Second Spire of the Pathfinders|Fundament: First Spire of the Rake|Fundament: Second Spire of the Reavers|Fundament: First Spire of the Savage Lord|Fundament: First Spire of the Sensei|Fundament: First Spire of the Warlord|
	/declare AADebuff string outer Turgur's Swarm|Malosinete|Pathosis|Dreary Deeds|Bladed Song|Bite of Tashani|Orb of Tishan|Hand of Ro|Fixation of Ro|Blessing of Ro|Scent of Terris|Death's Malaise|Crippling Sparkle|Ethereal Manipulation|Tigir's Insect Swarm|Wind of Malosinete|Crippling Apparition|Crippling Spirit|Lower Element|
	/declare AANuke string outer Force of Will|Force of Elements|Vicious Bite of Chaos|Disruptive Persecution|Harm Touch|Storm Strike|Force of Flame|Force of Ice|Volatile Arrow|
	/declare AADot string outer Mental Contortion|
	/declare AASwarmPet string outer Phantasmal Opponent|Army of the Dead|Swarm of Decay|Rise of Bones|Song of Stone|Servant of Ro|Host of the Elements|Nature's Guardian|Celestial Hammer|Chattering Bones|Call of Xuzl|Spirit Call|Attack of the Warders|Illusory Ally|Pack Hunt|
	/declare AAArcanum string outer Empowered Focus of Arcanum|Enlightened Focus of Arcanum|Acute Focus of Arcanum|Focus of Arcanum|
	/declare AAWizFam string outer Kerafyrm's Prismatic Familiar|Improved Familiar|Ro's Flaming Familiar|Druzzil's Mystical Familiar|E'ci's Icy Familiar|
	/declare AAWizMancy string outer Pyromancy|Arcomancy|Cryomancy|
	/declare AAWizFury string outer Fury of Kerafyrm|Fury of Ro|Fury of Druzzil|Fury of Eci|
	/declare AAMagCore string outer Fire Core|Vapor Core|Stone Core|Ice Core|
	/declare AAMagForm string outer Heart of Flames|Heart of Vapor|Heart of Stone|Heart of Ice|
	/declare AARngArrow string outer Poison Arrows|Glacial Arrow|Flaming Arrows|Frost Arrows|
	/declare AASnare string outer Encroaching Darkness|Entrap|Halt the Dead|Atol's Shackles|Atol's Unresistable Shackles|
	/declare AAStun string outer Disruptive Persecution|Divine Stun|Force of Disruption|
	/declare AAMez string outer Dirge of the Sleepwalker|Nightmare Stasis|Beam of Slumber|Wave of Slumber|Dead Mesmerization|Scintillating Beam|
	/declare AAHeal string outer Burst of Life|Beacon of Life|Convergence of Spirits|Union of Spirits|Lay on Hands|Hand of Piety|Divine Arbitration|Aegis of Superior Divinity|Call of the Ancients|Ancestral Aid|Celestial Regeneration|Focused Celestial Regeneration|Exquisite Benediction|Gift of Life|
	/declare AAHealSelf string outer Warder's Gift|
	/declare AAJolt string outer Concussive Intuition|Death Peace|Improved Death Peace|Arcane Whisper|Playing Possum|Soothing Words|Roar of Thunder|Sleight of Hand|
	/declare AAFade string outer Cover Tracks|Divine Peace|Death's Effigy|Fading Memories|Balefire Burst|Imitate Death|Inconspicuous Totem|Self Stasis|A Hole in Space|Drape of Shadows|Veil of the Underbrush|Escape|Stealthy Getaway|Howl of the Warlord|
	/declare AAFeignDeath string outer Death Peace|Improved Death Peace|Playing Possum|
	/declare AAFightBuff string outer Yaulp|Color Shock|Silent Casting|Reluctant Benevolence|Improved Twincast|Shield of Reverence|Twincast Rk. II|Twincast Rk. III|Scourge Skin|Dampen Resistance|Guardian of the Forest|Group Guardian of the Forest|Auspice of the Hunter|Outrider's Attack|Outrider's Accuracy|Scout's Mastery of Fire|Envenomed Blades|Rogue's Fury|Dirty Fighting|Resplendent Glory|Imperator's Command|
	/declare AARez string outer Gift of Resurrection|Call of the Wild|Blessing of Resurrection|Divine Resurrection|Restoration of Life|Incarnate Anew|Convergence|Rejuvenation of Spirit|
	/declare AAIllusion string outer Elemental Form: Air|Elemental Form: Earth|Elemental Form: Fire|Elemental Form: Water|Noteworthy Disguise: Drake|
	/declare AASelfBuff string outer  Perfected Dead Men Floating|Pact of the Wolf|Bobbing Corpse|Dead Man Floating|Preincarnation|Selo's Sonata|Sionachie's Crescendo|Eldritch Rune|Mind Over Matter|Veil of Mindshadow|Noteworthy Disguise: Drake|Pact of the Wurine|Elemental Ward|Cascade of Decay|
	/declare AAMainTankBuff string outer Divine Guardian|Spirit Guardian|Focused Celestial Regeneration|
	/declare AACure string outer Radiant Cure|Purified Spirits|Ward of Purity|Purification|Blessing of Purification|Purify Body|Group Purify Soul|Embrace the Decay|Nature's Salve|Agony of Absolution|Purge Poison|Purity of Death|
	/declare AABuff string outer  Perfected Dead Men Floating|Perfected Dead Man Floating|Spirit of Eagles|Marr's Salvation|Group Pact of the Wolf|Communion of the Cheetah|Talisman of Celerity|Selo's Sonata|Group Perfected Levitation|Perfected Levitation|Spirit of Eagle|Spirit Walk|Group Spirit Walk|Dead Man Floating|Flight of Eagles|Voice of Thule|
	/declare AAIgnore string outer Mass Group Buff|Tranquil Blessings|Origin|Harmonic Dissonance|Harmonious Arrow|Gate|Group Shrink|Shrink|Spiritual Channeling|Turn Undead|Summon Remains|Act of Valor|Forceful Rejuvenation|Sense the Dead|Fog of Memories|Project Illusion|Aspect of Zomm|Turn Summoned|Summon Tome of the Hero's Journey|Banestrike|Flesh to Bone|Wake the dead|Call to Corpse|Fear Storm|Blood Magic|Blanket of Forgetfulness|Mark of Travel|Tertiary Recall|Languid Bite|Call of the Herald|Vainglorious Shout|Bind Affinity|Tireless Sprint|Cry of Battle|Untamed Rage|Identify|Scout's Mastery of Ice|Crippling Strike|Eye Gouge|Destructive Force|Appraisal|Rampage|War Cry|Friendly Stasis|Hand of Disruption|Dragon Punch|
	/declare AAEnchant string outer Mass Enchant Palladium|Enchant Palladium|Enchant Palladium Trio|
	/declare AAInvis string outer Shared Camouflage|Innate Camouflage|Cover Tracks|Silent Presence|Spirit Walk|Group Silent Presence|Group Spirit Walk|Cloak of Shadows|Shauri's Sonorious Clouding|Group Perfect Invisibility|Gather Shadows|Improved Natural Invisibility|
	/declare AAImHit string outer Improved Sanctuary|Sanctuary|Outrider's Evasion|Shield of Notes|Hymn of the Last Stand|Doppelganger|Mind Crash|Host in the Shell|Companion of Necessity|Hold the Line|Divine Retribution|Blessing of Sanctuary|Embalmer's Carapace|Improved Death Peace|Lyrical Prankster|Ancestral Guard|Armor of Ancestral Spirits|Uncanny Resilience|Protection of the Spirit Wolf|Tumble|Warlord's Bravery|Mark of the Mage Hunter|Blade Guardian|Brace For Impact|
	/declare AAVeteran string outer Lesson of the Devoted|Infusion of the Faithful|Chaotic Jester|Expedient Recovery|Steadfast Servant|Staunch Recovery|Intensity of the Resolute|Throne of Heroes|Armor of Experience|Summon Resupply Agent|Summon Clockwork Banker|Summon Permutation Peddler|Summon Personal Tribute Master|Glyph of Indeterminable Reward|
	/declare AAInvisUndead string outer Group Perfected Invisibility to Undead|Innate Invis to Undead|Cloak of Light|Fool the Fallen|
	/declare AARoot string outer Grasp of Sylvan Spirits|Blessed Chains|Virulent Paralysis|Shackles of Tunare|Beguiler's Directed Banishment|Beguiler's Banishment|Strong Root|Paralytic Spores|Pestilent Paralysis|Bony Grasp of Death|
	/declare AAMount string outer Steed of Souls|Abyssal Steed|Unholy Steed|Wicked Steed|Holy Warhorse|Valiant Steed|Divine Steed|Hallowed Steed|
	/declare AAAggro string outer Projection of Doom|Ageless Enmity|Projection of Piety|Projection of Fury|Blast of Anger|Warlord's Grasp|
	/declare AAAEAggro string outer Explosion of Spite|Explosion of Hatred|Beacon of the Righteous|Area Taunt|Enhanced Area Taunt|Improved Explosion of Hatred|Improved Explosion of Spite|
	/declare AAPet string outer Aegis of Kildrukaun|Hobble of Spirits|Second Wind Ward|
	/declare AAPetIgnore string outer Suspended Minion|Summon Companion|Companion's Relocation|Diminutive Companion|Shared Health|
	/declare AAPetBuff string outer Aegis of Kildrukaun|Virulent Talon|Savage Lord's Totem|Focus of Primal Elements|Spiritcaller Totem of the Feral|Staff of Elemental Essence|Hobble of Spirits|Second Wind Ward|
	/declare AAHealPet string outer Replenish Companion|Mend Companion|Companion's Blessing|Divine Companion Aura|
	/declare AAPush string outer Unbridled Strike of Fear|Spiritual Rebuke|Repel the Wicked|Sonic Displacement|Paralytic Spores|Virulent Paralysis|Wall of Wind|Silent Displacement|Spiritual Rebuke|Press the Attack|Repel the Wicked|Unbridled Strike of Fear|Beam of Displacement|
	/declare AAPull string outer Hate's Attraction|Divine Call|Lure of the Siren's Song|Grappling Strike|Distant Strike|Moving Mountains|
	/declare AALeap string outer Hate Step|Leap of Faith|Lyre Leap|Netherstep|Dimensional Instability|Dimensional Shield|Neshika's Blink|Whisperwind|
	/declare AADA string outer Harmshield|Bestow Divine Aura|Cascading Divine Aura|
	/declare AALifetap string outer Leech Touch|Vicious Bite of Chaos|Dying Grasp|
	/declare AAGlyph string outer Glyph of Angry Thoughts|Glyph of Draconic Potential|Glyph of Courage|Glyph of Dragon Scales|Glyph of Stored Life|Glyph of Arcane Secrets|Glyph of the Cataclysm|Glyph of Destruction|Glyph of Genari Might|Glyph of the Master|Glyph of Lost Secrets|Glyph of Frantic Infusion|
	/declare AASummon string outer Azure Mind Crystal|Sanguine Mind Crystal|Mass Enchant Dwerium|Small Modulation Shard|Medium Modulation Shard|Large Modulation Shard|Giant Modulation Shard|
	/declare AACharm string outer Edict of Command|Dire Charm|
	/declare AAPort string outer Nexus Gate|Exodus|Teleport Bind|Translocate|Teleport|Translocational Anchor|Secondary Recall|Abscond|Call of the Hero|Call Hither|Egress|Levant|
	/declare AAManaBurn string outer Mana Burn|Mana Blaze|Volatile Mana Blaze|Mana Blast|
	/declare AAMana string outer Harvest of Druzzil|Quiet Miracle|Cannibalization|Gather Mana|Mana Draw|Death Bloom|Mana Reserve|Fundament: Second Spire of Enchantment|Veturika's Perseverance|Death Blossom|Paragon of Spirit|Thought Leech|Marr's Gift|
	/declare AAHarvest string outer Harvest of Druzzil|Quiet Miracle|Cannibalization|Gather Mana|Mana Draw|Death Bloom|Mana Reserve|Fundament: Second Spire of Enchantment|Veturika's Perseverance|Death Blossom|Paragon of Spirit|
	/declare AAClickyNuke string outer Aurora, the Heartwood Blade|Blade of Vesagran|Blessed Spiritstaff of the Heyokah|Champion's Sword of Eternal Power|Crafted Talisman of Fates|Deathwhisper|Fatestealer|Fistwraps of Celestial Discipline|Heartwood Blade|Innoruuk's Dark Blessing|Innoruuk's Voice|Kreljnok's Sword of Eternal Power|Nightbane, Sword of the Valiant|Nightshade, Blade of Entropy|Prismatic Dragon Blade|Raging Taelosian Alloy Axe|Redemption|Soulwhisper|Staff of Everliving Brambles|Staff of Living Brambles|Staff of Phenomenal Power|Staff of Prismatic Power|Transcended Fistwraps of Immortality|Vengeful Taelosian Blood Axe|
	/declare AAAura string outer Twincast Aura|Holy Aura|Disciple's Aura|Aura of Rage|Champion's Aura|
	/declare AAPulling string outer Throw Stone|Boastful Bellow|
	/declare AABattleLeap string outer Furious Leap|Stomping Leap|Battle Leap|
	/declare AAEndurance string outer Communion of Blood|

	/noparse /declare SelfBuffCheck string outer (${Spell[${bookcheck}].TargetType.Equal[Self]} && ${Spell[${bookcheck}].Duration}>50 && !${bookcheck.Find[illusion]})
	/noparse /declare LifetapCheck string outer (${Spell[${bookcheck}].TargetType.Equal[Lifetap]})
	/noparse /declare NukeCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && !${Spell[${bookcheck}].Duration} && (${Spell[${bookcheck}].Category.Find[Direct Damage]}||${Spell[${bookcheck}].Skill.Equal[Archery]}))
	/noparse /declare DotCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && ${Spell[${bookcheck}].Duration}>=2 && ${Spell[${bookcheck}].Category.Find[Damage Over Time]})
	/noparse /declare FightBuffCheck string outer (${Spell[${bookcheck}].TargetType.Equal[Self]} && ${Range.Between[1,51:${Spell[${bookcheck}].Duration}]})
	/noparse /declare MainTankBuffCheck string outer  ((${Spell[${bookcheck}].TargetType.Equal[single]}||${Spell[${bookcheck}].TargetType.Equal[group v2]}) && ${Spell[${bookcheck}].SpellType.Equal[beneficial]} && (${Range.Between[4,90:${Spell[${bookcheck}].Duration}]}||${Spell[${bookcheck}].Name.Find[Promised]}) && ${Spell[${bookcheck}].Slot[1].Left[8].NotEqual[Reaction]})
	/noparse /declare HealSingleCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && !${Spell[${bookcheck}].Duration} && ${Spell[${bookcheck}].SpellType.Equal[beneficial]} && (${Spell[${bookcheck}].Slot[1].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[2].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[3].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[4].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[5].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[6].Left[21].Equal[Increase Hitpoints by]}))
	/noparse /declare HealGroupCheck string outer ((${Select[${Spell[${bookcheck}].TargetType},group v1,group v2]}||${Spell[${bookcheck}].TargetType.Equal[self]} && (${Spell[${bookcheck}].Slot[1].Equal[UnknownEffect400]}||${Spell[${bookcheck}].Slot[1].Find[Increase Current HP by]} && ${Spell[${bookcheck}].AERange})) && !${Spell[${bookcheck}].Duration} && ${Spell[${bookcheck}].SpellType.Equal[beneficial]} && (${Spell[${bookcheck}].Slot[1].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[2].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[3].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[4].Left[21].Equal[Increase Hitpoints by]}))
	/noparse /declare HealSelfCheck string outer (${Spell[${bookcheck}].TargetType.Equal[self]} && !${Spell[${bookcheck}].Duration} && ${Spell[${bookcheck}].Category.Equal[Heals]})
	/noparse /declare HealSplashCheck string outer (${Select[${Spell[${bookcheck}].TargetType},Unknown,Free Target]} && ${Spell[${bookcheck}].SpellType.Equal[beneficial]} && ${Spell[${bookcheck}].Name.Find[splash]})
	/noparse /declare StunCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && ${Spell[${bookcheck}].Subcategory.Equal[Stun]})
	/noparse /declare DebuffCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && ${Spell[${bookcheck}].SpellType.Equal[detrimental]}  && ${Spell[${bookcheck}].Duration}  && ${Select[${Spell[${bookcheck}].Skill},Alteration,Abjuration]} && ${Spell[${bookcheck}].Slot[1].Left[13].NotEqual[Increase Hate]} && ${Spell[${bookcheck}].Slot[2].Left[13].NotEqual[Increase Hate]} && ${Spell[${bookcheck}].Slot[5].Left[13].NotEqual[Increase Hate]})
	/noparse /declare HealBalanceCheck string outer (${Me.Class.ShortName.Equal[clr]})
	/noparse /declare XHealCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && !${Spell[${bookcheck}].Duration} && ${Spell[${bookcheck}].SpellType.Equal[beneficial]} && (${Spell[${bookcheck}].Slot[1].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[2].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[3].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[4].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[5].Left[21].Equal[Increase Hitpoints by]}||${Spell[${bookcheck}].Slot[6].Left[21].Equal[Increase Hitpoints by]}))
	/noparse /declare BuffCheck string outer  ((${Spell[${bookcheck}].TargetType.Equal[single]}||${Spell[${bookcheck}].TargetType.Find[group]}||${Spell[${bookcheck} Rk. II].TargetType.Find[group]}) && ${Spell[${bookcheck}].SpellType.Equal[beneficial]} && ((${Range.Between[90,999999:${Spell[${bookcheck}].Duration}]}||${Range.Between[1,3:${Spell[${bookcheck}].Duration}]})||${Spell[${bookcheck}].Name.Find[Promised]}) && ${Spell[${bookcheck}].Slot[1].Left[8].NotEqual[Reaction]})
	/noparse /declare BuffRankCheck string outer (${Target.Buff[${iTargetBuff}].ID}==${Spell[${BuffOrigSpellIcon${iBuff}}].ID}||${Target.Buff[${iTargetBuff}].ID}==${Spell[${BuffOrigSpellIcon${iBuff}} Rk. II].ID}||${Target.Buff[${iTargetBuff}].ID}==${Spell[${BuffOrigSpellIcon${iBuff}} Rk. III].ID}||${Target.Buff[${iTargetBuff}].ID}==${Spell[${BuffOrigIconAlt${iBuff}}].ID}||${Target.Buff[${iTargetBuff}].ID}==${Spell[${BuffOrigIconAlt${iBuff}} Rk. II].ID}||${Target.Buff[${iTargetBuff}].ID}==${Spell[${BuffOrigIconAlt${iBuff}} Rk. III].ID})
	/noparse /declare JoltCheck string outer (${Spell[${bookcheck}].TargetType.Equal[single]} && ${Spell[${bookcheck}].SpellType.Equal[detrimental]}  && (${Spell[${bookcheck}].Slot[1].Left[13].Equal[Decrease Hate]}||${Spell[${bookcheck}].Slot[2].Left[13].Equal[Decrease Hate]}))
	/noparse /declare MezCheck string outer (${Spell[${bookcheck}].Slot[1].Left[11].Equal[Mesmerize(2]} && ${Spell[${bookcheck}].TargetType.Equal[single]}||${Spell[${bookcheck}].Slot[1].Left[11].Equal[Mesmerize(1]} && ${Spell[${bookcheck}].TargetType.Equal[single]})
	/noparse /declare AEMezCheck string outer (${Spell[${bookcheck}].Slot[1].Left[11].Equal[Mesmerize(2]} && ${Spell[${bookcheck}].TargetType.Equal[targeted ae]})
	/noparse /declare PBAEMezCheck string outer (${Spell[${bookcheck}].Slot[1].Left[11].Equal[Mesmerize(1]} && (${Spell[${bookcheck}].TargetType.Equal[pb ae]}||${Spell[${bookcheck} Rk. II].TargetType.Equal[pb ae]}) && !${bookcheck.Find[lullaby]} && !${bookcheck.Find[slumber of]})
	/noparse /declare AuraCheck string outer (${Spell[${bookcheck}].Slot[1].Find[Aura Effect]})
	/noparse /declare RootCheck string outer (${Spell[${bookcheck}].Slot[2].Equal[root]} && ${Spell[${bookcheck}].SpellType.Equal[detrimental]})
	/call Debug 3 "Leaving Sub NeedLoad"
/return

Sub OptionsLoad
	/call Debug 3 "In Sub OptionsLoad"
	|MasterList=Bard|AA|Aura|AutoClickies|Buff|Camp|Campfire|CheckTarget|ClickyMaintenance|ClickyNuke|Debuff|Disc|Dot|FeignDeath|FightBuff|Heal|HealSingle|HealGroup|HealBalance|HealPet|HealSelf|Jolt|Lifetap|MainTankBuff|Mez|Nuke|Pet|Rez|Root|SelfBuff|Snare|Stun|SummonTank|XHeal|AABuy|Follow|ImHit|Ignore|EchoHandler|Endurance|Mana|Merc|Pulling|SetupAdvLootVars|
	/declare OptionsLoadList string outer
	/declare OptionsLoadListAll string outer Plugin|CheckTarget|Ignore|Follow|Camp|Alias|EchoHandler|ImHit|SummonTank|Leap|Custom|Campfire|
	/declare OptionsCheck string outer ${Ini[MyIni,Settings,OptionsCheck]}
	/if (${OptionsCheck.Equal[NULL]}) {
		/if (${Me.Class.ShortName.Equal[BRD]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Bard|Debuff|Disc|Snare|SelfBuff|
		/if (${Select[${Me.Class.ShortName},MNK,ROG,BER]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Disc|Snare|
		/if (${Select[${Me.Class.ShortName},WAR]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Disc|Aggro|
		/if (${Select[${Me.Class.ShortName},DRU,SHM,]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Debuff|Dot|FightBuff|HealSingle|HealGroup|HealSelf|HealPet|MainTankBuff|Nuke|Pet|Rez|Root|SelfBuff|Snare|XHeal|
		/if (${Select[${Me.Class.ShortName},CLR]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Debuff|Dot|FightBuff|HealSingle|HealGroup|HealSelf|HealBalance|HealSplash|HealPet|MainTankBuff|Nuke|Rez|Root|SelfBuff|Snare|Stun|XHeal|
		/if (${Select[${Me.Class.ShortName},PAL]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Aggro|Debuff|Disc|Dot|FightBuff|HealSingle|HealGroup|HealSelf|HealSplash|HealPet|SelfBuff|Nuke|Rez|Root|SelfBuff|Snare|Stun|XHeal|
		/if (${Select[${Me.Class.ShortName},RNG]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Disc|Dot|FightBuff|HealSingle|HealPet|Jolt|MainTankBuff|Nuke|Root|SelfBuff|Snare|XHeal|
		/if (${Select[${Me.Class.ShortName},BST]}) /varset OptionsCheck |Pulling|Merc|AA|Buff|ClickyMaintenance|ClickyNuke|Fade|FeignDeath|Debuff|Disc|Dot|FightBuff|HealSingle|HealPet|Nuke|Pet|Root|SelfBuff|Snare|XHeal|
		/if (${Select[${Me.Class.ShortName},SHD]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|FeignDeath|Disc|Dot|FightBuff|Lifetap|Nuke|Pet|SelfBuff|Snare|Aggro|
		/if (${Select[${Me.Class.ShortName},NEC]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|FeignDeath|Debuff|Dot|FightBuff|HealSingle|HealPet|XHeal|Jolt|Lifetap|Mez|Nuke|Pet|Root|SelfBuff|Snare|
		/if (${Select[${Me.Class.ShortName},MAG]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Debuff|Dot|FightBuff|HealPet|Nuke|Pet|SelfBuff|MainTankBuff|
		/if (${Select[${Me.Class.ShortName},ENC]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Debuff|Dot|FightBuff|Mez|Nuke|Pet|Root|SelfBuff|Stun|
		/if (${Select[${Me.Class.ShortName},WIZ]}) /varset OptionsCheck |Pulling|Merc|AA|Aura|Buff|ClickyMaintenance|ClickyNuke|Fade|Debuff|FightBuff|Jolt|Nuke|Root|SelfBuff|Snare|Stun|
		/if (${Select[${Me.Class.ShortName},BST,CLR,DRU,ENC,SHM,PAL,RNG,SHD,NEC,MAG,WIZ]}) /varset OptionsCheck ${OptionsCheck}Mana|ModRod|
		/if (${Select[${Me.Class.ShortName},PAL,SHD,WAR,BER,ROG,MNK]}) /varset OptionsCheck ${OptionsCheck}Endurance|
		/mmoini "MyIni" "Settings" "OptionsCheck" "${OptionsCheck}"
	}
	/declare OptionsCheckRaid string outer ${Ini[MyIni,Settings,OptionsCheckRaid]}
	/if (${OptionsCheckRaid.Equal[NULL]}) /mmoini "MyIni" "Settings" "OptionsCheckRaid" "${OptionsCheck}"
	/varset OptionsLoadList ${OptionsLoadListAll}${OptionsCheck}
	/if (${OptionsCheck.Find[NULL|]}) /varset OptionsCheck ${OptionsCheck.Replace[NULL|,]}
	/if (${OptionsCheck.Find[NULL]}) /varset OptionsCheck ${OptionsCheck.Replace[NULL,]}
	/if (${OptionsCheck.Find[||]}) /varset OptionsCheck ${OptionsCheck.Replace[||,|]}
	/if (${OptionsCheck.Find[||]}) /varset OptionsCheck ${OptionsCheck.Replace[||,|]}
	/call Debug 3 "Leaving Sub OptionsLoad"
/return

Sub IniLoad(ininame,var,vartype,sec,default)
	/call Debug 3 "In Sub IniLoad"
	/if (!${Defined[${var}]}) {
		/if (${default.Equal[Null]}) {
			/declare ${var} ${vartype} outer ${MMOIni[${ininame},${sec},${var}]}
		} else {
			/declare ${var} ${vartype} outer ${MMOIni[${ininame},${sec},${var},${default}]}
		}
	} else {
		/if (${default.Equal[Null]}) {
			/varset ${var} ${MMOIni[${ininame},${sec},${var}]}
		} else {
			/varset ${var} ${MMOIni[${ininame},${sec},${var},${default}]}
		}
	}
	/if (${vartype.Equal[string]}) {
		/if (${${var}.Equal[NULL]}) /mmoini "${ininame}" "${sec}" "${var}"
	}
	/if (${vartype.Equal[string]}) {
			/if (!${${var}.Equal[NULL]}) /mmoini "${ininame}" "${sec}" "${var}" "${${var}}"
	}
	/if (${vartype.Equal[int]}||${vartype.Equal[float]}) /mmoini "${ininame}" "${sec}" "${var}" "${${var}}"
	/if (${vartype.Equal[bool]}) {
		/if (!${${var}}) /mmoini "${ininame}" "${sec}" "${var}" "FALSE"
	} 
	/if (${vartype.Equal[bool]}) {
		/if (${${var}}) /mmoini "${ininame}" "${sec}" "${var}" "TRUE"
	}
	/varset ${var} ${Ini[${ininame},${sec},${var}]}
	/call Debug 3 "Leaving Sub IniLoad"
/return

Sub CustomLoad
	/call Debug 3 "In Sub CustomLoad"
	/if (!${Defined[CustomLoaded]}) /declare CustomLoaded bool outer FALSE
	/if (${CustomLoaded}) {
		/call Debug 2 "Oops, already loaded CustomLoad, Leaving"
		/return
	}
	/varset CustomLoaded TRUE
	/declare i int local
	/declare CustomCombatTotal int outer ${Ini[MyIni,Custom,CustomCombatTotal]}

	/if (${CustomCombatTotal}) {
		/for i 1 to ${CustomCombatTotal}
			/declare CustomCombat${i} string outer ${Ini[MyIni,Custom,CustomCombat${i}]}
		/next i
	}
	/declare CustomRestTotal int outer ${Ini[MyIni,Custom,CustomRestTotal]}
	/if (${CustomRestTotal}) {
		/for i 1 to ${CustomRestTotal}
			/declare CustomRest${i} string outer ${Ini[MyIni,Custom,CustomRest${i}]}
		/next i
	}
	/if (${NeedLoad} && ${CustomCombatTotal}==NULL) /mmoini "MyIni" "Custom" "CustomCombatTotal" "0"
	/if (${NeedLoad} && ${CustomRestTotal}==NULL) /mmoini "MyIni" "Custom" "CustomRestTotal" "0"
	/if (${NeedLoad}) {
		/if (!${CustomCombatTotal}) /mmoini "MyIni" "Custom" "CustomCombat1"
		/if (!${CustomRestTotal}) /mmoini "MyIni" "Custom" "CustomRest1"
	}
	/call Debug 3 "Leaving Sub CustomLoad"
/return

Sub Custom
	/if (!${Me.CombatState.Equal[COMBAT]}) /return
	/declare i int local
	/for i 1 to ${CustomCombatTotal}
		/if (!${Defined[CustomCombat${i}]}) /declare CustomCombat${i} string outer
		/varset CustomCombat${i} ${Ini[MyIni,Custom,CustomCombat${i}]}
		/docommand ${CustomCombat${i}}
	/next i
/return

#Event TimeOut "#*#TimeOut #1#"
#Event TimeIn	"#*#TimeIn#*#"

Sub Event_TimeOut(line,timeout,action)
	/if (!${Defined[TimeOut]}) /declare TimeOut timer outer
	/varset TimeOut ${timeout}
	/if (${action.NotEqual[NULL]}) /docommand ${action}
	
	/while (${TimeOut}) {
		/doevents TimeIn
	}
/return

Sub Event_TimeIn
	/varset TimeOut 0
/return

#event EndMacro "It will take about 10 more seconds to prepare your camp."
#event EndMacro "It will take about 5 more seconds to prepare your camp."
Sub Event_EndMacro
	/echo You forgot to /end macro
	/end
/return

#event AddAuthorizedUser "#*#AddAuthorizedUser #1#"
Sub Event_AddAuthorizedUser(line, string addauthname)
	/echo ${addauthname}
	/if (${AuthorizedUsers.Find[${addauthname}]}) /mmoini "MyIni" "Settings" "AuthorizedUsers" "${AuthorizedUsers.Replace[${addauthname},]}"
	/if (!${AuthorizedUsers.Find[${addauthname}]}) /mmoini "MyIni" "Settings" "AuthorizedUsers" "${AuthorizedUsers}|${addauthname}"
	/if (${AuthorizedUsers.Find[||]}) /mmoini "MyIni" "Settings" "AuthorizedUsers" "${AuthorizedUsers.Replace[||,|]}"
	/varset AuthorizedUsers ${Ini[MyIni,Settings,AuthorizedUsers]}
	/echo AuthorizedUsers: ${AuthorizedUsers}
/return

#event LootNPCs "[MQ2] Toggle LootNPCs#*#"
Sub Event_LootNPCs
	/if (${LootNPCs}) {
		/mmoini "MyIni" "Settings" "LootNPCs" "FALSE"
		/echo Looting disabled.
	}
	/if (!${LootNPCs}) {
		/mmoini "MyIni" "Settings" "LootNPCs" "TRUE"
		/echo Looting enabled.
	}
	/varset LootNPCs ${Ini[MyIni,Settings,LootNPCs]} 
/return

#event BurnMode "[MQ2] Toggle BurnMode#*#"
#event BurnMode "#*#|${BurnModeAlias}|#*#"
Sub Event_BurnMode
	/varset BurnMode ${If[${BurnMode},FALSE,TRUE]}
	/if (${BurnMode}) /echo Now in BurnMode
	/if (!${BurnMode}) /echo No longer in BurnMode
/return

#event HelpMe "[MQ2] Help guide enabled#*#"
Sub Event_HelpMe
	/echo /assisttype [1|2|3|4] <-- toggles assist type. 1 = /assist, 2 = pick own target, 3 = use XTarget1 as your kill target, 4 = use netbots to pick target
	/echo /toggle option - Toggles "option" on or off, ie. /toggle Nuke, /toggle AA, /toggle Dot
	/echo /options - shows current options
	/echo
	/echo /burn - Toggles BurnMode to TRUE/FALSE
	/echo
	/echo Clickies:
	/echo /addclicky <item link> - adds clicky to maintain
	/echo /removeclicky <item link> - removes clicky from maintaing
	/echo /clicky - toggles maintainence of clickies
	/echo
	/echo IgnoreList related:
	/echo /imob1 - adds current target to alert list 1 to temporarily ignore for pulling
	/echo /imob - adds current target to ignoremob list
	/echo /cmob - adds current target to coldimmune list
	/echo /dmob - adds current target to diseaseimmune list
	/echo /fmob - adds current target to fireimmune list
	/echo /mmob - adds current target to magicimmune list
	/echo /pmob - adds current target to poisonimmune list
	/echo /smob - adds current target to stunimmune list
	/echo
	/echo Camp related:
	/echo /campon - turns leash mode on
	/echo /campoff - turns leash mode off
	/echo /ame - anchors you at current spot
	/echo
	/echo Follow related:
	/echo To follow, in any chat channel say: ${FollowCommand}
	/echo To stop following, in any chat channel say: ${StopFollowCommand}
	/echo 
	/echo SummonTank related:
	/echo /sumtank - toggles summon tanking for current target
	|/echo 
	|/echo [Pet] related:
	|/echo /petgear add|phrase|<link of item> - adds items to ini for later use.  ie. /petgear add|wind|Summoned: Sword of Wind 
	|/echo /petgear wind|water|belt|hulahoop - would attempt to give your pet gear using those 4 aliases that are defined in your ini
	/echo
	/echo Special phrases:
	/echo invison - uses invis
	/echo ivuon - uses invis vs undead
	/echo invisoff - removes invis/ivu
	/echo levon - uses levitate spell, if defined
	/echo levoff - removes levitate spells
	/if (${Me.Class.ShortName.Equal[PAL]}) /echo Use: splashp - splashes with paladin
	/if (${Me.Class.ShortName.Equal[CLR]}) /echo Use: splashc - splashes with cleric
	/echo 
	/echo Special commands:
	/echo /invis		/bc invison
	/echo /ivu		/bc ivuon
	/echo /invisoff	/bc invisoff
	/echo /ivuoff		/bc ivuoff
	/echo /invischange	/bc ToggleInvis invis
	/echo /ivuchange	/bc ToggleInvis ivu
	/echo /taskget	/bc Taskget '$ {Target}'
	/echo /lootthis	/bc LootThis $ {Target.ID}
	/echo /trusted name - Adds name to trusted rez list
	/echo /LootNPCs - toggles on and off looting
	/echo /offtank - toggles whether or not you want to offtank mobs in event of no enc/bard or unmezzable mob
	/echo
	/echo /puller - toggles whether or not you are puller
	/echo /pullingmethod [standard|nav|hunt|seek] - toggles pulling method 
	/echo
	/echo MQ2Nav camp setup example to add a camp called "center":
	/echo 1. /addcamp center
	/echo 2. use the map to target all the mobs you want to kill, in the order you want to kill them, once finished, go to next step
	/echo 3. /stopcamp
	/echo 
	/echo 4. whenever you want to use this camp now, or in the future, just /startcamp center
	/echo
	/echo Camps are set in your \mq2\Camps.ini folder if you want to delete camps later or share them.
	/echo 
	/echo Loot.ini related:
	/echo /lootignore - Changes item status on cursor to Ignore
	/echo /lootkeep - Changes item status on cursor to Keep
	/echo /lootsell - Changes item status on cursor to Sell
	/echo /loottradeskills - Changes item status on cursor to Tradeskills
	/echo /lootdestroy - Changes item status on cursor to Destroy
	/echo /sell - Sells items listed as Sell to currently targeted vendor
	/echo /deposit - Deposits items listed as Keep to currently targeted banker/guildbanker

	/doevents flush
/return

#event Toggle "#*#Toggle option #1#"
Sub Event_Toggle(line, string option_name)
	/call Debug 3 "Toggle Event.  Option name: ${option_name}"
	/if (!${Defined[ToggleList]}) /declare ToggleList string outer |Bard|AA|Aura|AutoClickies|Buff|Camp|Campfire|CheckTarget|ClickyMaintenance|ClickyNuke|Debuff|Disc|Dot|FeignDeath|FightBuff|Heal|HealSingle|HealGroup|HealBalance|HealPet|HealSelf|Jolt|Lifetap|MainTankBuff|Mez|Nuke|Pet|Rez|Root|SelfBuff|SetRoles|Snare|Stun|SummonTank|XHeal|AABuy|Follow|ImHit|Ignore|EchoHandler|Endurance|Mana|Merc|Pulling|SetupAdvLootVars|SummonItem|Cure|Request|GroupFightBuff|
	
	/declare location int local ${ToggleList.Find[|${option_name}|]}
	/declare len int local ${Math.Calc[${option_name.Length}+2]}
	/call Debug 3 "Location of option - ${location} | Length of option - ${len} | ToggleList Option: ${ToggleList.Mid[${location}, ${len}]}"

	/if (!${location}) {
		/echo Not a valid option to toggle.
		/return
	}

	/if (${location} && ${ToggleList.Mid[${location}, ${len}].NotEqualCS[|${option_name}|]}) {
		/echo You entered "${option_name}" but you should have entered "${ToggleList.Mid[${location}, ${len}].Replace[|,]}"
		/echo I'll fix this for you, to not get this error message, please use proper case.
		/varset option_name ${ToggleList.Mid[${location}, ${len}].Replace[|,]}
		/call Debug 3 "Updated option_name to ${option_name}"
	} 

	/if (${OptionsCheck.Find[|${option_name}|]}) {
		/call Debug 3 "Found option ${option_name} - OptionsCheck: ${OptionsCheck}"
		/varset OptionsCheck ${OptionsCheck.Replace[|${option_name}|,|]}
		/call Debug 3 "OptionsCheck now: ${OptionsCheck}"
		|/varset OptionsCheck ${OptionsCheck.Left[${Math.Calc[${OptionsCheck.Find[|${option_name}|]}-1].Int}]}${OptionsCheck.Right[${Math.Calc[${OptionsCheck.Length}-${OptionsCheck.Find[|${option_name}|]}-${option_name.Length}].Int}]}
		/call Debug 3 "Writing to INI"
		/mmoini "MyIni" "Settings" "OptionsCheck" "${OptionsCheck}"
		/echo Disabling ${option_name}
	} else {
		/varset OptionsCheck ${OptionsCheck}${option_name}|
		/mmoini "MyIni" "Settings" "OptionsCheck" "${OptionsCheck}"
		/echo Enabling ${option_name}
	}

	/if (${OptionsCheck.Find[NULL|]}) /varset OptionsCheck ${OptionsCheck.Replace[NULL|,]}
	/if (${OptionsCheck.Find[NULL]}) /varset OptionsCheck ${OptionsCheck.Replace[NULL,]}
	/if (${OptionsCheck.Find[||]}) /varset OptionsCheck ${OptionsCheck.Replace[||,|]} 
/return

#event Emergency "#*#|${EmergencyAlias}|#*#"
Sub Event_Emergency
	/if (${Defined[EmergencySkill]}) {
		/if (${EmergencySkill.Equal[NULL]}||!${EmergencySkill.Length}||${EmergencyAlias.Equal[NULL]}||!${EmergencyAlias.Length}) /return
		/echo Emergency event detected, attempting to use ${EmergencySkill}!
		/call ClearTarget
		/call ClearAttack
		/if (${Me.AbilityReady[${EmergencySkill}]}) /doability "${EmergencySkill}"
		/if (${Me.AltAbilityReady[${EmergencySkill}]}) /alt act ${Me.AltAbility[${EmergencySkill}].ID}
		/if (${Me.CombatAbilityReady[${EmergencySkill}]}) /disc ${EmergencySkill}
		/if (${Me.Gem[${EmergencySkill}]}) /call Cast "${EmergencySkill}" gem${Me.Gem[${EmergencySkill}]} NULL NULL NULL
		/if (${FindItem[${EmergencySkill}].ItemSlot} && !${FindItem[${EmergencySkill}].Timer} && ${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=${EmergencySkill}].ItemSlot} ${FindItem[=${EmergencySkill}].ItemSlot2}
		/if (${FindItem[${EmergencySkill}].ItemSlot} && !${FindItem[${EmergencySkill}].Timer} && !${Me.HaveExpansion[Veil of Alaris]}) /casting "${EmergencySkill}"|item
	}
/return

#event ExpReport		"#*#expreport#*#"
Sub Event_ExpReport
	/declare  exp      float local 0
	/declare  aas      float local 0         
	/declare  aanow  float local 0    
	/declare  expnow  float local 0
	/declare  aahr   float local 0    
	/declare  exphr   float local 0
	
	/varcalc expnow (${Me.Level} * 100) + ${Me.PctExp}
	/varcalc aanow (${Me.AAPointsTotal} * 100) + ${Me.PctAAExp}
	/varcalc aas     (${aanow} - ${aastart})/100
	/varcalc exp     (${expnow} - ${expstart})/100    
    
	/varcalc aahr ${aas} / (${Macro.RunTime}/3600)
	/varcalc exphr ${exp} / (${Macro.RunTime}/3600)
	
   	/docommand /${MyChannel} AA Exp: Spent: ${Me.AAPointsSpent} - Unspent: ${Me.AAPoints}.${Me.PctAAExp} - AA Gained: ${aas} - AA/Hour: ${aahr}
   	/docommand /${MyChannel} Reg Exp: Current: ${Me.Level}.${Me.PctExp} - Exp gained: ${exp}  Exp/Hour: ${exphr}
   	/docommand /${MyChannel} HP: ${Me.PctHPs} --- Mana: ${Me.PctMana} --- End: ${Me.PctEndurance} 
/return

#event IgnoreMob               	"#*# ignoremob #1#"
#event StunImmuneMob		"#*# stunimmunemob #1#"
#event SnareImmuneMob           "#*# snareimmunemob #1#"
#event SlowImmuneMob            "#*# slowimmunemob #1#"
#event CharmImmuneMob		"#*# charmimmunemob #1#"
#event MezImmuneMob		"#*# mezimmunemob #1#"
#event FireImmuneMob            "#*# fireimmunemob #1#"
#event ColdImmuneMob            "#*# coldimmunemob #1#"
#event MagicImmuneMob           "#*# magicimmunemob #1#"
#event PoisonImmuneMob          "#*# poisonimmunemob #1#"
#event DiseaseImmuneMob         "#*# diseaseimmunemob #1#"
#event IgnoreMob               	"#*# ignoremob"
#event StunImmuneMob		"#*# stunimmunemob"
#event SnareImmuneMob           "#*# snareimmunemob"
#event SlowImmuneMob            "#*# slowimmunemob"
#event CharmImmuneMob		"#*# charmimmunemob"
#event MezImmuneMob		"#*# mezimmunemob"
#event FireImmuneMob            "#*# fireimmunemob"
#event ColdImmuneMob            "#*# coldimmunemob"
#event MagicImmuneMob           "#*# magicimmunemob"
#event PoisonImmuneMob          "#*# poisonimmunemob"
#event DiseaseImmuneMob         "#*# diseaseimmunemob"
#event SlowImmune		"Your target is immune to changes in its attack speed#*#"
#event IgSnareImmune		"Your target is immune to changes in its run speed#*#" 
#event MezImmune		"Your target cannot be mesmerized.#*#"
#event IgnZoned           	"You have entered#*#"

Sub IgnoreLoad
	/call Debug 3 "In Sub IgnoreLoad"
	/if (!${Defined[IgnoreLoaded]}) /declare IgnoreLoaded bool outer FALSE
	/if (${IgnoreLoaded}) {
		/call Debug 2 "Oops, already loaded IgnoreLoad, Leaving"
		/return
	}
	/varset IgnoreLoaded TRUE
	/if (!${Defined[IniFile]}) /declare IniFile string outer Mob_Ignore_List.ini
	/if (!${Defined[ImmuneList]}) /declare ImmuneList string outer Ignore|Mez|Charm|Stun|Fire|Cold|Magic|Poison|Disease|Snare|Slow|Unresistable|Chromatic|
	/if (!${Defined[IgnoreAll]}) /declare IgnoreAll string outer ${Ini[${IniFile},Ignores.All,Ignore,|]}
	/if (${IgnoreAll.Equal[|]}) /mmoini "${IniFile}" "Ignores.All" "Ignore" "|"
	/declare i int local

	/for i 1 to ${Math.Calc[${ImmuneList.Count[|]}]}
		/if (${ImmuneList.Arg[${i},|].Equal[Ignore]}) {
			/declare ${ImmuneList.Arg[${i},|]}List string outer ${Ini[${IniFile},"Ignores.${Zone.ShortName}","${ImmuneList.Arg[${i},|]}"]}
			/if (${IgnoreList.Equal[NULL]}) {
				/mmoini "${IniFile}" "Ignores.${Zone.ShortName}" "Ignore" "|"
				/varset IgnoreList ${Ini[${IniFile},"Ignores.${Zone.ShortName}","Ignore"]}
			}
			/if (${IgnoreList.Find[NULL]}) /varset IgnoreList ${IgnoreList.Replace[NULL,]}
			/if (${IgnoreList.Find[||]}) /varset IgnoreList ${IgnoreList.Replace[||,|]}
			/cechob \arIgnoreList: ${IgnoreList}
		}

		/if (${ImmuneList.Arg[${i},|].NotEqual[Ignore]} && !${Defined[${ImmuneList.Arg[${i},|]}ImmuneList]}) {
			/declare ${ImmuneList.Arg[${i},|]}ImmuneList string outer ${Ini[${IniFile},"${ImmuneList.Arg[${i},|]}Immunes.${Zone.ShortName}","${ImmuneList.Arg[${i},|]}Immune"]}
			/if (${${ImmuneList.Arg[${i},|]}ImmuneList.Equal[NULL]}) {
				/mmoini "${IniFile}" "${ImmuneList.Arg[${i},|]}Immunes.${Zone.ShortName}" "${ImmuneList.Arg[${i},|]}Immune" "|"
				/varset ${ImmuneList.Arg[${i},|]}ImmuneList ${Ini[${IniFile},"${ImmuneList.Arg[${i},|]}Immunes.${Zone.ShortName}","${ImmuneList.Arg[${i},|]}Immune"]}
			}
			/if (${${ImmuneList.Arg[${i},|]}ImmuneList.Find[|NULL]}) /varset ${ImmuneList.Arg[${i},|]}ImmuneList ${${ImmuneList.Arg[${i},|]}ImmuneList.Replace[NULL,]}
			/if (${${ImmuneList.Arg[${i},|]}ImmuneList.Find[||]}) /varset ${ImmuneList.Arg[${i},|]}ImmuneList ${${ImmuneList.Arg[${i},|]}ImmuneList.Replace[||,|]}    			
		}
	/next i
	/call Debug 3 "Leaving Sub IgnoreLoad"
/return

Sub Event_IgnZoned
	/if (!${Defined[IgnoreLoaded]}) /call IgnoreLoad
	/if (!${Defined[Outside]}) /declare Outside bool outer TRUE
	/varset Outside TRUE

	/varset IgnoreList ${Ini[${IniFile},"Ignores.${Zone.ShortName}","Ignore"]}
	/if (${IgnoreList.Equal[NULL]}) {
		/mmoini "${IniFile}" "Ignores.${Zone.ShortName}" "Ignore" "|"
		/varset IgnoreList ${Ini[${IniFile},"Ignores.${Zone.ShortName}","Ignore"]}
	}
	/echo IgnoreList: ${IgnoreList}
	/declare i int local  		
	/for i 2 to ${Math.Calc[${ImmuneList.Count[|]}-1]}
		/varset ${ImmuneList.Arg[${i},|]}ImmuneList ${Ini[${IniFile},"${ImmuneList.Arg[${i},|]}Immunes.${Zone.ShortName}","${ImmuneList.Arg[${i},|]}Immune"]}

		/if (${${ImmuneList.Arg[${i},|]}ImmuneList.Equal[NULL]}) {
			/mmoini "${IniFile}" "${ImmuneList.Arg[${i},|]}Immunes.${Zone.ShortName}" "${ImmuneList.Arg[${i},|]}Immune" "|"
			/varset ${ImmuneList.Arg[${i},|]}ImmuneList ${Ini[${IniFile},"${ImmuneList.Arg[${i},|]}Immunes.${Zone.ShortName}","${ImmuneList.Arg[${i},|]}Immune"]}
		} 
	/next i
	/call FollowCheck 			
/return

Sub ImmuneListAdd(WhichList,WhichMob)
	/if (!${Defined[IgnoreLoaded]}) /call IgnoreLoad
	/varset ${WhichList}ImmuneList ${Ini[${IniFile},"${WhichList}Immunes.${Zone.ShortName}","${WhichList}Immune"]} 
	/if (!${${WhichList}ImmuneList.Find[${WhichMob}]} && ${WhichMob.NotEqual[NULL]}) {
  		/mmoini "${IniFile}" "${WhichList}Immunes.${Zone.ShortName}" "${WhichList}Immune" "${${WhichList}ImmuneList}${WhichMob}|"
     	/varset ${WhichList}ImmuneList ${Ini[${IniFile},"${WhichList}Immunes.${Zone.ShortName}","${WhichList}Immune"]}
  		/echo ${WhichList}ImmuneList: ${${WhichList}ImmuneList}
  	} 
/return

Sub Event_IgnoreMob(string line,string MobName)
	/if (!${Defined[IgnoreLoaded]}) /call IgnoreLoad
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/varset IgnoreList ${Ini[${IniFile},"Ignores.${Zone.ShortName}","Ignore"]}
	/if (!${IgnoreList.Find[${MobName}]} && ${MobName.NotEqual[NULL]}) {
		/mmoini "${IniFile}" "Ignores.${Zone.ShortName}" "Ignore" "${IgnoreList}${MobName}|"
		/varset IgnoreList ${Ini[${IniFile},"Ignores.${Zone.ShortName}","Ignore"]}
		/if (${IgnoreList.Find[NULL]}) /varset IgnoreList ${IgnoreList.Replace[NULL,]}
		/if (${IgnoreList.Find[||]}) /varset IgnoreList ${IgnoreList.Replace[||,|]}
		/echo IgnoreList: ${IgnoreList}
	}
/return

Sub Event_StunImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Stun" "${MobName}"
/return

Sub Event_SnareImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/if (${SnareAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} SNARE IMMUNE						
	/call ImmuneListAdd "Snare" "${MobName}"
/return

Sub Event_SlowImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/if (${DebuffAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} SLOW IMMUNE
	/call ImmuneListAdd "Slow" "${MobName}"
/return

Sub Event_MezImmuneMob(string line,string MobName)
	/if (${BeamTimer}||${BeamUsed}) /return
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/if (${MezAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} MEZ IMMUNE	
	/call ImmuneListAdd "Mez" "${MobName}"
/return

Sub Event_FireImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Fire" "${MobName}"
/return

Sub Event_ColdImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Cold" "${MobName}"
/return

Sub Event_MagicImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Magic" "${MobName}"
/return

Sub Event_PoisonImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Poison" "${MobName}"
/return

Sub Event_DiseaseImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Disease" "${MobName}"
/return

Sub Event_CharmImmuneMob(string line,string MobName)
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/call ImmuneListAdd "Charm" "${MobName}"
/return

Sub Event_MezImmune
	/if (!${Defined[MobName.Length]}) /declare MobName string local ${Target.CleanName}
	/if (${MezAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} MEZ IMMUNE
	/call ImmuneListAdd "Mez" "${MobName}"
/return

Sub Event_IgSnareImmune
	/if (!${Defined[SnareLoaded]}) /call SnareLoad
	/varset Snared TRUE
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/if (${SnareAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} SNARE IMMUNE
	/call ImmuneListAdd "Snare" "${MobName}"
/return

Sub Event_SlowImmune
	/varset Slowed TRUE
	/if (!${MobName.Length}) /declare MobName string local ${Target.CleanName}
	/if (${DebuffAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} SLOW IMMUNE
	/call ImmuneListAdd "Slow" "${MobName}"
/return

Sub EchoPlain(string Texte)
    /echo ${Texte}
/return

Sub EchoColor(string Texte)
    /cechob ${Texte}
/return

Sub EchoHandlerLoad
	/call Debug 3 "In Sub EchoHandlerLoad"
	/if (!${Defined[EchoHandlerLoaded]}) /declare EchoHandlerLoaded bool outer FALSE
	/if (${EchoHandlerLoaded}) /return
	/varset EchoHandlerLoaded TRUE
	/declare pLoaded    int    local ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},1,0]}
	/declare Black 		string outer ${If[${pLoaded},\ab,""]}
	/declare Blue   	string outer ${If[${pLoaded},\au,""]}
	/declare Brown      string outer ${If[${pLoaded},\a-o,""]}
	/declare Cyan   	string outer ${If[${pLoaded},\at,""]}
	/declare Gray		string outer ${If[${pLoaded},\a-w,""]}
	/declare Green		string outer ${If[${pLoaded},\ag,""]}
	/declare Pink   	string outer ${If[${pLoaded},\am,""]}
	/declare Orange   	string outer ${If[${pLoaded},\ao,""]}
	/declare Purple   	string outer ${If[${pLoaded},\ap,""]}
	/declare Red   		string outer ${If[${pLoaded},\ar,""]}
	/declare Teal   	string outer ${If[${pLoaded},\at,""]}
	/declare White   	string outer ${If[${pLoaded},"\aw",""]}
	/declare Yellow  	string outer ${If[${pLoaded},\ay,""]}
	/declare DarkGreen 	string outer ${If[${pLoaded},\a-g,""]}
	/declare DarkMaroon	string outer ${If[${pLoaded},\a-m,""]}
	/declare DarkPurple	string outer ${If[${pLoaded},\a-p,""]}
	/declare DarkRed	string outer ${If[${pLoaded},\a-r,""]}
	/declare DarkCyan	string outer ${If[${pLoaded},\a-t,""]}
	/declare DarkBlue	string outer ${If[${pLoaded},\a-u,""]}
	/declare DarkYellow	string outer ${If[${pLoaded},\a-y,""]}
	/declare EchoSub    string outer ${If[${pLoaded},EchoColor,EchoPlain]}

	/declare ColorList  string local |123|${Gray}|${Green}|${Teal}|${Blue}|${White}|${Yellow}|${Red}|
	/declare ConColor[${ColorList.Count[|]}] string outer 
	/declare i int local
	/for i 1 to ${ColorList.Count[|]} do
		/varset ConColor[${i}] ${If[${pLoaded},${ColorList.Arg[${i},|]},""]}
	/next i
	/call Debug 3 "Leaving Sub EchoHandlerLoad"
/return

#event TaskGet2 "#*#TaskGet2 #0#"

Sub Event_TaskGet2(string keyphrase)
	/echo Using: ${keyphrase} ---> ${Target}
	/declare i int local
	/for i 1 to ${Group}
		/delay 2
		/delay ${Math.Rand[3]}s
		/if (${Group.Member[${i}].Type.Equal[pc]}) /bct ${Group.Member[${i}]} //target ${Target}
		/delay 5
		/if (${keyphrase.NotEqual[Hail]}) /if (${Group.Member[${i}].Type.Equal[pc]}) /bct ${Group.Member[${i}]} //say ${keyphrase}
		/if (${keyphrase.Equal[Hail]}) /if (${Group.Member[${i}].Type.Equal[pc]}) /bct ${Group.Member[${i}]} //hail
	/next i
	/if (${keyphrase.NotEqual[Hail]}) /say ${keyphrase}
	/if (${keyphrase.Equal[Hail]}) /hail
/return


|################> Alias Load <#######################
Sub AliasLoad
	/call Debug 3 "In Sub AliasLoad"
	/if (!${NewVersion}) {
		/call Debug 2 "Not a New Version, no aliases needed"
		/call Debug 3 "Leaving Sub AliasLoad"
		/return
	}
	
	/if (!${Defined[MyChannel]}) /declare MyChannel string outer ${Ini[MyIni,Settings,MyChannel,echo]}
	/noparse	/squelch /alias		/aabuy				/varset AABuy ${If[${AABuy},FALSE,TRUE]}
				/squelch /alias 	/helpme 			/echo Help guide enabled
				/squelch /alias 	/assisttype 		/echo Change AssistType to
				/squelch /alias     /debuglevel         /echo Set DebugLevel
				/squelch /alias 	/toggle				/echo Toggle option
	/noparse 	/squelch /alias 	/options 			/echo ${OptionsCheck}
				/squelch /alias 	/LootNPCs 			/echo Toggle LootNPCs
				/squelch /alias 	/burn 				/echo Toggle BurnMode
				/squelch /alias 	/adduser 			/echo AddAuthorizedUser
				/squelch /alias 	/taskg 				/echo TaskGet2
				/squelch /alias 	/leap 				/echo LeapTarget
				/squelch /alias 	/sumtank 			/echo SummonTankTarget
				/squelch /alias 	/ame 				/echo AnchorMe
				/squelch /alias 	/campoff 			/varset UseCamp FALSE
				/squelch /alias 	/campon 			/varset UseCamp TRUE
				/squelch /alias 	/offtank 			/echo Toggle OffTank
				/squelch /alias 	/addclicky 			/echo Add Clicky
				/squelch /alias 	/removeclicky 		/echo Remove Clicky
				/squelch /alias 	/clicky 			/echo ClickyToggle
				/squelch /alias 	/imob 				/echo ignoremob
	/noparse 	/squelch /alias 	/imob1 				/alert add 1 ${Target}
				/squelch /alias 	/cmob 				/echo coldimmunemob
				/squelch /alias 	/dmob 				/echo diseaseimmunemob
				/squelch /alias 	/fmob 				/echo fireimmunemob
				/squelch /alias 	/mmob 				/echo magicimmunemob
				/squelch /alias 	/pmob 				/echo poisonimmunemob
				/squelch /alias 	/smob 				/echo stunmob
				/squelch /alias 	/addcamp 			/echo addcamp
				/squelch /alias 	/stopcamp 			/echo stopadd
				/squelch /alias 	/listcamp 			/echo listcamp
				/squelch /alias 	/startcamp 			/echo startcamp
				/squelch /alias 	/petgear 			/echo PetGear
	/noparse	/squelch /alias 	/petrequest			/docommand /${MyChannel} PetGearRequest ${Me.ID}
				/squelch /alias 	/puller 			/echo TogglePuller
				/squelch /alias 	/pullingmethod 		/echo TogglePullingMethod
				/squelch /alias 	/trusted 			/echo Toggle Trusted
				/squelch /alias 	/import 			/echo ImportSection
				/squelch /alias 	/summon 			/echo SummonItem
				/squelch /alias 	/aaspew 			/echo AASpewList 1
				/squelch /alias 	/cureignore 		/echo AddCureIgnoreList
	/noparse 	/squelch /alias 	/lootignore    		/echo LootItem Ignore ${Cursor.Name}
	/noparse 	/squelch /alias 	/lootsell      		/echo LootItem Sell ${Cursor.Name}
	/noparse 	/squelch /alias 	/loottradeskills	/echo LootItem Tradeskills ${Cursor.Name}        
	/noparse 	/squelch /alias 	/lootkeep      		/echo LootItem Keep ${Cursor.Name}
	/noparse 	/squelch /alias 	/lootdestroy   		/echo LootItem Destroy ${Cursor.Name}
	/noparse	/squelch /alias		/lootcollectible 	/echo LootItem Collectible ${Cursor.Name}
				/squelch /alias 	/sell           	/echo SellItems
				/squelch /alias 	/deposit 			/echo DepositItems
				/squelch /alias		/invis				/${MyChannel}  invison
				/squelch /alias		/ivu				/${MyChannel}  ivuon
				/squelch /alias		/invisoff			/${MyChannel}  invisoff
				/squelch /alias		/ivuoff				/${MyChannel}  ivuoff
				/squelch /alias		/invischange		/${MyChannel}  ToggleInvis invis
				/squelch /alias		/ivuchange			/${MyChannel} ToggleInvis ivu
	/noparse	/squelch /alias		/taskget			/${MyChannel}  TaskGet ${Target}
	/noparse	/squelch /alias		/lootthis			/${MyChannel}  LootThis ${Target.ID}

	/call Debug 2 "Updating Ini version to ${BotVersion}"
	/mmoini "MyIni" "Settings" "BotVersion" "${BotVersion}"

	/call Debug 3 "Leaving Sub AliasLoad"
/return

#Event DebugLevel "[MQ2] Set DebugLevel #1#"
Sub Event_DebugLevel(line, int new_level)
	/varset DebugLevel ${new_level}
	/call Debug 1 "Updated DebugLevel to ${DebugLevel}"
/return

|#################>  Plugin Load <###############################
Sub PluginLoad
	/call Debug 3 "In Sub PluginLoad"
	/declare PluginCheckList string outer MQ2CEcho|MQ2Cast|MQ2Debuffs|Mq2MoveUtils|
	/declare i int local
	/for i 1 to ${PluginCheckList.Count[|]} 
		/if (!${Plugin[${PluginCheckList.Arg[${i},|]}].Name.Equal[${PluginCheckList.Arg[${i},|]}]}) /squelch /plugin ${PluginCheckList.Arg[${i},|]}
	/next i
	/call Debug 3 "Leaving Sub PluginLoad"
/return


|**###############> Assist related routines and events <#######################**|
#event AssistType "[MQ2] Change AssistType to #1#"
Sub Event_AssistType(line, int new_type)
	/varset AssistType ${new_type}
	/if (!${AssistType}) /echo Set AssistType.  1 to just /assist, 2 to /target own prioritized mob, 3 to /assist with XTarget1 is kill target, 4 to use NetBots
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==1) /echo AssistType 1 = /assist ${AssistPC} at ${AssistAt}% - Check every 5s
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==2) /echo AssistType 2 = Pick own target at ${AssistAt}% 
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==3) /echo AssistType 3 = Using XTarget1 to assist ${AssistPC} at ${AssistAt}%
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==4) /echo AssistType 4 = Using NetBots to assist ${AssistPC} at ${AssistAt}%
/return

#event SetTarget "#*#|${SetTargetMessage}| #1#"
Sub Event_SetTarget(string Line,int MobID)
	/if (!${Defined[TarID]}) /declare TarID int outer
	/varset TarID ${MobID}
	/squelch /tar id ${TarID}
   	/if (${UseMelee}||${UseArchery}) /call Attacking2
/return

Sub CheckTargetLoad
	/call Debug 3 "In Sub CheckTargetLoad"
	/if (!${Defined[CheckTargetLoaded]}) /declare CheckTargetLoaded bool outer FALSE
	/if (${CheckTargetLoaded}) {
		/call Debug 2 "Oops, already loaded CheckTargetLoad, leaving"
		/return
	}
	/varset CheckTargetLoaded TRUE
	/if (!${Defined[TarID]}) /declare TarID int outer
	/varset ListVar AssistType|AssistPC|AssistAt|OpeningMove|AttackRange|AttackCommand|AttackConditions|AmIOffTank|UseMelee|UseArchery|ArcheryMaxDistance|ArcheryMinDistance|SetTargetMessage|
	/varset ListVarType int|string|int|string|int|string|string|bool|bool|bool|int|int|string|
	/varset ListDefault 3|${Group.MainAssist}|99|NULL|150|"/attack on"|NULL|FALSE|${If[${Select[${Me.Class.ShortName},BRD,BST,BER,ROG,WAR,MNK,RNG,SHD,PAL]},TRUE,FALSE]}|${If[${InvSlot[11].Item.Type.Equal[Archery]},TRUE,FALSE]}|200|35|Kill_this|
	/varset ListSection Assist
	/declare ReAssist timer outer 3s
	/declare OpeningMoveTimer timer outer 5s
	/declare assiststring string local
	/declare i int local
	/declare AssistWait timer outer

	/for i 1 to ${ListVar.Count[|]}
		/call IniLoad "MyIni" "${ListVar.Arg[${i},|]}" "${ListVarType.Arg[${i},|]}" "Assist" "${ListDefault.Arg[${i},|]}"
	/next i
	/varset assiststring ${Ini[MyIni,Assist,AssistPC]}
	/if (${assiststring.Equal[NULL]}||!${assiststring.Length}) /mmoini "MyIni" "Assist" "AssistPC"
	/varset assiststring ${Ini[MyIni,Assist,AssistAt]}
	/if (${assiststring.Equal[NULL]}||!${assiststring.Length}) /mmoini "MyIni" "Assist" "AssistAt"
	/if (${AssistPC.Equal[${Me.Name}]}||${AssistPC.Equal[self]}) /varset AssistType 2
	/cechob \arAvailable AssistTypes:  1 to just /assist, 2 to /target own prioritized mob, 3 to /assist with XTarget1 is kill target, 4 to use NetBots
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==1) /echo AssistType 1 = /assist ${AssistPC} at ${AssistAt}% - Check every 5s
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==2) /echo AssistType 2 = Pick own target at ${AssistAt}% 
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==3) /echo AssistType 3 = Using XTarget1 to assist ${AssistPC} at ${AssistAt}%
	/if (${AssistPC.NotEqual[load]} && ${AssistType}==4) /echo AssistType 4 = Using NetBots to assist ${AssistPC} at ${AssistAt}%

	/noparse /declare XTargetList string outer ${Me.XTarget[1].ID}|${Me.XTarget[2].ID}|${Me.XTarget[3].ID}|${Me.XTarget[4].ID}|${Me.XTarget[5].ID}|${Me.XTarget[6].ID}|${Me.XTarget[7].ID}|${Me.XTarget[8].ID}|${Me.XTarget[9].ID}|${Me.XTarget[10].ID}
	/declare XTargetList1 		string outer PH1
	/declare XTargetList2 		string outer PH2
	/declare AddListPriority 	string outer 0
	/declare KillID 		int outer
	/declare KillPri 		int outer
	/declare AddListPrority string 		outer
	|/if (!${Defined[xrad]})     	/declare xrad int outer 1500
	|/if (!${Defined[zrad]})     	/declare zrad int outer 300
	/declare EchoAddsInsert		bool outer ${Ini[MyIni,AddHandler,EchoAddsInsert,TRUE]}
	/declare EchoAddsRemove 	bool outer ${Ini[MyIni,AddHandler,EchoAddsRemove,TRUE]}
	/declare EchoAddsUpdate		bool outer ${Ini[MyIni,AddHandler,EchoAddsUpdate,TRUE]}
	/declare AddChanges		int outer 0
	/declare NewList		string outer |
	/declare NewCount     		int outer 0
	/declare AddList      		string outer |
	/declare AddCount            int outer 0
	/declare AddVariable      string outer |Name|Class|Level|ConColor|XTarget|Named|Pet|KillPriority|MezzPriority|
	/declare OnAddSub         string outer |
	/declare LastSetTargetMessage string outer
	/if (!${Defined[MezzImmuneList]}) /declare MezzImmuneList string outer 
	/declare BurnMode bool outer FALSE
	/varset BurnModeAlias ${Ini[MyIni,Assist,BurnModeAlias,BurnModeAlias]}
	/if (${BurnModeAlias.Equal[BurnModeAlias]}) /mmoini "MyIni" "Assist" "BurnModeAlias" "BurnModeAlias"
	/call Debug 3 "Leaving Sub CheckTargetLoad"
/return

#event AddHandlerForce "#*#AddList: #1#"
Sub Event_AddHandlerForce(line, string newaddlist)
	/if (${EQBCAnnounceAdds}) /return
	/if (!${Defined[iAddList]}) /declare iAddList int outer
	/if (!${Defined[iAddCount]}) /declare iAddCount int outer 0
	/declare i int local
	/for iAddList 2 to ${newaddlist.Count[|]}
		/for i 1 to ${XTarget.Max}
			/if (${Me.XTarget[${i}].ID}==${newaddlist.Arg[${iAddCount},|]}) /goto :call
		/next i
		/varset i 0
		:call
		/call AddHandlerScan ${newaddlist.Arg[${iAddCount},|]} ${i} 1
	/next iAddList
/return

|TODO: Not sure what these two lines were for, they were just randomly between subs.  Commented them out.
|/if (${forceaction}) /call CheckTarget${forceaction}
|/return

Sub AddHandlerScan(SpawnID,SlotID,ForceAdd)
    /if (!${ForceAdd} && (!${SpawnID} || ${AddList.Find[|${SpawnID}|]} || !${Select[${Spawn[id ${SpawnID}].Type},npc,pet]} || ${Spawn[id ${SpawnID}].Master.Type.Equal[pc]} || ${IgnoreList.Find[${Spawn[id ${SpawnID}].CleanName}]}||${IgnoreAll.Find[${Spawn[id ${SpawnID}].CleanName}]})) /return
	/if (${AddList.Find[|${SpawnID}|]}||${IgnoreAll.Find[${Spawn[id ${SpawnID}].CleanName}]}||${IgnoreList.Find[${Spawn[id ${SpawnID}].CleanName}]}||${SpawnID.Equal[NULL]}) /return
	/varcalc AddChanges	${AddChanges}+1
	/varcalc AddCount ${AddCount}+1
	/varcalc NewCount ${NewCount}+1
	/varset  AddList |${SpawnID}${AddList}
	/varset  NewList |${SpawnID}${NewList}
	/if (!${Defined[Adds_${SpawnID}_Name]}) /declare Adds_${SpawnID}_Name      string outer ${Spawn[id ${SpawnID}].CleanName}
	/if (!${Defined[Adds_${SpawnID}_Class]}) /declare Adds_${SpawnID}_Class     string outer ${Spawn[id ${SpawnID}].Class.ShortName}
	/if (!${Defined[Adds_${SpawnID}_Level]}) /declare Adds_${SpawnID}_Level        int outer ${Spawn[id ${SpawnID}].Level}
	/if (!${Defined[Adds_${SpawnID}_ConColor]}) /declare Adds_${SpawnID}_ConColor     int outer ${Select[|${Spawn[id ${SpawnID}].ConColor}|,|GREY|,|GREEN|,|LIGHT BLUE|,|BLUE|,|WHITE|,|YELLOW|,|RED|]}
	/if (!${Defined[Adds_${SpawnID}_XTarget]}) /declare Adds_${SpawnID}_XTarget      int outer ${SlotID}
	/if (!${Defined[Adds_${SpawnID}_Named]}) /declare Adds_${SpawnID}_Named        int outer ${If[${Spawn[id ${SpawnID}].Name.Find[#]},1,0]}
	/if (!${Defined[Adds_${SpawnID}_Pet]}) /declare Adds_${SpawnID}_Pet          int outer ${If[${Spawn[id ${SpawnID}].Type.Equal[pet]},1,0]}
	/if (${EchoAddsInsert}) /call ${EchoSub} "${Purple}ADDS${Red}+${ConColor[${Adds_${SpawnID}_ConColor}]} ${Adds_${SpawnID}_Level} ${Adds_${SpawnID}_Class} ${Adds_${SpawnID}_Name} ${Purple} ID:${White} ${SpawnID} ${Purple} ${Red} ${If[${Adds_${SpawnID}_XTarget},XTARGET,""]}"
	/if (${EQBCAnnounceAdds}) /bc AddList: ${AddList}
	/doevents
/return

Sub AddHandlerLoad
	/call Debug 3 "In Sub AddHandlerLoad"
	| Nothing here?
	/call Debug 3 "Leaving Sub AddHandlerLoad"
/return

Sub AddHandler(int forceaction)
    /varset MezzImmuneList ${Ini[Mob_Ignore_List.ini,MezImmunes.${Zone.ShortName},MezImmune]}
    /declare SpawnID    int local
    /declare i          int local
    /declare j          int local
    /declare k       string local

    /varset AddChanges 0

    /if (${AddCount}) {
        /varset NewCount 0
        /varset NewList |

        /for i 1 to ${AddCount}
           /varset SpawnID ${AddList.Arg[${i},|]}
           /if (${SpawnID}) {
               /if (${Select[${Spawn[id ${SpawnID}].Type},npc,pet]} && !${Spawn[id ${SpawnID}].Master.Type.Equal[pc]} && !${IgnoreList.Find[${Spawn[id ${SpawnID}].CleanName}]} && !${IgnoreAll.Find[${Spawn[id ${SpawnID}].CleanName}]}) {
                    /varcalc NewCount ${NewCount} + 1
                    /varset  NewList |${SpawnID}${NewList}
                } else {
                    /if (${EchoAddsRemove}) /call ${EchoSub} "${Purple}ADDS${Green}-${ConColor[${Adds_${SpawnID}_ConColor}]} ${Adds_${SpawnID}_Level} ${Adds_${SpawnID}_Class} ${Adds_${SpawnID}_Name} ${Purple} ID:${White} ${SpawnID}"
   		    		/if (${EQBCAnnounceAdds}) /bc AddList: ${AddList}
		    		/varcalc AddChanges	${AddChanges} + 1
                    /for j 1 to ${AddVariable.Count[|]}
						/varset k ${AddVariable.Arg[${j},|]}
                    	/if (${Defined[Adds_${SpawnID}_${k}]}) /deletevar Adds_${SpawnID}_${k}
                    /next j
                }
            }
        /next i

        /if (${AddChanges}) {
            /varset AddCount ${NewCount}
            /varset AddList ${NewList}
        }
    }

    /varset NewCount 0
    /varset NewList |

	|	update alert
    /if (${Me.XTarget}) {
        /for i 1 to ${XTarget.Max}
            /call AddHandlerScan ${Me.XTarget[${i}].ID} ${i} 0
        /next i
    }

	|    /for i 1 to ${SpawnCount[zradius ${zrad}, radius ${xrad} los]}
	|        /call AddHandlerScan ${NearestSpawn[${i} zradius ${zrad}, radius ${xrad}].ID} FALSE
	|    /next i

    /if (${AddChanges}) {
        /if (${EchoAddsUpdate}) /call ${EchoSub} "${Purple}ADDS${Yellow}=${White} ${AddCount}${Purple}-> ${If[${AddCount}<10,${Gray}${AddList},${Red}TOOMANY]}"
		/if (${EQBCAnnounceAdds}) /bc AddList: ${AddList}
        /if (${NewCount}) {
            /for i 1 to ${OnAddSub.Count[|]}
                /varset k ${OnAddSub.Arg[${i},|]}
                /if (!${k.Equal[NULL]}) /call ${k} ${NewCount} "${NewList}"
            /next i
        }
    }
	/varset AddListPriority
	/for i 1 to ${XTarget.Max} 
		/varset AddListPriority ${AddListPriority} ${If[(${Spawn[${Me.XTarget[${i}].ID}].Type.Equal[npc]}||${Spawn[${Me.XTarget[${i}].ID}].Master.Type.Equal[npc]}||${Spawn[${Me.XTarget[${i}].ID}].Master.Type.Equal[corpse]}),${Int[${Math.Calc[(${Spawn[${Me.XTarget[${i}].ID}].Level}+${If[(${Spawn[${Me.XTarget[${i}].ID}].Name.Find[#]}||${Spawn[${Me.XTarget[${i}].ID}].Named}),25,0]})+${If[${MezImmuneList.Find[${Spawn[${Me.XTarget[${i}].ID}].CleanName}]},15,0]}+${If[${SnareImmuneList.Find[${Spawn[${Me.XTarget[${i}].ID}].CleanName}]} && !${Mezzer},15,0]}-${If[${Spawn[${Me.XTarget[${i}].ID}].Master.Type.Equal[npc]},25,0]}]}]},0]}
	/next i
	/varset KillPri ${Math.Max[${AddListPriority}]}
	/if (${AddListPriority.Arg[1, ].Equal[${KillPri}]}) {
		/varset KillID ${XTargetList2.Arg[1,||]}
	} else {
		/for i 2 to ${XTarget.Max}
			/if (${AddListPriority.Arg[${i}, ].Equal[${KillPri}]}) {
				/varset KillID ${XTargetList2.Arg[${i},||]}
				/goto :found
			}
		/next i
	}

	:found
	/if (${EchoAddsUpdate} && ${KillID} && ${KillID}!=${TarID} && (${Spawn[id ${KillID}].Type.Equal[npc]}||${Spawn[id ${KillID}].Master.Type.Equal[npc]}||${Spawn[id ${KillID}].Master.Type.Equal[corpse]})) {
		/if (${Me.XTarget}) {
			/for i 1 to ${XTarget.Max}
				/call AddHandlerScan ${Me.XTarget[${i}].ID} ${i}
			/next i
		}
		/call ${EchoSub} "${Purple}Priority Target ${Yellow} = ${ConColor[${Select[|${Spawn[id ${KillID}].ConColor}|,|GREY|,|GREEN|,|LIGHT BLUE|,|BLUE|,|WHITE|,|YELLOW|,|RED|]}]} ${Spawn[id ${KillID}]}"
	}
	/if (${forceaction}) /call CheckTarget${forceaction}
/return

Sub CheckTarget0
	/if (${Me.Hovering}) /return
	/if (${Target.ID} && (${Target.Type.Equal[npc]}||${Spawn[${Target.Master.ID}].Type.Equal[npc]}||${Spawn[${Target.Master.ID}].Type.Equal[corpse]}) && ${Target.ID}!=${TarID} && !${IgnoreList.Find[${Spawn[${Target.CleanName}]}]} && !${IgnoreAll.Find[${Spawn[${Target.CleanName}]}]}) {
		/call ClearTarget
		/varset TarID ${Target.ID}
   	}
/return

Sub CheckTarget1
	/if (${Me.Hovering}) /return
 	/if (!${Target.ID} || ${Target.Type.NotEqual[NPC]} && ${Target.Master.Type.NotEqual[npc]} || !${ReAssist} || ${Me.Pet.ID} && ${Target.ID}==${Me.Pet.ID}) {
		/if (${Spawn[${AssistPC} radius 150].ID}) {
			/assist ${AssistPC}
			/varset ReAssist ${ReAssist.OriginalValue}
		}
		/if (${Spawn[corpse ${AssistPC}].ID} && !${Spawn[pc ${AssistPC}].ID} && !${Spawn[pet ${AssistPC}].ID} && !${Spawn[mercenary ${AssistPC}].ID} && ${AssistPC2.NotEqual[NULL]} && ${Spawn[${AssistPC2} radius 150].ID}) {
			/assist ${AssistPC2}
			/varset ReAssist ${ReAssist.OriginalValue}
		}
	}

	/if (${Target.ID} && (${Target.Type.Equal[npc]}||${Spawn[${Target.Master.ID}].Type.Equal[npc]}||${Spawn[${Target.Master.ID}].Type.Equal[corpse]}) && ${Target.ID}!=${TarID} && !${IgnoreList.Find[${Spawn[${Target.CleanName}]}]} && !${IgnoreAll.Find[${Spawn[${Target.CleanName}]}]} && ${Target.Distance}<=${AttackRange}) {
		/call ClearTarget
		/varset TarID ${Target.ID}
		/if (${Defined[OpeningMove]}) {
			/if (!${Defined[OpeningMove${TarID}]}) /declare OpeningMove${TarID} int outer 0
			/if (${OpeningMove.NotEqual[NULL]} && !${OpeningMove${TarID}}) {
				/docommand ${OpeningMove}
				/if (!${Defined[OpeningMove${TarID}]}) /declare OpeningMove${TarID} int outer 1
				/varset OpeningMove${TarID} 1
			}
		}
		/if ((${UseMelee}||${UseArchery}) && ${Target.PctHPs}<=${AssistAt}) /call Attacking2
   	}
   	/if ((${UseMelee}||${UseArchery}) && ${Target.ID}==${TarID} && ${Target.PctHPs}<=${AssistAt} && ${Target.Distance}<=${AttackRange}) /call Attacking2
/return

Sub CheckTarget2
	/declare i int local
	/if (!${Defined[CheckTarget2]}) {
		/declare CheckTarget2 int outer 1
		/for i 1 to ${XTarget.Max}
			/if (${Me.XTarget[${i}].Type.NotEqual[Auto Hater]}) /xtarget set ${i} autohater
		/next i
	}
	/if (${KillID} && (${Spawn[id ${KillID}].Type.Equal[NPC]}||${Spawn[id ${KillID}].Master.Type.Equal[NPC]}||${Spawn[id ${KillID}].Master.Type.Equal[corpse]}) && ${TarID}!=${KillID}) /varset TarID ${KillID}
	/if (!${Target.ID} && ${Spawn[${TarID}].ID} && !${Select[${Spawn[${TarID}].Type},pc,mercenary,corpse]}) /squelch /tar id ${TarID} 
	/if (${Ini[MyIni,Assist,AttackConditions,1]} && ${Target.ID} && (${Target.Distance}<=${AttackRange}||${UseArchery}) && ${Target.PctHPs}<=${AssistAt} && (${Target.Type.Equal[NPC]}||${Target.Master.Type.Equal[npc]}||${Target.Master.Type.Equal[corpse]})) {
		/if (${AmIOffTank} && ${Me.XTarget}>1) /call OffTank
		/if (${Target.ID}!=${KillID}) /call ClearTarget
		/if (${TarID} && (${Spawn[${TarID}].ID} && !${Spawn[${TarID}].Type.Equal[Corpse]})) /squelch /tar id ${TarID}
		/delay 1s ${Target.ID}
		/if (${SetTargetMessage.NotEqual[NULL]} && ${LastSetTargetMessage.NotEqual[${Target.ID}]} && ${Target.ID}) {
			/docommand /${MyChannel} ${SetTargetMessage} ${TarID}
			/varset LastSetTargetMessage ${Target.ID}
			/call ClearTarget2
		}
		/if (${Target.ID}) {
			/if (${Defined[OpeningMove]}) {
				/if (${Bool[${OpeningMove}]}) {
					/if (!${Defined[OpeningMove${TarID}]}) /declare OpeningMove${TarID} int outer 0
					/if (!${OpeningMove${TarID}}) {
						/if (!${TarID}) {
							/squelch /tar clear
							/return
						}
						/docommand ${OpeningMove}
						/varset OpeningMove${TarID} 1
					}
				}
			}
			/if (${UseMelee}||${UseArchery}) /call Attacking2
		}
	}
 	/if (${Target.Distance}<=${AttackRange} && ${TarID} && (!${Spawn[${TarID}].ID}||${Spawn[${TarID}].Type.Equal[Corpse]}) || ${IgnoreList.Find[${Spawn[${TarID}].CleanName}]}|| ${IgnoreAll.Find[${Spawn[${TarID}].CleanName}]}) {
		/varset TarID 0
		/call ClearTarget
   	}
/return

Sub CheckTarget3
	/if (${Me.Hovering}) /return
	/if (!${Defined[CheckTargetLoaded]}) /call CheckTargetLoad
	/if (!${Defined[TarID]}) /declare TarID int outer

	/if (${Ini[MyIni,Assist,AttackConditions,1]} && (${Spawn[${Me.XTarget[1].ID}].Distance}<=${AttackRange}||${UseArchery}) && ${Me.XTarget[1].ID} && ${Spawn[${AssistPC}].Distance}<150 && ${Spawn[${Me.XTarget[1].ID}].PctHPs}<=${AssistAt} && (${Spawn[${Me.XTarget[1].ID}].Type.Equal[NPC]}||${Spawn[${Me.XTarget[1].ID}].Master.Type.Equal[npc]}||${Spawn[${Me.XTarget[1].ID}].Master.Type.Equal[corpse]})) {
		/if (${AmIOffTank} && ${Me.XTarget}>1) /call OffTank
		/if (${Me.XTarget[1].ID}!=${TarID}) /call ClearTarget
		/varset TarID ${Me.XTarget[1].ID}
		/if (${TarID} && (${Spawn[${TarID}].ID} && !${Spawn[${TarID}].Type.Equal[Corpse]})) /squelch /tar id ${TarID}
		/delay 1s ${Target.ID}
		
		/if (!${Defined[OpeningMove${TarID}]}) /declare OpeningMove${TarID} int outer 0
		/if (${OpeningMove.NotEqual[NULL]} && !${OpeningMove${TarID}} && ${Target.ID}) {
			/docommand ${OpeningMove}
			/varset OpeningMove${TarID} 1
		}
   		/if (${UseMelee}||${UseArchery}) /call Attacking2
	}
 	/if (${Spawn[${Me.XTarget[1].ID}].Distance}<=${AttackRange} && ${TarID} && (!${Spawn[${TarID}].ID}||${Spawn[${TarID}].Type.Equal[Corpse]}) || ${IgnoreList.Find[${Spawn[${TarID}].CleanName}]}|| ${IgnoreAll.Find[${Spawn[${TarID}].CleanName}]}) {
		/varset TarID 0
		/call ClearTarget
   	}
	/if (${FindItemCount[=Ethereal Arrow]}<=1 && ${FindItem[Huntsman's Ethereal Quiver].ItemSlot} && ${UseArchery} && !${Cursor.Name.Equal[Ethereal Arrow]} && !${Me.AltAbility[Endless Quiver]}) {
		/if (${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=Huntsman's Ethereal Quiver].ItemSlot} ${FindItem[=Huntsman's Ethereal Quiver].ItemSlot2}
		/if (!${Me.HaveExpansion[Veil of Alaris]}) /casting "Huntsman's Ethereal Quiver"|item
		/delay 1s
		/delay 10s !${Me.Casting.ID}
		/delay 1s
		/autoinv
	}
/return

Sub CheckTarget4
	/if (${Me.Hovering}) /return
	/if (!${Plugin[MQ2NetBots].Name.Equal[MQ2NetBots]}) {
		/echo Need to use netbots for this option. Enabling.
		/plugin mq2netbots load
		/netbots on send on grab on
	}
	/if (!${Defined[CheckTargetLoaded]}) /call CheckTargetLoad
	/if (!${Defined[TarID]}) /declare TarID int outer

	/if (${NetBots.Client.Find[${AssistPC}]} && ${NetBots[${AssistPC}].TargetID} && ${NetBots[${AssistPC}].TargetHP}<=${AssistAt} && (${NetBots[${AssistPC}].CombatState}==0||${NetBots[${AssistPC}].Attacking}) && ${Spawn[id ${NetBots[${AssistPC}].TargetID}].Distance}<=${AttackRange}) {
		/if (${AmIOffTank} && ${Me.XTarget}>1) /call OffTank
		/squelch /tar id ${NetBots[${AssistPC}].TargetID}
		/if (${NetBots[${AssistPC}].TargetID}!=${TarID}) /call ClearTarget
		/varset TarID ${NetBots[${AssistPC}].TargetID}
		/if (${OpeningMove.NotEqual[NULL]} && !${OpeningMove${TarID}}) {
			/docommand ${OpeningMove}
			/if (!${Defined[OpeningMove${TarID}]}) /declare OpeningMove${TarID} int outer 1
			/varset OpeningMove${TarID} 1
		}
		/if (${UseMelee}||${UseArchery}) /call Attacking2
	}
 	/if (${TarID} && (!${Spawn[${TarID}].ID}||${Spawn[${TarID}].Type.Equal[Corpse]}) || ${IgnoreList.Find[${Spawn[${TarID}].CleanName}]}|| ${IgnoreAll.Find[${Spawn[${TarID}].CleanName}]}) {
		/varset TarID 0
		/call ClearTarget
	}
/return

Sub Attacking1
	/if (${Me.Hovering}) /return
	/if (!${Me.Standing}) /stand
	/if (!${Me.Combat} && ${UseMelee}) /docommand ${AttackCommand}
/return

Sub Attacking2
	/if (${Me.Hovering}) /return
	/if (!${Defined[TarID]}) /declare TarID int outer
	/if (!${Me.Standing}) /stand
	
	:assisttype5
	/varset TarID ${Target.ID}
    /if (!${Me.Combat} && (${Me.Standing}||${Me.Mount.ID}) && ${Target.PctHPs}<=${AssistAt} && ${Target.ID}==${TarID} && ${Target.ID} && (!${UseArchery}||${UseArchery} && ${Target.Distance}<${ArcheryMinDistance})) { 
        /if (${UseMelee}) /squelch /docommand ${AttackCommand}
   		/if (${Verbose}) /docommand /${MyChannel} Attacking --> ${Target.DisplayName}
	}
	/varset AssistWait 10s	

	:wait
	/if (${Target.PctHPs}<=${AssistAt} && ${Target.ID}==${TarID} && ${Target.ID} && ${Target.Distance}<=${AttackRange} && ${Target.ID}) /goto :attackloop
	/doevents
	/if (${AssistWait}) /goto :wait
	/call CheckTarget${AssistType}

	:attackloop
	/if (${Me.Hovering}) /return
    /if (!${Me.Combat} && (${Me.Standing}||${Me.Mount.ID}) && ${Target.PctHPs}<=${AssistAt} && ${Target.ID}==${TarID} && ${Target.ID} && ${UseArchery} && ${Target.Distance}>=${ArcheryMinDistance} && ${Target.Distance}<=${ArcheryMaxDistance}) { 
		/face
		/ranged
		/squelch /autofire on
   		/if (${Verbose}) /docommand /${MyChannel} Autofire --> ${Target.DisplayName}
	}
	/if (!${Range.Between[0,20:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Me.Heading.Degrees}]}]}]} && ${Target.ID}) /face
	/if (${Target.Type.Equal[corpse]} && ${Me.XTarget[1].ID}||${Target.ID}==${Me.Pet.ID}||${Spawn[group ${Target.CleanName}].ID}==${Target.ID}) /squelch /tar clear
	/if (!${Target.ID}) {
		/call ClearTarget
		/return
	}
	/if (${Target.ID}!=${TarID}) /goto :newtarget
	/if (!${Me.Combat} && (!${UseArchery}||${UseArchery} && ${Target.Distance}<${ArcheryMinDistance})) /squelch /docommand ${AttackCommand}
	/call Combat
	/if (${Me.CombatState.Equal[COMBAT]}) /doevents
	/goto :attackloop

	:newtarget
	/if (${AssistType}==2 && (${Spawn[${Me.XTarget[1].ID}].Type.Equal[npc]}||${Spawn[${Me.XTarget[1].ID}].Master.Type.Equal[npc]}||${Spawn[${Me.XTarget[1].ID}].Master.Type.Equal[corpse]}) && ${Target.ID} && (${Target.Master.Type.Equal[npc]}||${Target.Type.Equal[npc]}||${Target.Master.Type.Equal[corpse]})) /goto :assisttype5
	/echo Somehow got new target. Re-assisting ${AssistPC}.
	/squelch /target clear

	/call ClearTarget
/return

#event ToggleOffTank "[MQ2] Toggle OffTank#*#"
Sub Event_ToggleOffTank
	/if (!${Defined[AmIOffTank]}) /declare AmIOffTank bool outer
	/varset AmIOffTank ${Ini[MyIni,Settings,AmIOffTank,FALSE]}
	/if (${AmIOffTank}) /mmoini "MyIni" "Settings" "AmIOffTank" "FALSE"
	/if (!${AmIOffTank}) /mmoini "MyIni" "Settings" "AmIOffTank" "TRUE"
	/varset AmIOffTank ${Ini[MyIni,Settings,AmIOffTank,FALSE]}
	/echo AmIOffTank set to ${AmIOffTank}
/return

Sub OffTank
	/if (${Me.Hovering}) /return
	/if (!${Defined[AmIOffTank]}) /declare AmIOffTank bool outer ${Ini[MyIni,Settings,AmIOffTank,FALSE]}
	/declare x int local
	/declare i int local
	/if (!${Defined[IgnoreImmuneLists]}) /declare IgnoreImmuneLists ${Ini[MyIni,Mez,IgnoreImmuneLists,FALSE]}
	/for i 1 to ${XTarget.Max}
		/if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].ID}!=${TarID} && !${IgnoreList.Find[${Me.XTarget[${i}].CleanName}]} && !${IgnoreAll.Find[${Me.XTarget[${i}].CleanName}]} && (${IgnoreImmuneLists}||!${MezImmuneList.Find[${Me.XTarget[${i}]}]})) /varcalc x ${x}+1
	/next i
	/if (${x}) {
		/for i 1 to ${XTarget.Max}
			/if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].ID}!=${TarID} && !${IgnoreList.Find[${Me.XTarget[${i}].CleanName}]}  && !${IgnoreAll.Find[${Me.XTarget[${i}].CleanName}]} && (${IgnoreImmuneLists}||!${MezImmuneList.Find[${Me.XTarget[${i}]}]}) && !${Spawn[group enc].ID} && !${Spawn[group brd].ID}) {
				/squelch /tar id ${Me.XTarget[${i}].ID}
				/varset TarID ${Me.XTarget[${i}].ID}
				/call ClearTarget
				/if (${UseMelee}||${UseArchery}) /call Attacking2
			}
		/next i
	}
/return

Sub ClearTarget
	/if (${Defined[OpeningMove${TarID}]}) /deletevar OpeningMove${TarID}
	/if (${Defined[DotTotal]}) /call ClearDots
	/if (${Defined[Hate]}) /varset Hate 0
	/if (${Defined[Snared]}) /varset Snared FALSE
	/if (${Defined[TarID]}) /varset TarID 0
	/if (${Defined[PetAttacking]}) /varset PetAttacking FALSE
	/if (${Defined[DebuffTotal]}) /call DebuffClear
	/if (${Defined[RootTotal]}) /call RootClear ${Target.ID}
	/if (${Defined[FightTimer]}) /varset FightTimer 0
/return

Sub ClearTarget2
	/if (${Defined[OpeningMove${TarID}]}) /deletevar OpeningMove${TarID}
	/if (${Defined[DotTotal]}) /call ClearDots
	/if (${Defined[Hate]}) /varset Hate 0
	/if (${Defined[Snared]}) /varset Snared FALSE
	/if (${Defined[PetAttacking]}) /varset PetAttacking FALSE
	/if (${Defined[FightTimer]}) /varset FightTimer 0
/return

Sub ClearHate
	/varset Hate 0
/return

Sub ClearAttack
	/if (${Plugin[MQ2Twist].Name.Length}) {
		/if (${Twist.Twisting}) /twist off
	}
	/squelch /tar clear
	/squelch /attack off
	/if (${Me.Casting.ID}) /call Interrupt
/return

#event ClearTargetData "#*#|${ClearTargetDataAlias}|#*#"
Sub Event_ClearTargetData
	/if (${ClearTargetDataAlias.Equal[NULL]}||!${ClearTargetDataAlias.Length}) /return
	/call ClearAttack
	/call ClearTarget
	/call ClearAddList
/return

Sub ClearAddList
	/varset AddCount 0
	/varset AddList |
	/call Debug 3 "Resetting AddList"
/return

Sub CombatLoad
	/call Debug 3 "In Sub CombatLoad"
	/declare CombatLoaded int outer 1
	/declare i int local
	/declare x int local
	/declare b int local
	/declare CL_PH int local
	/declare CombatRoutines string outer
	/for i 1 to 5
		/declare CombatCheck${i} string outer
		/declare CombatFrequency${i} string outer ${Ini[MyIni,Combat,CombatFrequency${i},123456]}
		/if (${CombatFrequency${i}.Equal[123456]}) {
			/mmoini "MyIni" "Combat" "CombatFrequency${i}"
			/varset CombatFrequency${i}
		}
	/next i
	/mmoini "MyIni" "Combat" "StandardCombatOptions" "Bard|XHeal|HealSingle|HealGroup|HealBalance|HealSelf|HealPet|Disc|MainTankBuff|FightBuff|Lifetap|Stun|AA|Dot|Nuke|Snare|ClickyNuke|Jolt|Rez|ModRod|Mana|Merc"
	/if (!${CombatFrequency1.Length} && !${CombatFrequency2.Length} && !${CombatFrequency3.Length} && !${CombatFrequency4.Length} && !${CombatFrequency5.Length}) {
		/mmoini "MyIni" "Combat" "CombatFrequency5" "Bard|XHeal|HealSingle|HealGroup|HealBalance|HealSelf|HealPet|Disc|MainTankBuff|FightBuff|Lifetap|Stun|AA|Dot|Nuke|Snare|ClickyNuke|Jolt|Rez|ModRod|Mana|Merc"
		/goto :skipcombatcheck
	}
	
	/for b 5 downto 1
		/for x 1 to ${Math.Calc[${CombatFrequency${b}.Count[|]}+1]}
			/for i 1 to ${b}
				/if (${CL_PH}>=5) /varcalc CL_PH ${CL_PH}-5
				/if (${b}==4) /varcalc CL_PH ${CL_PH}+${b}+2
				/if (${b}!=4) /varcalc CL_PH ${CL_PH}+${b}+1
				/if (${CL_PH}>5) /varcalc CL_PH ${CL_PH}-5
				/if (${CL_PH}>5) /varcalc CL_PH ${CL_PH}-5
				/if (${CL_PH}>5) /varcalc CL_PH ${CL_PH}-5
				/if (${CombatFrequency${b}.Arg[${x},|].Length}) /varset CombatCheck${CL_PH} ${CombatCheck${CL_PH}}${CombatFrequency${b}.Arg[${x},|]}|
			/next i
		/next x
	/next b
	
	/for b 1 to 5
		/if (${CombatCheck${b}.Find[||]}) /varset CombatCheck${b} ${CombatCheck${b}.Replace[||,|]}
		/varset CombatRoutines ${CombatRoutines}${CombatCheck${b}}
		/if (${CombatRoutines.Find[||]}) /varset CombatRoutines ${CombatRoutines.Replace[||,|]}
	/next b

	:skipcombatcheck
	/if (!${CombatRoutines.Length}||${CombatRoutines.Equal[|]}) /varset CombatRoutines Bard|XHeal|Heal|Disc|MainTankBuff|FightBuff|Lifetap|Stun|AA|Dot|Nuke|Snare|ClickyNuke|Jolt|Rez|ModRod|Mana|Merc|
	|/mmoini "MyIni" "Combat" "CombatRoutines" "${CombatRoutines}"
	/if (${CombatFrequency5.Equal[Bard|XHeal|HealSingle|HealGroup|HealBalance|HealSelf|HealPet|Disc|MainTankBuff|FightBuff|Lifetap|Stun|AA|Dot|Nuke|Snare|ClickyNuke|Jolt|Rez|ModRod|Mana|Merc]}) {
		/echo Protip: Consider editing [Combat] CombatFrequency5= to boost macro speed
		/mqlog ${Me.Class} -  Protip: Consider editing [Combat] CombatFrequency5= to boost macro speed
	}
	/if (!${Defined[AmIPuller]}) /declare AmIPuller bool outer ${Ini[MyIni,Pulling,AmIPuller,FALSE]}
	/if (${AmIPuller}) {
		/varset AssistType 2
	}
	/call Debug 3 "Leaving Sub CombatLoad"
/return

Sub MakeList
    /call Debug 3 "In Sub MakeList"
	/varset CurrentSub MakeList
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/if (!${Defined[MakeList1]}) /declare MakeList1 string outer Dot|Nuke|Snare|AA|Jolt|Stun|
	/if (!${Defined[MakeList2]}) /declare MakeList2 string outer Lifetap|FeignDeath|Fade|
	/if (!${Defined[MakeList3]}) /declare MakeList3 string outer HealSingle|HealSelf|HealBalance|HealGroup|
	/if (!${Defined[MakeList4]}) /declare MakeList4 string outer Mez|Debuff|Root|
	/if (!${Defined[MakeList5]}) /declare MakeList5 string outer FightBuff|SelfBuff|Aura|

	/declare i int local
	/declare x int local
	/declare y int local

	/for i 1 to 3
		/call Debug 3 "i: ${i} || MakeList${i}.Count[|]: ${MakeList${i}.Count[|]}"
		/for x 1 to ${MakeList${i}.Count[|]}
			/call Debug 3 "x: ${x} || Ini Value: ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}Total]}"
			/if (${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}Total]}) {
				/for y 1 to ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}Total]}
					/if (!${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}Total]}) /continue
					/if (${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}Use${y}]}) {
						/if (${i}==1) {
							/if (!${Defined[${MakeList${i}.Arg[${x},|]}UseAtMobPctHP]}) /declare ${MakeList${i}.Arg[${x},|]}UseAtMobPctHP string outer
							/if (!${Defined[${MakeList${i}.Arg[${x},|]}StopAtMobPctHP]}) /declare ${MakeList${i}.Arg[${x},|]}StopAtMobPctHP string outer
							/varset ${MakeList${i}.Arg[${x},|]}UseAtMobPctHP ${${MakeList${i}.Arg[${x},|]}UseAtMobPctHP} ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}UseAtMobPctHP${y}]}
							/varset ${MakeList${i}.Arg[${x},|]}StopAtMobPctHP ${${MakeList${i}.Arg[${x},|]}StopAtMobPctHP} ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}StopAtMobPctHP${y}]}
						}
						/if (${i}==2) {
							/if (!${Defined[${MakeList${i}.Arg[${x},|]}UseAtMyHP]}) /declare ${MakeList${i}.Arg[${x},|]}UseAtMyHP string outer
							/varset ${MakeList${i}.Arg[${x},|]}UseAtMyHP ${${MakeList${i}.Arg[${x},|]}UseAtMyHP} ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}UseAtMyHP${y}]}
						}
						/if (${i}==3) {
							/if (!${Defined[${MakeList${i}.Arg[${x},|]}UseAt]}) /declare ${MakeList${i}.Arg[${x},|]}UseAt string outer
							/if (!${Defined[${MakeList${i}.Arg[${x},|]}StopAt]}) /declare ${MakeList${i}.Arg[${x},|]}StopAt string outer
							/varset ${MakeList${i}.Arg[${x},|]}UseAt ${${MakeList${i}.Arg[${x},|]}UseAt} ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}UseAt${y}]}
							/varset ${MakeList${i}.Arg[${x},|]}StopAt ${${MakeList${i}.Arg[${x},|]}StopAt} ${Ini[MyIni,${MakeList${i}.Arg[${x},|]},${MakeList${i}.Arg[${x},|]}StopAt${y}]}
						}
						/if (${i}==4) {
							/if (!${Defined[${MakeList${i}.Arg[${x},|]}SpellIcon]}) /declare ${MakeList${i}.Arg[${x},|]}SpellIcon string outer
							/varset ${MakeList${i}.Arg[${x},|]}SpellIcon ${${MakeList${i}.Arg[${x},|]}SpellIcon}${${MakeList.Arg[${x},|]}SpellIcon{y}}
						}
					}
				/next y
			}
		/next x
	/next i

	/call Debug 3 "Leaving Sub MakeList"
/return

|**##########################################> Pulling sub order of operations <#######################################
PullingLoad -> Pulling -> FindMob -> Pull -> PullCheck -> ReturnCamp
Related Events: CannotSeeTarget, TogglePuller, TogglePullingMethod, MakeCamp/AddCamp/StopCamp/StartCamp/AddMobs
**|

#event TogglePuller "[MQ2] TogglePuller#*#"
Sub Event_TogglePuller
	/if (!${Defined[PullingLoaded]}) /call PullingLoad
	/if (${AmIPuller}) {
		/varset AmIPuller FALSE
	} else {
		/varset AmIPuller TRUE
	}
	/echo AmIPuller Toggled to ${AmIPuller}
/return

#event TogglePullingMethod "[MQ2] TogglePullingMethod #1#"
Sub Event_TogglePullingMethod(line,newmethod)
	/if (!${Defined[PullingLoaded]}) /call PullingLoad
	/mmoini "MyIni" "Pulling" "PullingMethod" "${newmethod}"
	/varset PullingMethod ${Ini[MyIni,Pulling,PullingMethod]}
	/echo PullingMethod Toggled to ${PullingMethod}
/return

Sub PullingLoad
	/squelch /moveto set usewalk off
	/squelch /moveto set BreakOnSummon off
	/if (!${Defined[PullingLoaded]}) /declare PullingLoaded bool outer FALSE
	/if (${PullingLoaded}) /return
	/squelch /alert add 1 arcane_distillect
	/varset PullingLoaded TRUE
	/declare pt int local
	/if (!${Defined[XTargetRadiusList]}) /declare XTargetRadiusList string outer 
	/noparse /varset XTargetRadiusList (${Range.Between[1,60:${Spawn[${Me.XTarget[1].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[2].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[3].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[4].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[5].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[6].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[7].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[8].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[9].ID}].Distance}]}||${Range.Between[1,60:${Spawn[${Me.XTarget[10].ID}].Distance}]})
	/if (!${Defined[AmIPuller]}) /declare AmIPuller bool outer 
	/varset AmIPuller ${Ini[MyIni,Pulling,AmIPuller]}
	/declare PullRadius int outer ${Ini[MyIni,Pulling,PullRadius,600]}
	/declare PullZRadius int outer ${Ini[MyIni,Pulling,PullZRadius,20]}
	/noparse /declare PullMob string outer ${Spawn[${NearestSpawn[${x}, npc noalert 1 ${Target${b}}]}]
	/declare PullStepRadius int outer ${Int[${Math.Calc[${PullRadius}/5]}]}
	/declare PullStep int outer
	/declare PullHistory[2,11] string outer 0
	/declare PullCastRange int outer ${Ini[MyIni,Pulling,PullCastRange,1]}
	/declare MQ2NavPullRadius int outer ${Ini[MyIni,Pulling,MQ2NavPullRadius,10]}
	/declare MQ2NavPullZRadius int outer ${Ini[MyIni,Pulling,MQ2NavPullZRadius,10]}
	/declare AlertListClear bool outer ${Ini[MyIni,Pulling,AlertListClear,FALSE]}
	/declare PullCondition string outer ${Ini[MyIni,Pulling,PullCondition,TRUE]}
	/if (!${AlertListClear}) /mmoini "MyIni" "Pulling" "AlertListClear" "FALSE"
	/declare AlertListClearTimer string outer ${Ini[MyIni,Pulling,AlertListClearTimer,60m]}
	/if (${AlertListClearTimer.Equal[60m]}) /mmoini "MyIni" "Pulling" "AlertListClearTimer" "60m"
	/declare PullAlertTimer timer outer
	/declare ReturnActionTotal int outer ${Ini[MyIni,Pulling,ReturnActionTotal]}
	/declare distancecheck int outer
	/declare distancemob int outer
	/for pt 1 to ${ReturnActionTotal}
		/declare ReturnAction${pt} string outer ${Ini[MyIni,Pulling,ReturnAction${pt}]}
	/next pt
	/if (${NeedLoad} && ${AmIPuller}==NULL) {
		/mmoini "MyIni" "Pulling" "AmIPuller" "FALSE"
		/squelch /alias /puller /echo TogglePuller
		/mmoini "MyIni" "Pulling" "PullRadius" "600"
		/mmoini "MyIni" "Pulling" "PullZRadius" "20"
		/mmoini "MyIni" "Pulling" "PullCastRange" "150"
		/mmoini "MyIni" "Pulling" "MQ2NavPullRadius" "10"
		/mmoini "MyIni" "Pulling" "MQ2NavPullZRadius" "10"
		/mmoini "MyIni" "Pulling" "ReturnActionTotal" "0"
		/mmoini "MyIni" "Pulling" "ReturnAction1"
		/mmoini "MyIni" "Pulling" "PullCondition"
	}
	/noparse /declare PullConditions string outer ${Ini[MyIni,Pulling,PullConditions,1]}
	/declare PullConColor string outer ${Ini[MyIni,Pulling,PullConColor]}
	/if (${PullConditions.Equal[1]}) /mmoini "MyIni" "Pulling" "PullConditions"
	/if (!${PullConColor.Length}||${PullConColor.Equal[NULL]}) /mmoini "MyIni" "Pulling" "PullConColor" "LIGHT BLUE,BLUE,WHITE,YELLOW"

	/call MobCampLoad
	/declare FindMobTimer timer outer 10s
	/declare PullCheck int outer
	/if (!${Defined[Pulling]}) /declare Pulling bool outer
	/declare ObstacleCount int outer
	/declare ObsX int outer
	/declare ObsY int outer
	/declare findtimer timer outer 60s
	/if (!${Defined[twisting]}) /declare twisting bool outer
	/if (!${Defined[XLOC]}) /declare XLOC int outer ${Me.X}
	/if (!${Defined[YLOC]}) /declare YLOC int outer ${Me.Y}
	/if (!${Defined[ZLOC]}) /declare ZLOC int outer ${Me.Z}
	/declare PullingMethod string outer ${Ini[MyIni,Pulling,PullingMethod]}
	/if (${PullingMethod.Find[nav]}||${PullingMethod.Find[hunt]}) {
		/if (${Plugin[MQ2Nav].Name.NotEqual[MQ2Nav]}) {
			/plugin MQ2Nav
			/echo Loaded MQ2Nav because your [Pulling] PullingMethod=${PullingMethod}
		}
		/delay 2s ${Plugin[MQ2Nav].Name.Equal[MQ2Nav]}
		/if (!${Navigation.MeshLoaded} && ${AmIPuller}) {
			/if (${Plugin[MQ2Nav].Name.Equal[MQ2Nav]} && !${Navigation.MeshLoaded}) /cechob \arMesh not created for this zone, MQ2Nav pulling cannot function.
			/echo [Pulling] PullingMethod=${PullingMethod} cannot be used.  MQ2Nav must be loaded, and a mesh must be created.
			/mqlog ${Me.Class} -  [Pulling] PullingMethod=${PullingMethod} cannot be used.  MQ2Nav must be loaded, and a mesh must be created.
			/varset PullingMethod standard
		}
	}
	/declare CourseCorrectionTimer string outer ${Ini[MyIni,Pulling,CourseCorrectionTimer,5]}
	/if (${CourseCorrectionTimer.Equal[5]}) /mmoini "MyIni" "Pulling" "CourseCorrectionTimer" "4"
	/declare UseLeap string outer ${Ini[MyIni,Pulling,UseLeap,FALSE]}
	/declare LeapName string outer ${Ini[MyIni,Pulling,LeapName,NULL]}
	/if (${LeapName.Equal[NULL]}) /mmoini "MyIni" "Pulling" "LeapName" "12345"
	/declare PullingAnnounceCMD string outer ${Ini[MyIni,Pulling,PullingAnnounceCMD,NULL]}
	/declare PullingTotal int outer ${Ini[MyIni,Pulling,PullingTotal,0]}
	/declare PullAtMyHPs int outer ${Ini[MyIni,Pulling,PullAtMyHPs,75]}
	/declare PullingTimer timer outer
	/declare PrePullSkillName string outer ${Ini[MyIni,Pulling,PrePullSkillName,----]}
	/declare PrePullSkillGem string outer ${Ini[MyIni,Pulling,PrePullSkillGem,----]}
	/declare PrePullSkillDelay string outer ${Ini[MyIni,Pulling,PrePullSkillDelay,----]}
	/declare PrePullDelay timer outer
	/declare PrePullSkillReuse string outer ${Ini[MyIni,Pulling,PrePullSkillReuse,----]}
	/declare PrePullReuse timer outer
	/if (${PrePullSkillName.Equal[123456]}) {
		/mmoini "MyIni" "Pulling" "PrePullSkillName" "----"
		/mmoini "MyIni" "Pulling" "PrePullSkillGem" "----"
		/mmoini "MyIni" "Pulling" "PrePullSkillDelay" "----"
		/mmoini "MyIni" "Pulling" "PrePullSkillReuse" "----"
	}
	/if (!${Defined[pt]}) /declare pt int outer 0
	/for pt 1 to ${PullingTotal}
		/if (!${Bool[${Ini[MyIni,Pulling,PullSkillName${pt}]}]}) {
			/mmoini "MyIni" "Pulling" "PullSkillName${pt}" "----"
			/mmoini "MyIni" "Pulling" "PullSkillGem${pt}" "----"
			/mmoini "MyIni" "Pulling" "PullSkillRequiresLineOfSight${pt}" "TRUE"
			/mmoini "MyIni" "Pulling" "PullSkillDistance${pt}" "16"
		}
		/declare PullSkillName${pt} string outer ${Ini[MyIni,Pulling,PullSkillName${pt},NULL]}
		/declare PullSkillRequiresLineOfSight${pt} string outer ${Ini[MyIni,Pulling,PullSkillRequiresLineOfSight${pt},TRUE]}
		/declare PullSkillDistance${pt} int outer ${Ini[MyIni,Pulling,PullSkillDistance${pt}]}
		/declare PullSkillGem${pt} string outer ${Ini[MyIni,Pulling,PullSkillGem${pt},NULL]}
		/if (${PullSkillGem${pt}.Equal[NULL]}) {
			/if (${Me.Gem[${PullSkillName${pt}}]}) /varset PullSkillGem${pt} gem${Me.Gem[${PullSkillName${pt}}]}
			/if (!${Me.Gem[${PullSkillName${pt}}]} && ${Me.Book[${PullSkillName${pt}}]})  /varset PullSkillGem${pt} gem1
			/if (${Me.AltAbility[${PullSkillName${pt}}]})  /varset PullSkillGem${pt} alt
			/if (${Me.Ability[${PullSkillName${pt}}]})  /varset PullSkillGem${pt} ability
			/if (${Me.CombatAbility[${PullSkillName${pt}}]})  /varset PullSkillGem${pt} disc
			/if (${FindItem[=${PullSkillName${pt}}].ItemSlot})  /varset PullSkillGem${pt} item
			/if (${FindItem[${PullSkillName${pt}}].Type.Equal[Archery]})  /varset PullSkillGem${pt} bow
			/if (${FindItem[${PullSkillName${pt}}].Type.Equal[Ammo]}||${FindItem[${PullSkillName${pt}}].Type.Find[Throwing]})  /varset PullSkillGem${pt} ammo
			/mmoini "MyIni" "Pulling" "PullSkillGem${pt}" "PullSkillGem${pt}"
		}
		/if (${PullSkillGem${pt}.Equal[bow]}) {
			/melee bow=${FindItem[=${PullSkillName${pt}}].ID}
			/melee arrow=${InvSlot[22].Item.ID}
			/echo Using ${PullSkillName${pt}} as bow and ${InvSlot[22].Item.Name} as ammo.  If this isnt correct, equip the correct items and restart macro.
		}
		/if (${PullSkillGem${pt}.Equal[ammo]}) {
			/melee bow=${FindItem[=${PullSkillName${pt}}].ID}
			/melee arrow=${FindItem[=${PullSkillName${pt}}].ID}
			/echo Using ${PullSkillName${pt}} as throwing item.  If this isnt correct, equip the correct items and restart macro.
		}
		/declare PullSkillSummon${pt} string outer ${Ini[MyIni,Pulling,PullSkillSummon${pt}]}
	/next pt
	/if (!${Defined[PullSkillRequiresLineOfSight1]}) /declare PullSkillRequiresLineOfSight1 string outer ${Ini[MyIni,Pulling,PullSkillRequiresLineOfSight1,TRUE]}
	/if (!${Defined[PullSkillRequiresLineOfSight2]}) /declare PullSkillRequiresLineOfSight2 string outer ${Ini[MyIni,Pulling,PullSkillRequiresLineOfSight2,TRUE]}
	
	/squelch /alias /pullingmethod /echo TogglePullingMethod
	/if (${AmIPuller} && !${PullingTotal}) {
		/echo You are set to pull but have [Pulling] PullingTotal=0
		/mqlog ${Me.Class} -  You are set to pull but have [Pulling] PullingTotal=0
	}
	/if (${AmIPuller} && ${PullSkillName1.Equal[NULL]}) {
		/echo You are set to pull but have [Pulling] PullSkillName1=  blank
		/mqlog ${Me.Class} -  You are set to pull but have [Pulling] PullSkillName1=  blank
	}		
	/if (${NeedLoad} && !${PullingTotal}) {
		/mmoini "MyIni" "Pulling" "PullingMethod" "Standard"
		/mmoini "MyIni" "Pulling" "PullingAnnounceCMD" "----"
		/mmoini "MyIni" "Pulling" "PullingTotal" "1"
		/mmoini "MyIni" "Pulling" "PullAtMyHPs" "75"
		/declare pt1 int local
		/for pt1 1 to 2
			/mmoini "MyIni" "Pulling" "PullSkillName${pt1}" "/attack on"
			/mmoini "MyIni" "Pulling" "PullSkillRequiresLineOfSight${pt1}" "TRUE"
			/mmoini "MyIni" "Pulling" "PullSkillGem${pt1}" "----"
			/mmoini "MyIni" "Pulling" "PullSkillDistance${pt1}" "----"
			/mmoini "MyIni" "Pulling" "PullSkillSummon${pt1}" "----"
		/next pt1
	}
	/if (${PullSkillName1.Equal[/attack on]}) {
		/varset PullCastRange ${Me.MaxRange}
		/varset PullSkillDistance1 ${Me.MaxRange}
	}
/return

Sub Pulling
	/call Debug 4 "Entered Sub Pulling"
	/if (!${Defined[PullingLoaded]}) /call PullingLoad
	/if (${Me.Feigning}||${NeedLoad}||${Me.Hovering}||(${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]})&& ${PullCondition}) /return
	/if (!${PullCheck}) {
		/varset PullCheck 1
		/call Rest
	}
	/if (!${PullAlertTimer} && ${AlertListClear}) {
		/varset PullAlertTimer ${Ini[MyIni,Pulling,AlertListClearTimer]}
		/call AlertRecheck 1 "${Ini[MyIni,Pulling,AlertListClearTimer]}"
	}
	|/call GroupManaChk - Working on these subs from previous macro to implement them into this macro Chatwiththisname
	|/call GroupHealthChk
	/if (!${Me.CombatState.Equal[COMBAT]} && !${Me.XTarget} && !${AddCount} && (${MyCamp.Length}||${PullingMethod.Find[standard]}||${PullingMethod.Find[seek]}) && ${Me.PctHPs}>=${PullAtMyHPs}) {
		/call FindMob
	}
	/if (${AddMobs} && ${Target.ID}) {
		/call AddMob
	}
	/if (${PullingMethod.Find[hunt]}) {
		/call Hunt
		/return
	}
	/if (${PullingMethod.Find[seek]}) {
		/call Seek
		/return
	}
	/if ((${Me.XTarget}||${Me.CombatState.Equal[Combat]} && ${Pulling})) /call ReturnCamp
/return

Sub FindMob
	/call Debug 4 "Entered Sub FindMob"
	/if (${Me.Feigning}||${Me.Hovering}||${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]}) /return
	/if (${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}) /return
	/squelch /keypress home
	/doevents
	/declare i int local
	/if (${PullingMethod.Find[nav]}) {
		/if (!${FindMobTimer}) {
			/echo MQ2Nav Target Scan: ${MQ2NavPullRadius} range from your points on ${MyCamp} with ${MQ2NavPullZRadius} zradius.
			/varset FindMobTimer ${FindMobTimer.OriginalValue}
		}
		/declare fm int local
		/for fm 0 to ${${MyCamp}Total}
			/if (${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}) /return
			/varset PullConditions ${Ini[MyIni,Pulling,PullConditions,1]}
			/if ((${PullConditions}) && !${Spell[${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].CleanName}].Extra.Left[2].Equal[IO]} && !${${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].ID}PullTimer} && ${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].ID} && !${IgnoreList.Find[${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].CleanName}]} && !${IgnoreAll.Find[${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].CleanName}]})  {
				/squelch /tar id ${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].ID}
				/delay 1s ${Target.ID}
				/delay 8
				/if (${Target.SecondaryAggroPlayer.ID}) {
					/if (!${Defined[${Target.ID}PullTimer]}) /declare ${Target.ID}PullTimer timer outer 5m			
					/imob1
					/delay 1s
					/squelch /tar clear
				 	/continue
				}
				/call Pull ${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].ID}
				/return
			}
		/next fm
		
		/if (!${findtimer} && !${Target.ID}) {
			/echo No mobs up at camp, waiting.  I'm not ignoring you.
			/varset findtimer ${findtimer.OriginalValue}
			/return
		}
	}
	
	/if (${PullingMethod.Find[standard]}) {
		/if (${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}) /return
		/if (!${FindMobTimer}) {
			/echo Target scan: ${PullRadius} range with ${PullZRadius} zradius.
			/varset FindMobTimer ${FindMobTimer.OriginalValue}
		}
	
		/for i 1 to ${SpawnCount[npc noalert 1 radius ${PullRadius}]}
			/varset PullConditions ${Ini[MyIni,Pulling,PullConditions,1]}
			/if (!${Defined[PullTimer]}) {
				/if ((${PullConditions}) && !${Spell[${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}].CleanName}].Extra.Left[2].Equal[IO]} && !${Defined[${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}].ID}PullTimer]} && (${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}].ID}||${PullingTotal}==1 && !${PullSkillRequiresLineOfSight1}) && !${Me.XTarget[1].ID} && !${IgnoreList.Find[${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}].CleanName}]} && !${IgnoreAll.Find[${Spawn[loc ${XLOC} ${YLOC} npc noalert 1 radius ${If[${i},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].CleanName}]} && ${Select[${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}].ConColor},${PullConColor}]}) {
					/squelch /tar ${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}]}
					/delay 1s ${Target.ID}
					/delay 8
					/if (${Target.SecondaryAggroPlayer.ID}) {
						/if (!${Defined[${Target.ID}PullTimer]}) /declare ${Target.ID}PullTimer timer outer 5m
						/imob1
						/delay 1s
						/squelch /tar clear
						/continue
					}
					/if (!${findtimer} && !${Target.ID}) {
						/echo No mobs up at camp, waiting. I'm not ignoring you.
						/varset findtimer ${findtimer.OriginalValue}
						/moveto ${XLOC} ${YLOC} loose
						/return
					}
					/if (${Int[${Math.Abs[${Math.Calc[${Me.Z}-${Target.Z}]}]}]}>${PullZRadius}) { 
						/echo ${NearestSpawn[${i}, npc noalert 1 radius ${PullRadius} zradius ${PullZRadius}]} is beyond PullZRadius allowances, picking another...
						/squelch /tar clear
						/continue
					}
					|/squelch /moveto set breakonaggro on
					/call Pull ${Target.ID}
					/return
				}
			}
		/next i
		
		/if (!${findtimer}) {
			/echo ${If[${PullConditions},No mobs up within specifications.,PullConditions not met.]}
			/varset findtimer ${findtimer.OriginalValue}
		}
	}
/return

#event PullHold "Your spell did not take hold."
Sub Event_PullHold
	/call Debug 4 "Entered Sub Event_PullHold"
	/if (!${Pulling}) /return
	/alert add 1 npc ${Target}
	/squelch /tar clear
/return

Sub Pull(int spawnid)
	/call Debug 4 "Entered Sub Pull"
	/if (!${spawnid}) /return
	/varset CurrentSub Pulling
	|/echo Attempting to pull ${Spawn[ id ${spawnid}]}
	/if (${Me.Feigning}||${Me.Hovering}||${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]}||${Me.XTarget}||${Me.CombatState.Equal[COMBAT]}) /return
	/if (!${Defined[Pulling]}) /declare Pulling bool outer
	/varset Pulling TRUE
	/cechob \atPulling --> ${Spawn[${spawnid}]}
	/declare i int local
	/varcalc i 15+${Math.Calc[${Spawn[${spawnid}].Distance}/50].Int}
	/varset PullingTimer ${i}s
	/declare CCTimer timer local ${Ini[MyIni,Pulling,CourseCorrectionTimer,5]}
	
	:move
	/if (!${Target.ID}) /call ReturnCamp
	/if (!${CCTimer} && ${Target.Moving}) {
		/varset CCTimer ${CCTimer.OriginalValue}
		/if (${PullingMethod.Find[nav]}) {
			/nav id ${spawnid}
		}
		/if (${PullingMethod.Find[Standard]}) {
			/moveto id ${spawnid} breakonaggro breakonhit
		}
	}
	/if (${Me.Hovering}) {
		/varset Pulling FALSE
		/return
	}
	/if (${Target.SecondaryAggroPlayer.ID} && !${SpawnCount[group ${Target.SecondaryAggroPlayer}]} && !${Me.Pet.CleanName.Find[${Target.SecondaryAggroPlayer}]}) {
		/echo Someone else has already aggrod ${Target}, returning to camp and picking something else.
		/squelch /tar clear
		/call ReturnCamp
	}
	/if (!${PullingTimer}) {
		/echo It's been ${Math.Calc[${PullingTimer.OriginalValue}/10]} seconds and this isn't working. Let's try again and ignore this mob from now on.
		/if (${MoveUtils.Command.Equal[MOVETO]}) {
			/moveto off
			/keypress back
		}
		/if (${Target.ID}) {
			/imob1
			/delay 3
			/squelch /tar clear
		}
		/if (${Pulling}) /call ReturnCamp
		/return
	}
	|/echo Moving...
	/if ((${Me.XTarget}||${Me.CombatState.Equal[COMBAT]}) && ${Pulling}) {
		/echo Seems we got some aggro. Returning to base.
		/call ReturnCamp
		/return
	}
	/if (${Plugin[MQ2Twist].Name.Length}) {
		/if (${Twist.Twisting}) {
			/varset twisting TRUE
			/squelch /twist stop
		}
	}
	/call PullCheck ${spawnid}
	
	|Standard Pulling
	/if (${PullingMethod.Find[standard]} && !${Me.Moving}) {
 		/doevents
      	/if ((${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}||!${Target.ID}) && ${Pulling}) {
      		/call ReturnCamp
      		/goto :skip
      	}
      	/if ((${Int[${Target.Distance}]}>${PullCastRange}||!${Target.LineOfSight} && ${PullSkillRequiresLineOfSight1}||!${Target.LineOfSight} && ${PullSkillRequiresLineOfSight1} && ${PullSkillRequiresLineOfSight2} && ${PullingTotal}==2) && !${Stick.Distance} && !${MoveUtils.Command.Equal[MOVETO]}) /moveto id ${spawnid} loose
        /call PullCheck
      	/if (${UseLeap} && ${LeapName.NotEqual[NULL]} && ${Me.AltAbilityReady[${LeapName}]} && ${Target.Distance}>350) {
			/alt act ${Me.AltAbility[${LeapName}].ID}
			/delay 2
      	}
      	/if (${Int[${Target.Distance}]}>${PullCastRange} && !${Me.XTarget}) /goto :move
	}

	|Seeking
	/if (${PullingMethod.Find[seek]} && !${Me.Moving}) {
 	  	/doevents
    	/if ((${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}||!${Target.ID}) && ${Pulling}) {
      		/moveto off
      		/call CheckTarget2
      		/goto :skip
      	}
      	/if ((${Int[${Target.Distance}]}>${PullCastRange}||!${Target.LineOfSight} && ${PullSkillRequiresLineOfSight1}||!${Target.LineOfSight} && ${PullSkillRequiresLineOfSight1} && ${PullSkillRequiresLineOfSight2} && ${PullingTotal}==2) && !${Stick.Distance} && !${MoveUtils.Command.Equal[MOVETO]}) /moveto id ${spawnid} loose
      	/call PullCheck
      	/if (${Int[${Target.Distance}]}>${PullCastRange} && !${Me.XTarget}) /goto :move
	}

	|MQ2Nav Pulling
	/if (${PullingMethod.Find[nav]}) {
		/if (!${Navigation.Active}) {
			/nav id ${spawnid}
			/echo Nav to ${Spawn[${spawnid}]}
			/if (${Plugin[MQ2Twist].Name.Length}) {
				/if (${Twist.Twisting}) {
					/varset twisting TRUE
					/squelch /twist off
				}
			}
			/call PullCheck
			/if (${Int[${Target.Distance}]}>${PullCastRange} && !${Me.XTarget}) /goto :move
		}
	}

	/if (${Me.Hovering}) {
		/varset Pulling FALSE
		/return
	}	
	/if (!${Me.XTarget}) /goto :move

	:skip
/return

Sub PullCheck
	/call Debug 4 "Entered Sub PullCheck"
	/if (${Me.Hovering}) {
		/varset Pulling FALSE
		/return
	}
	/if ((${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}) && ${Pulling}) /call ReturnCamp
	|/echo is MoveUtils Sutck: ${MoveUtils.Stuck}
	/if (${MoveUtils.Stuck}) /call MoveCheck
    /if (${Me.Casting.ID}||${Int[${Target.Distance}]}>${PullCastRange}||!${Target.LineOfSight} && ${PullSkillRequiresLineOfSight1}||!${Target.LineOfSight} && ${PullSkillRequiresLineOfSight1} && ${PullSkillRequiresLineOfSight2} && ${PullingTotal}==2) /return
	/if (${PullingMethod.Find[nav]}) {
		/if (${Navigation.Active}) /nav stop
	}
	/if (${MoveUtils.Command.Equal[MOVETO]}) /moveto off
	/if (${Me.Moving}) /keypress back
	/delay 1s !${Me.Moving}
	/if (${Stick.Distance}) /stick off
	/if (${Target.Type.Equal[pc]}) /squelch /tar clear
	/if (${PullSkillName1.Equal[/attack on]}) {
		/if (!${Stick.Active}) {
			/echo Sticking to target for melee attack. 
			/stick 6 uw
		}
	}

	:castingpull
	/doevents PullHold
	/doevents CannotSeeTarget
	/if (${Plugin[MQ2Twist].Name.Length}) {
		/if (!${Defined[CanEngage]}) /declare CanEngage string outer ((${Target.LineOfSight}||!${PullSkillRequiresLineOfSight1}) && !${Me.XTarget} && !${Me.CombatState.Equal[COMBAT]} && (!${Me.Moving}||${Me.Class.ShortName.Equal[BRD]}||${PullSkillName1.Equal[/attack on]}) && (!${Me.Casting.ID}||${Twist.Twisting}) && ((${Me.SpellReady[${PullSkillName1}]}||${Me.CombatAbilityReady[${PullSkillName1}]}||${Me.AltAbilityReady[${PullSkillName1}]})||(!${Me.Gem[${PullSkillName1}]} && ${PullSkillGem1.Find[gem]})||(${FindItem[${PullSkillName1}].ItemSlot} && !${FindItem[${PullSkillName1}].Timer})||${PullSkillName1.Equal[/attack on]}))
	} else {
		/if (!${Defined[CanEngage]}) /declare CanEngage string outer ((${Target.LineOfSight}||!${PullSkillRequiresLineOfSight1}) && !${Me.XTarget} && !${Me.CombatState.Equal[COMBAT]} && (!${Me.Moving}||${Me.Class.ShortName.Equal[BRD]}||${PullSkillName1.Equal[/attack on]}) && !${Me.Casting.ID} && ((${Me.SpellReady[${PullSkillName1}]}||${Me.CombatAbilityReady[${PullSkillName1}]}||${Me.AltAbilityReady[${PullSkillName1}]})||(!${Me.Gem[${PullSkillName1}]} && ${PullSkillGem1.Find[gem]})||(${FindItem[${PullSkillName1}].ItemSlot} && !${FindItem[${PullSkillName1}].Timer})||${PullSkillName1.Equal[/attack on]}))
	}
	/if (${PullSkillName1.Equal[/attack on]}) {
		/varset CanEngage TRUE
	}
	|/echo ${CanEngage}
	/if (${Me.Sitting}) /stand
	/if (${CanEngage}) {
		/if (${PullSkillName1.Equal[/attack on]}) {
			/if (!${Stick.Active}) /stick 10
			/if (${Me.Sitting}) {
				/stand
			}
			/attack on
			/delay 1s
		}
		/if (${Me.SpellReady[${PrePullSkillName}]}||${Me.AltAbilityReady[${PrePullSkillName}]}||${Me.CombatAbilityReady[${PrePullSkillName}]} && ${Me.CurrentEndurance}>${Spell[${PrePullSkillName}].EnduranceCost}||${FindItem[=${PrePullSkillName}].ItemSlot} && !${FindItem[=${PrePullSkillName}].Timer} && !${PrePullReuse}) {
			/call Cast "${PrePullSkillName}" "${PrePullSkillGem}" NULL NULL NULL
		 	/varset PrePullReuse ${PrePullSkillReuse}
		 	/if (!${PrePullDelay}) {
		 		/delay ${PrePullSkillDelay}
		 		/varset PrePullDelay ${PrePullSkillDelay}
			}
	 	}

		/if (${Select[${PullSkillGem1},bow,ammo]}) /face
		/echo ${PullSkillName1} --> ${Target}
		/if (${PullSkillGem1.Equal[bow]}) /ranged
		/if (${PullSkillGem1.Equal[ammo]}) /throwit
		/if (${Me.Class.ShortName.Equal[BRD]} && ${Me.Gem[${PullSkillName1}]} && ${Plugin[MQ2Twist].Name.Length}) {
			/twist once ${Me.Gem[${PullSkillName1}]}
			/echo Twisting once ${PullSkillName1}
		}
		/if (!${Spell[${PullSkillName1}].Slot[1].Find[Summon ]} && !${Select[${PullSkillGem1},bow,ammo]} && (!${Me.Class.ShortName.Equal[BRD]}||!${Me.Gem[${PullSkillName1}]})) {
			/call Debug 3 "Attempting to pull with castable Pull Skill 1 (${PullSkillName1} - ${PullSkillGem1})"
			/call Cast "${PullSkillName1}" ${PullSkillGem1} Blue PullAggroCheck NULL
		}
    	/if (${Spell[${PullSkillName1}].Slot[1].Find[Summon ]} && ${Me.Pet.ID}) /pet attack  		
	}
	/if (${Defined[PullSkillName2]}) {
		/declare bTwistOn bool outer FALSE
		/if (${Plugin[MQ2Twist].Name.Length}) {
			/varset bTwistOn TRUE
		} else {
			/varset bTwistOn FALSE
		}
		/if ((${Target.LineOfSight}||!${PullSkillRequiresLineOfSight2}) && ${PullingTotal}==2 && !${Me.XTarget} && !${Me.CombatState.Equal[COMBAT]} && (!${Me.Moving}||${Me.Class.ShortName.Equal[BRD]}) && (!${Me.Casting.ID}||${bTwistOn}) && ((${Me.SpellReady[${PullSkillName2}]}||${Me.CombatAbilityReady[${PullSkillName2}]}||${Me.AltAbilityReady[${PullSkillName2}]})||(!${Me.Gem[${PullSkillName2}]} && ${PullSkillGem2.Find[gem]})||(${FindItem[${PullSkillName2}].ItemSlot} && !${FindItem[${PullSkillName2}].Timer}))) {
			/if (${Me.SpellReady[${PrePullSkillName}]}||${Me.AltAbilityReady[${PrePullSkillName}]}||${Me.CombatAbilityReady[${PrePullSkillName}]} && ${Me.CurrentEndurance}>${Spell[${PrePullSkillName}].EnduranceCost}||${FindItem[=${PrePullSkillName}].ItemSlot} && !${FindItem[=${PrePullSkillName}].Timer} && !${PrePullSkillReuse}) {
				/call Cast "${PrePullSkillName}" "${PrePullSkillGem}" NULL NULL NULL
				/varset PrePullReuse ${PrePullSkillReuse}
				/if (!${PrePullDelay}) {
					/delay ${PrePullSkillDelay}
					/varset PrePullDelay ${PrePullSkillDelay}
				}
			}
			/echo ${PullSkillName2} --> ${Target}
			/if (${Select[${PullSkillGem2},bow,ammo]}) /face
			/if (${PullSkillGem2.Equal[bow]}) /ranged
			/if (${PullSkillGem2.Equal[ammo]}) /throwit
			/if (!${Spell[${PullSkillName1}].Slot[1].Find[Summon ]} && !${Select[${PullSkillGem2},bow,ammo]}) {
				/call Debug 3 "Attempting to pull with castable Pull Skill 2 (${PullSkillName2} - ${PullSkillGem2}"
				/call Cast "${PullSkillName2}" ${PullSkillGem2} Blue PullAggroCheck NULL
			}
			/if (${Spell[${PullSkillName2}].Slot[1].Find[Summon ]} && ${Me.Pet.ID}) /pet attack  		
		}
	
	
		/if (${Me.Hovering}) {
			/call Debug 3 "I'm dead, disabling pulling"
			/varset Pulling FALSE
			/return
		}
		
		/if (!${Me.CombatState.Equal[COMBAT]} && !${Me.XTarget} && (${Target.Distance}<${PullSkillDistance1}||${Target.Distance}<${PullSkillDistance2} && ${PullingTotal}==2) && ${Target.LineOfSight}) {
			/call Debug 3 "Pull casting failed, trying again"
			/goto :castingpull 
		}
	}
/return

Sub PullAggroCheck
	/call Debug 4 "Entered Sub PullAggroCheck"
	/if (${Me.CombatState.Equal[COMBAT]}) {
		/call Interrupt
		/call ReturnCamp
	}	
/return

|**Movement related checks/events:  MoveCheck, CannotSeeTarget, ReturnCamp
**|

#event CannotSeeTarget "You cannot see your target."
Sub Event_CannotSeeTarget
	/if (!${Pulling}) /return
	/if (${Pulling}) {
		/if (${PullingMethod.Find[nav]}) {
			/keypress forward hold
			/delay 5
			/keypress forward
			/keypress back
			/goto :skip
		}
		/call MoveCheck 1
	}

	:skip
	/if (${Me.Pet.ID}&&(${Spell[${PullSkillName1}].Slot[1].Find[Summon ]}||${Spell[${PullSkillName1}].Slot[1].Find[Summon ]} && ${PullingTotal}==2)) /pet attack
/return

Sub MoveCheck(int forcemovecheck)
	/declare i int local ${Stick.StickTarget}
	/declare x int local ${Stick.Distance}
	/if (${MoveUtils.Stuck}||!${PullingMethod.Find[nav]} && ${forcemovecheck}) {
		/moveto off
		/if (${Math.Rand[99]}>50) {
			/keypress back hold
		} else {
			/keypress forward hold
		}
		/delay 1s
		/keypress back
		/keypress forward
		/if (${Me.XTarget}) {
			/if (${Pulling}) /call ReturnCamp
			/return
		}
		/keypress back
		/if (${Math.Rand[99]}>50) {
        	/keypress strafe_right hold
        } else {
        	/keypress strafe_left hold
        }
		/if (${Me.XTarget}) {
			/if (${Pulling}) /call ReturnCamp
			/return
		}
        /delay 1s
        /keypress strafe_right
        /keypress strafe_left
		/if (${Me.FeetWet}) {
			/keypress page_down hold
				/if (${Me.XTarget}) {
					/if (${Pulling}) /call ReturnCamp
					/return
				}
			/delay 1s
			/keypress page_down
		}
	}
	
	/if (${PullingMethod.Find[nav]} && ${forcemovecheck}) {
		/keypress forward hold
		/delay 5
		/keypress forward
		/keypress back
	}
	
	|/if (${i}||${Stick.StickTarget}) /stick id ${Stick.StickTarget} ${x}
/return

Sub ReturnCamp
	/varset CurrentSub ReturnCamp
	/if (${Pulling}) /varset PullingAnnounceCMD ${Ini[MyIni,Pulling,PullingAnnounceCMD,NULL]}
	/if (${Pulling} && ${Me.CombatState.Equal[COMBAT]} && ${Target.ID} && ${PullingAnnounceCMD.NotEqual[NULL]}) /docommand ${PullingAnnounceCMD}
	/if (${Me.Pet.Following.ID}) /pet back off
	/if (${ReturnActionTotal}) {
		/declare i int local
		/for i 1 to ${ReturnActionTotal}
			/varset ReturnAction${i} ${Ini[MyIni,Pulling,ReturnAction${i},123456]}	
			/if (${ReturnAction${i}.NotEqual[123456]}) /docommand ${ReturnAction${i}}
			/if (${ReturnAction${i}.Find[/twist]}) /varset twisting TRUE
		/next i
	}
	/if (${Plugin[MQ2Twist].Name.Length}) {
		/if (${twisting} && !${Twist.Twisting}) /squelch /twist
	}
	/if (${PullingMethod.Find[nav]}) /nav locxyz ${XLOC} ${YLOC} ${ZLOC}
	|/if (${PullingMethod.Find[standard]} && ${Pulling}) /squelch /moveto set breakonaggro off
	/if (${PullingMethod.Find[standard]}) {
		/moveto loc ${YLOC} ${XLOC} loose
		/face loc ${YLOC},${XLOC}
		/delay 2
	}

	:wait
	/doevents
	/delay 1
    /if (${UseLeap} && ${LeapName.NotEqual[NULL]} && ${Me.AltAbilityReady[${LeapName}]} && (${Math.Distance[${Me.X},${Me.Y}:${XLOC},${YLOC}]}>250 && ${Math.Distance[${Target.X},${Target.Y}:${XLOC},${YLOC}]}<=600||${Debuff.Snared} && ${Math.Distance[${Me.X},${Me.Y}:${XLOC},${YLOC}]}>=120)) {
    	/alt act ${Me.AltAbility[${LeapName}].ID}
    	/delay 2
    	/if (${PullingMethod.Find[nav]}) /nav locxyz ${XLOC} ${YLOC} ${ZLOC}
    	/if (${PullingMethod.Find[standard]}) /moveto loc ${YLOC} ${XLOC} loose
    }
	/if (${Math.Distance[${Me.X},${Me.Y}:${XLOC},${YLOC}]}>16) {
		/if (!${MoveTo.Moving}) {
			/moveto loc ${YLOC} ${XLOC} loose
			/echo I wasn't moving for some unknown reason, but I am now.
		}
		/goto :wait
	}
	/if (!${MoveUtils.Command.Equal[MOVETO]}) /moveto off
	/if (${Target.ID} && !${XTargetList.Count[${Target.ID}]} && ${Pulling} && ${Me.XTarget}) /squelch /tar clear
	/varset Pulling FALSE
	/varset PullCheck 0
/return

Sub Hunt
	/if (${LootNPCs} && !${Me.XTarget}) /call LootMobs
	/if (${UseCamp}) /varset UseCamp FALSE
	/if (${AssistType}!=2) /varset AssistType 2
	/if (!${Defined[PullingLoaded]}) /call PullingLoad
	/if (${Me.XTarget[1].ID} && ${UseMelee} && !${Me.Combat}) /docommand ${AttackCommand}
	/if (${Me.CombatState.NotEqual[COMBAT]} && (${Target.LineOfSight}||!${PullSkillRequiresLineOfSight1}) && ${Target.Distance}<=${PullSkillDistance1} && (${Me.AltAbilityReady[${PullSkillName1}]}||${Me.SpellReady[${PullSkillName1}]}||${FindItem[${PullSkillName1}].ItemSlot} && !${FindItem[${PullSkillName1}].Timer}||${Me.CombatAbilityReady[${PullSkillName1}]}||${Me.AbilityReady[${PullSkillName1}]})) {
		/if (${Navigation}) {
			/if (${Navigation.Active}) /nav stop
		}
		/call Cast "${PullSkillName1}" ${PullSkillGem1} NULL NULL NULL
	} else {
		/if (${Me.CombatState.NotEqual[COMBAT]} && (${Target.LineOfSight}||!${PullSkillRequiresLineOfSight2}) && ${Target.Distance}<=${PullSkillDistance2} && (${Me.AltAbilityReady[${PullSkillName2}]}||${Me.SpellReady[${PullSkillName2}]}||${FindItem[${PullSkillName2}].ItemSlot} && !${FindItem[${PullSkillName2}].Timer}||${Me.CombatAbilityReady[${PullSkillName2}]}||${Me.AbilityReady[${PullSkillName2}]})) {
			/if (${Navigation}) {
				/if (${Navigation.Active}) /nav stop
			}
			/call Cast "${PullSkillName2}" ${PullSkillGem2} NULL NULL NULL
		}
	}
	/if (!${Me.CombatState.Equal[COMBAT]} && !${MovePullTimer} && ${Plugin[MQ2Nav].Name.Equal[MQ2Nav]}) {
		/if (!${Defined[MovePullTimer]}) /declare MovePullTimer timer outer 1m
		/nav locxyz ${XLOC} ${YLOC} ${ZLOC}
		/varset MovePullTimer 1m
	}
	/if (${Navigation}) {
		/if (${Navigation.Active} && (${Me.CombatState.Equal[COMBAT]}||${Me.XTarget})) {
			/nav stop
			/call CheckTarget2
		}
	}
	/declare i int local

	/if (${Navigation}) {
		/if (${Me.XTarget[1].ID} && ${Navigation.Active}) /nav stop
	}
	/if (${Me.XTarget[1].ID}||${Me.Feigning}) /return
	/for i 1 to ${SpawnCount[npc]}
		/varset PullConditions ${Ini[MyIni,Pulling,PullConditions,1]}
		/if ((${PullConditions}) && (${NearestSpawn[${i}, npc].LineOfSight}||${PullingTotal}==1 && !${PullSkillRequiresLineOfSight1}||${PullingTotal}==2 && !${PullSkillRequiresLineOfSight2}) && ${NearestSpawn[${i}, npc noalert 1].Type.Equal[npc]} && ${Select[${NearestSpawn[${i}, npc noalert 1].ConColor},${PullConColor}]} && !${IgnoreList.Find[${NearestSpawn[${i}, npc noalert 1].CleanName}]}&& !${IgnoreAll.Find[${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].CleanName}]} && !${Me.XTarget[1].ID}) {
			/squelch /tar id ${NearestSpawn[${i}, npc noalert 1].ID}
			/nav id ${NearestSpawn[${i}, npc noalert 1].ID}

			/if (${UseMelee}||${UseArchery}) /call Attacking2
			/return
		}
	/next i
/return

Sub SeekLoad
	/declare SeekLoaded int outer 1
	/declare NextSpotPH string outer ${Me.Y} ${Me.X} ${Me.Z}
	/declare NextSpotInt int outer 1
/return

Sub Seek
	/if (!${Defined[SeekLoaded]}) /call SeekLoad
	/declare i int local
	/declare b int local
	/declare x int local
	/for i 500 to 3500 step 3000
		/if (${Me.XTarget[1].ID}) /squelch /tar id ${Me.XTarget[1].ID}
		/for x 1 to ${SpawnCount[npc radius ${i}]}
			/if (${SpawnCount[npc id ${distancemob}]}) {
				/squelch /target id ${distancemob}
				/if (!${Stick.Distance}&&${SpawnCount[npc id ${distancemob}]}) /moveto id ${distancemob} loose
				/varset distancecheck
				/varset distancemob 0
				/goto :move
			}
			/varset distancecheck ${i}
			/varset distancemob 0

			/if (${Target.ID} && ${Me.XTarget}) /call CheckTarget2
			/if (${NearestSpawn[${x}, npc  noalert 1].ID} &&  ${PullConditions} && ${NearestSpawn[${x}, npc  noalert 1].Type.NotEqual[corpse]}) {
				/if (${NearestSpawn[${x}, npc  noalert 1].Distance}<${distancecheck}) {
					/varset distancecheck ${NearestSpawn[${x}, npc  noalert 1].Distance}
					/varset distancemob ${NearestSpawn[${x}, npc  noalert 1].ID}
				}
			}
		/next x

		/if (${i}>3400 && !${Me.XTarget}) {
			/if (!${KeyPressTimer}) /call KeyPress
			/keypress forward hold
			/varset KeyPressTimer 3s
			
			:wait4
			/if (!${Melee.Combat} && ${Target.ID} && ${Target.Type.Equal[npc]} && ${Target.Distance}<40) /killthis
			/if (${Target.ID} && ${Me.XTarget}) /call CheckTarget2
			/if (${KeyPressTimer}) /goto :wait4
			/keypress back
			/keypress home
			/moveto loc ${NextSpotPH} loose
			/if (!${Melee.Combat} && ${Target.ID} && ${Target.Type.Equal[npc]} && ${Target.Distance}<40) /killthis
			/if (${Target.ID} && ${Me.XTarget}) /call CheckTarget2
			|## these need declared.
			|/varcalc NextSpotInt ${NextSpotInt}+1
			|/if (${NextSpotInt}>${NextSpotTotal}) /varset NextSpotInt 1
			|/varset NextSpotPH ${NextSpot${NextSpotInt}}
		}
	
		/if (!${Melee.Combat} && ${Target.ID} && ${Target.Type.Equal[npc]} && ${Target.Distance}<40) /killthis
		/if (${Target.ID} && ${Me.XTarget}) /call CheckTarget2
	/next i
	
	:move
/return

Sub KeyPress
	/if (!${Defined[KeyPressTimer]}) /declare KeyPressTimer timer outer 1m
	/varset KeyPressTimer 1m
	/keypress page_down hold
	/delay 1s
	/keypress home
	/if (${Target.ID} && ${Me.XTarget}) /call CheckTarget2
/return

Sub Seeker
	/declare i int local
	/declare x int local

	|${Spawn[${NearestSpawn[${x}, npc noalert 1 ${Target${b}}]}].FeetWet} &&  ${Spawn[${NearestSpawn[${x}, npc noalert 1 ${Target${b}}]}].LineOfSight}

	/for i ${Math.Calc[${PullRadius}/5].Int} to ${PullRadius} step ${Math.Calc[${PullRadius}/5].Int}
		/varset PullConditions ${Ini[MyIni,Pulling,PullConditions,1]}
		/for x 1 to ${SpawnCount[npc radius ${i}]}
			/if (${NearestSpawn[${x}, npc  noalert 1].ID} &&  ${PullConditions} && ${NearestSpawn[${x}, npc  noalert 1].Type.NotEqual[corpse]} && !${IgnoreList.Find[${NearestSpawn[${x}, npc  noalert 1].CleanName}]} && !${IgnoreAll.Find[${Spawn[loc ${XLOC${fm}} ${YLOC${fm}} npc noalert 1 radius ${If[${fm},${MQ2NavPullRadius},100]} zradius ${MQ2NavPullZRadius}].CleanName}]} && ${Math.Abs[${Math.Calc[${NearestSpawn[${x}, npc  noalert 1].Z}-${Me.Z}]}]}<${PullRadiusZ} && ${Spawn[${NearestSpawn[${x}, npc noalert 1]}].LineOfSight}) {
				/call Pull ${NearestSpawn[${x}, npc  noalert 1].ID}
				/return
			}
		/next x
	/next i
/return


|#####> Mobcamp start <#####

#event AddCamp "#*#addcamp #1#"
#event ListCamp "#*#listcamp#*#"
#event StopAdd "#*#stopadd#*#"
#event StartCamp "#*#startcamp #1#"

Sub MobCampLoad
	/if (!${Defined[MobCampLoaded]}) /declare MobCampLoaded bool outer FALSE
	/if (${MobCampLoaded}) /return
	/varset MobCampLoaded TRUE
	/declare AddMobs bool outer FALSE
	/declare CampList string outer ${Ini[MobIni,${Zone.ShortName},CampList]}
	/declare CampName string outer
	/declare MyCamp string outer
	/declare MyCampList string outer |
	/if (${CampList.Equal[NULL]}) {
		/mmoini "MobIni" "${Zone.ShortName}" "CampList" "|"
		/varset CampList |
	}
	/squelch /alias /addcamp /echo addcamp
	/squelch /alias /stopcamp /echo stopadd
	/squelch /alias /listcamp /echo listcamp
	/squelch /alias /startcamp /echo startcamp
/return

Sub Event_StopAdd
	/if (!${Defined[MobCampLoaded]}) /call MobCampLoad
	/varset AddMobs FALSE
/return

Sub Event_StartCamp(string line, string cn)
	/if (!${Defined[MobCampLoaded]}) /call MobCampLoad
	/varset MyCamp ${Zone.ShortName}_${cn}
	/echo ${MyCamp}
	/call MobCampMake
/return

Sub Event_AddCamp(string line, string newcamp)
	/if (!${Defined[MobCampLoaded]}) /call MobCampLoad
	/varset CampName ${newcamp}
	/if (!${CampList.Find[${newcamp}]}) {
		/mmoini "MobIni" "${Zone.ShortName}" "CampList" "${CampList}${newcamp}|"
		/varset CampList ${CampList}${newcamp}|
		|/if (${camptype.Find[adv]}) /goto :campdone
		/varset AddMobs TRUE
	}
	
	:campdone
	/echo CampList=${CampList}
	/call AddMob
/return

Sub Event_ListCamp
	/if (!${Defined[MobCampLoaded]}) /call MobCampLoad
	/echo ${CampList}
/return

Sub MobCampMake
	/if (!${Defined[MobCampLoaded]}) /call MobCampLoad
	/if (!${Defined[${MyCamp}Total]}) /declare ${MyCamp}Total int outer ${Ini[MobIni,${MyCamp},${MyCamp}Total]}
	/varset ${MyCamp}Total ${Ini[MobIni,${MyCamp},${MyCamp}Total]}
	/declare i int local
	/if (!${Defined[XLOC0]}) /declare XLOC0 int outer
	/if (!${Defined[YLOC0]}) /declare YLOC0 int outer
	/if (!${Defined[ZLOC0]}) /declare ZLOC0 int outer
	/varset XLOC0 ${Me.X}
	/varset YLOC0 ${Me.Y}
	/varset ZLOC0 ${Me.Z}
	/for i 1 to ${${MyCamp}Total}
		/if (!${Defined[XLOC${i}]}) /declare XLOC${i} int outer 
		/if (!${Defined[YLOC${i}]}) /declare YLOC${i} int outer 
		/if (!${Defined[ZLOC${i}]}) /declare ZLOC${i} int outer 
		/varset XLOC${i} ${Ini[MobIni,${MyCamp},XLOC${i}]}
		/varset YLOC${i} ${Ini[MobIni,${MyCamp},YLOC${i}]}
		/varset ZLOC${i} ${Ini[MobIni,${MyCamp},ZLOC${i}]}
	/next i
	/echo Camp: ${MyCamp} - ${${MyCamp}Total} Total spawn points added
/return

Sub AddMob
	/if (!${Defined[MobCampLoaded]}) /call MobCampLoad
	/varset MyCamp ${Zone.ShortName}_${CampName}
  	/if (!${Defined[${MyCamp}Total]}) /mmoini "MobIni" "${MyCamp}" "${MyCamp}Total" "0"
  	/if (!${Defined[${MyCamp}Total]}) /declare ${MyCamp}Total int outer ${Ini[MobIni,${MyCamp},${MyCamp}Total]}
 	
	:makecamp
  	/if (${MyCampList.Find[${Target.ID}]}||!${Target.ID}) /goto :next
  	/varcalc ${MyCamp}Total ${${MyCamp}Total}+1
  	/mmoini "MobIni" "${MyCamp}" "${MyCamp}Total" "${${MyCamp}Total}"
  	/mmoini "MobIni" "${MyCamp}" "XLOC${${MyCamp}Total}" "${Target.X}"
  	/mmoini "MobIni" "${MyCamp}" "YLOC${${MyCamp}Total}" "${Target.Y}"
  	/mmoini "MobIni" "${MyCamp}" "ZLOC${${MyCamp}Total}" "${Target.Z}" 
  	/varset MyCampList ${MyCampList}${Target.ID}|
  	/echo Point ${${MyCamp}Total} added successfully in MobIni
  	
	:next
	/doevents
	/if (${AddMobs}) /goto :makecamp
/return

|########################>  Spell Loading section <##############################
Sub SpellLoad2(SubName,SubOptions)
	/if (!${Defined[${SubName}Conditions]}) /declare ${SubName}Conditions string outer ${Ini[MyIni,${SubName},${SubName}Conditions,123456]}
	/if (${${SubName}Conditions.Equal[123456]}) /mmoini "MyIni" "${SubName}" "${SubName}Conditions" "TRUE"
	|--------------------------------------------------------------------  1          2       3      4          5      6            7             8          9     10       11        12         13        14       15     16      17       18      19       20        21     22    23     24      25   26      27            28         29      30        31       
	/if (!${Defined[SpellLoad2Cats]}) /declare SpellLoad2Cats string outer Total|TotalIfNamed|Use|SpellName|SpellIcon|SpellGem|UseAtMobPctHP|StopAtMobPctHP|Recast|Value|UseAtMyHP|UseAtMyMana|MaxTries|MaxNPCLevel|Name|ForAggro|NamedOnly|After|IfNearby|IfNearbyAmt|UseAt|StopAt|AvgHP|Classes|Alias|IconAlt|ActNumber|DuringCombat|Trusted|Conditions|AtAggroPct|
	|--------------------------------------------------------------------  1   2   3      4      5      6    7   8   9     10  11  12  13  14    15    16   17  18   19     20     21 22  23   24     25     26     27  28    29     30   31  
	/if (!${Defined[SpellLoad2Vars]}) /declare SpellLoad2Vars string outer int|int|bool|string|string|string|int|int|timer|int|int|int|int|int|string|bool|bool|int|string|string|int|int|int|string|string|string|int|bool|string|string|int|
	/declare i int local
	/declare temptotal int local
	/declare temptotal1 int local
	/declare temptotal2 int local
	/varset temptotal1 ${Ini[MyIni,${SubName},${SubName}Total,0]}
	/varset temptotal2 ${Ini[MyIni,${SubName},${SubName}TotalIfNamed,0]}
	/varset temptotal ${temptotal1}
	/if (${temptotal2}>${temptotal1}) /varset temptotal ${temptotal2}
	/if (!${Defined[${SubName}Total]}) /declare ${SubName}Total int outer ${Ini[MyIni,${SubName},${SubName}Total,0]}
	/if (!${${SubName}Total} && ${SubName.NotEqual[GoM]} && ${OptionsCheck.Find[|${SubName}|]} && ${SubName.NotEqual[Buff]}) {
		/cechob \ay${SubName}Total=0 -- You wont use this section, consider removing section from [Settings] OptionsCheck=
		/mqlog ${Me.Class} -  ${SubName}Total=0 -- You wont use this section, consider removing section from [Settings] OptionsCheck=
		/return
	}
	/if (!${Defined[${SubName}TotalIfNamed]}) /declare ${SubName}TotalIfNamed int outer ${Ini[MyIni,${SubName},${SubName}TotalIfNamed,0]}
	/if (!${Defined[${SubName}Announce]}) /declare ${SubName}Announce bool outer ${Ini[MyIni,${SubName},${SubName}Announce,FALSE]}
	/if (!${Defined[ForceMem${SubName}]}) /declare ForceMem${SubName} bool outer ${Ini[MyIni,${SubName},ForceMem${SubName},FALSE]}
	/declare x int local
	/for x 1 to ${temptotal}
		/for i 1 to ${SubOptions.Count[|]}
			/varset spellload2 ${Ini[MyIni,${SubName},${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x},NULL]}
			/if (!${Defined[${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}]}) {
				/call Debug 3 "Declaring dynamic variable: /declare ${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x} ${SpellLoad2Vars.Arg[${SubOptions.Arg[${i},|]},|]} outer ${Ini[MyIni,${SubName},${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}]}"
				/declare ${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x} ${SpellLoad2Vars.Arg[${SubOptions.Arg[${i},|]},|]} outer ${Ini[MyIni,${SubName},${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}]}
			} 
			/if (${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].Equal[Conditions]}) /varset ${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x} ${Ini[MyIni,${SubName},${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x},123456]}
			/if (!${Defined[${SubName}Use${x}]}) /declare ${SubName}Use${x} bool outer FALSE
			/if (!${${SubName}Use${x}}||${SubName.Equal[GoM]}||${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].Equal[Conditions]}) /break
			/if (${spellload2.Equal[NULL]} && ${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].NotEqual[Conditions]}) {
				/mmoini "MyIni" "${SubName}" "${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}"
				/if (!${Defined[AuraSpellName${x}]}) /declare AuraSpellName${x} string outer
				/if (${SubName.Equal[Aura]} && ${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].Equal[SpellIcon]} && (!${AuraSpellName${x}.Find[ the ]}||${Select[${Me.Class.ShortName},NEC,MAG]})) /continue
				/if (!${ErrorFound}) {
					/cechob \arError(s) found in MyIni
					/varset ErrorFound TRUE
				}
				/cechob \ar[${SubName}] ${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}= is missing or not filled out correctly
				/if (${Ini[MyIni,${SubName},${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}]} == NULL) {
					/ini "MyIni" "${SubName}" "${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}" "----"
				/cechob \ag[${SubName}] ${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}= was added to the INI. 
				}
				/mqlog ${Me.Class} -  [${SubName}] ${SubName}${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|]}${x}= is missing or not filled out correctly
			}
			/if (${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].Equal[SpellName]} && ${spellload2.NotEqual[NULL]}) {
				/varset spellload2 ${Ini[MyIni,${SubName},${SubName}SpellGem${x}]}
				/if (((${Defined[${SubName}SpellName${x}]}&&${Me.Book[${${SubName}SpellName${x}} Rk. III]}) || (${Defined[${SubName}SpellName${x}]}&&${Me.CombatAbility[${${SubName}SpellName${x}} Rk. III]})) && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk. III
				/if (((${Defined[${SubName}SpellName${x}]}&&${Me.Book[${${SubName}SpellName${x}} Rk. II]})  || (${Defined[${SubName}SpellName${x}]}&&${Me.CombatAbility[${${SubName}SpellName${x}} Rk. II]}))  && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk. II
				/if (((${Defined[${SubName}SpellName${x}]}&&${Me.Book[${${SubName}SpellName${x}} Rk.III]})  || (${Defined[${SubName}SpellName${x}]}&&${Me.CombatAbility[${${SubName}SpellName${x}} Rk.III]}))  && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk.III
				/if (((${Defined[${SubName}SpellName${x}]}&&${Me.Book[${${SubName}SpellName${x}} Rk.II]})   || (${Defined[${SubName}SpellName${x}]}&&${Me.CombatAbility[${${SubName}SpellName${x}} Rk.II]}))   && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk.II
				/if (((${Defined[${SubName}SpellName${x}]}&&${Me.Book[${${SubName}SpellName${x}} Rk III]})  || (${Defined[${SubName}SpellName${x}]}&&${Me.CombatAbility[${${SubName}SpellName${x}} Rk III]}))  && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk III
				/if (((${Defined[${SubName}SpellName${x}]}&&${Me.Book[${${SubName}SpellName${x}} Rk II]})   || (${Defined[${SubName}SpellName${x}]}&&${Me.CombatAbility[${${SubName}SpellName${x}} Rk II]}))   && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk II
				|/if (((${Defined[${SubName}SpellName${x}]}&&${Defined[${SubName}Name${x}]}) && (${Me.Book[${${SubName}SpellName${x}} Rk. III]} || ${Me.CombatAbility[${${SubName}Name${x}} Rk. III]}) && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk. III
				|/if (((${Defined[${SubName}SpellName${x}]}&&${Defined[${SubName}Name${x}]}) && (${Me.Book[${${SubName}SpellName${x}} Rk. II]}  || ${Me.CombatAbility[${${SubName}Name${x}} Rk. II]})  && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} ${${SubName}SpellName${x}} Rk. II
				|/if (((${Defined[${SubName}SpellName${x}]}&&${Defined[${SubName}Name${x}]}) && (${Me.Book[${${SubName}SpellName${x}} Rk. III ]} || ${Me.CombatAbility[${${SubName}Name${x}} Rk. III ]}) && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} "${${SubName}SpellName${x}} Rk. III "
				|/if (((${Defined[${SubName}SpellName${x}]}&&${Defined[${SubName}Name${x}]}) && (${Me.Book[${${SubName}SpellName${x}} Rk. II ]} || ${Me.CombatAbility[${${SubName}Name${x}} Rk. II ]})  && ${spellload2.NotEqual[alt]}) /varset ${SubName}SpellName${x} "${${SubName}SpellName${x}} Rk. II "
				/if (!${Me.Book[${${SubName}SpellName${x}}]} && !${Me.AltAbility[${${SubName}SpellName${x}}].Name.Length} && !${Me.CombatAbility[${${SubName}SpellName${x}}]} && !${FindItem[${${SubName}SpellName${x}}].ItemSlot}) {
					/if (!${ErrorFound}) {
						/cechob \arError(s) found in MyIni
						/varset ErrorFound TRUE
					}
					/cechob \ar [${SubName}] ${SubName}SpellName${x}=${${SubName}SpellName${x}} -- You don't have this ability/item
					/mqlog ${Me.Class} -  [${SubName}] ${SubName}SpellName${x}=${${SubName}SpellName${x}} -- You dont have this ability/item
				}
			}
	
			/if (${Defined[${SubName}SpellGem${x}]} && ${Defined[${SubName}SpellName${x}]} && ${Defined[${SubName}Name${x}]} && ${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].Equal[SpellGem]} && ${spellload2.NotEqual[NULL]}) {
				/if (${${SubName}SpellGem${x}.Find[gem]} && !${Me.Book[${${SubName}SpellName${x}}]}||${${SubName}SpellGem${x}.Find[alt]} && !${Me.AltAbility[${${SubName}SpellName${x}}]}||${${SubName}SpellGem${x}.Find[disc]} && !${Me.CombatAbility[${${SubName}SpellName${x}}]} && !${Me.CombatAbility[${${SubName}Name${x}}]}||${${SubName}SpellGem${x}.Find[item]} && !${FindItem[${${SubName}SpellName${x}}].ItemSlot}||${${SubName}SpellGem${x}.Length}<3) {
					/if (!${ErrorFound}) {
						/cechob \arError(s) found in MyIni
						/varset ErrorFound TRUE
					}
					/cechob \ap[${SubName}] ${SubName}SpellGem${x}=${${SubName}SpellGem${x}} -- This gem is wrong format for ${SubName}SpellName${x}=${${SubName}SpellName${x}}
					/mqlog ${Me.Class} -  [${SubName}] ${SubName}SpellGem${x}=${${SubName}SpellGem${x}} -- This gem is wrong format for ${SubName}SpellName${x}=${${SubName}SpellName${x}}
				}
			}
			
			/if (${Defined[${SubName}SpellGem${x}]} && ${Defined[${SubName}SpellIcon${x}]}) {
				/if (${SpellLoad2Cats.Arg[${SubOptions.Arg[${i},|]},|].Equal[SpellIcon]} && ${spellload2.NotEqual[NULL]} && (!${Spell[${${SubName}SpellIcon${x}}].ID} && !${Spell[${${SubName}SpellIcon${x}} ].ID}||${Spell[${${SubName}SpellIcon${x}}].Duration}>0 && ${Spell[${${SubName}SpellIcon${x}}].Duration}<2)) {
					/if (!${ErrorFound}) {
						/cechob \arError(s) found in MyIni
						/varset ErrorFound TRUE
					}
					/cechob \at[${SubName}] ${SubName}SpellIcon${x}=${${SubName}SpellIcon${x}} -- This spell doesnt exist or you are using the wrong name
					/mqlog ${Me.Class} -  [${SubName}] ${SubName}SpellIcon${x}=${${SubName}SpellIcon${x}} -- This spell doesnt exist or you are using the wrong name
				}
			}
		/next i
	/next x
/return

Sub SpellLoad(string slType, int slIniLoad, string slIniTraits, string slIniValue)
	/declare i int local
	/declare a int local
	/declare b int local
	/declare c int local
	/declare spelllevelcheck int local
	/if (${Me.Level}>=64) {
		/varset spelllevelcheck ${Math.Calc[${Me.Level}-4]}
	} else /if (${Me.Level}<64) {
		/varset spelllevelcheck ${Math.Calc[${Me.Level}-9]}
	} else /if (${Me.Level}<10) {
		/varset spelllevelcheck 1
	}
	/declare bookcheck string local
	/declare booklist string local 
	/declare spellgemdetect string local
	/declare spellph string local
	/declare bookspot int local 1

	/if (!${Defined[bookmax]} && ${NeedLoad}) {
		/declare bookstart int outer
		/for b 1 to 720
			/if (${Spell[${Me.Book[${b}]}].ID} && ${Range.Between[${spelllevelcheck},${Me.Level}:${Me.Book[${b}].Level}]}) {
				/varset bookstart ${b}
				/goto :bookmax
			}
		/next b
		/varset bookspot ${bookstart}

		:bookmax
		/if (!${Defined[bookmax]}) {
			/declare bookmax int outer
		}
		
		/for b 1 to 720
			/if (${Spell[${Me.Book[${b}]}].ID} && ${Range.Between[${spelllevelcheck},${Me.Level}:${Me.Book[${b}].Level}]}) /varset bookmax ${b}
		/next b
	}
	/if (!${Defined[SpellLoadPH]}) /declare SpellLoadPH string outer
	|--------------------------------------------------------------------  1          2       3      4          5      6            7             8          9     10       11        12         13        14       15     16      17       18      19       20        21     22    23     24      25   26      27            28         29      30        31
	/if (!${Defined[SpellLoadCats]}) /declare SpellLoadCats string outer |Total|TotalIfNamed|Use|SpellName|SpellIcon|SpellGem|UseAtMobPctHP|StopAtMobPctHP|Recast|Value|UseAtMyHP|UseAtMyMana|MaxTries|MaxNPCLevel|Name|ForAggro|NamedOnly|After|IfNearby|IfNearbyAmt|UseAt|StopAt|AvgHP|Classes|Alias|IconAlt|ActNumber|DuringCombat|Trusted|Conditions|AtAggroPct|
	|--------------------------------------------------------------------  1   2   3      4      5      6    7   8   9     10  11  12  13  14    15    16   17  18   19     20     21 22  23   24     25     26     27  28    29     30   31  
	/if (!${Defined[SpellLoadVars]}) /declare SpellLoadVars string outer |int|int|bool|string|string|string|int|int|timer|int|int|int|int|int|string|bool|bool|int|string|string|int|int|int|string|string|string|int|bool|string|string|int|
	/if (!${Defined[ForceMemList]}) /declare ForceMemList string outer |Nuke|Dot|Lifetap|Debuff|Jolt|Snare|Stun|FightBuff|Mez|Rez|
	/if (${slIniLoad}) {
		/varset SpellLoadPH ${Ini[MyIni,${slType},${slType}${SpellLoadCats.Arg[1,|]},123456]}
		/if (${SpellLoadPH.NotEqual[123456]}) /goto :skipini
		/cechob \ag Loading ini for ${CurrentSub} section.
		/if (${slIniTraits.Find[|1|]}) /mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[1,|]}" "${slIniValue.Arg[1,|]}"
		/if (${slIniTraits.Find[|2|]}) /mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[2,|]}" "${slIniValue.Arg[2,|]}"
		/if (${ForceMemList.Find[|${slType}|]}) /mmoini "MyIni" "${slType}" "ForceMem${slType}" "FALSE"
		/mmoini "MyIni" "${slType}" "${slType}Announce" "FALSE"
		|** Added to fix the issue with /mac bot40 load where ${CurrentSub}Check was undefined. 10/26/17**|
		/if (!${Defined[${CurrentSub}Check]}) {
			/if (${OptionsCheck.Find[|${CurrentSub}|]}) {
				/declare ${CurrentSub}Check bool outer TRUE
			} else {
				/declare ${CurrentSub}Check bool outer FALSE
			}
		}
		/for i 1 to ${slIniLoad}
			/for a 1 to ${Math.Calc[${slIniTraits.Count[|]}-1]}
				|/echo Finding ${CurrentSub}${i} information. 
				/if (${Select[${slIniTraits.Arg[${a},|]},1,2]}) /goto :nexttrait
				/if (${slType.Equal[Buff]}) /mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[${slIniTraits.Arg[${a},|]},|]}${i}"
				/if (${slIniValue.Arg[${a},|].NotEqual[PH]} && !${spellgemdetect.Find[gem]}) /mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[${slIniTraits.Arg[${a},|]},|]}${i}" "${slIniValue.Arg[${a},|]}"
				/if (!${Defined[AA${CurrentSub}]}) /declare AA${CurrentSub} string inner
				/if (${slIniValue.Arg[${a},|].Equal[PH]} && (!${Select[${slIniTraits.Arg[${a},|]},5]}||!${Select[${CurrentSub},FightBuff,Buff,SelfBuff]}) && (!${Defined[${CurrentSub}SpellGem${i}]} && !${Defined[${AA${CurrentSub}.Arg[${c},|].Replace[ ,]}]}||!${Select[${slIniTraits.Arg[${a},|]},6]} && !${Defined[${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID}]})) /mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[${slIniTraits.Arg[${a},|]},|]}${i}"
				/if ((${Select[${slIniTraits.Arg[${a},|]},4]}||${Select[${slIniTraits.Arg[${a},|]},15]} && ${CurrentSub.Equal[ClickyNuke]}) && ${Select[${CurrentSub},Rez,SelfBuff,Lifetap,Nuke,Dot,Snare,Stun,Mez,AEMez,PBAEMez,HealSingle,HealGroup,HealSelf,HealSplash,Jolt,Debuff,FightBuff,HealBalance,MainTankBuff,XHeal,Buff,FeignDeath,ClickyNuke,Aura,Fade,Root,Cure,SummonItem]}) {
					/for c 1 to ${AA${CurrentSub}.Count[|]}
						/if ((${Me.AltAbility[${AA${CurrentSub}.Arg[${c},|]}]} && !${Defined[${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID}]} && !${Defined[${CurrentSub}${AA${CurrentSub}.Arg[${c},|].Replace[ ,]}]} )||${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot} && !${Defined[${CurrentSub}${AA${CurrentSub}.Arg[${c},|].Replace[ ,]}]}||(${Me.Book[${AA${CurrentSub}.Arg[${c},|]}]} && !${Defined[${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID}]} && !${Defined[${CurrentSub}${AA${CurrentSub}.Arg[${c},|].Replace[ ,]}]})||${Me.CombatAbility[${AA${CurrentSub}.Arg[${c},|]}]} && !${Defined[${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID}]}) {
							/mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[${slIniTraits.Arg[${a},|]},|]}${i}" "${AA${CurrentSub}.Arg[${c},|]}"
							/if (${Select[${CurrentSub},SelfBuff,Buff,Aura,FightBuff]}) /mmoini "MyIni" "${slType}" "${slType}SpellIcon${i}" "${AA${CurrentSub}.Arg[${c},|]}"
							/mmoini "MyIni" "${slType}" "${slType}Conditions${i}"
							/if (${Me.Book[${AA${CurrentSub}.Arg[${c},|]}]} && !${Me.Gem[${AA${CurrentSub}.Arg[${c},|]}]} && !${Me.AltAbility[${AA${CurrentSub}.Arg[${c},|]}]}) /mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "gem${MyGemTotal}"
							/if (${Me.Book[${AA${CurrentSub}.Arg[${c},|]}]} && ${Me.Gem[${AA${CurrentSub}.Arg[${c},|]}]} && !${Me.AltAbility[${AA${CurrentSub}.Arg[${c},|]}]}) /mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "gem${Me.Gem[${AA${CurrentSub}.Arg[${c},|]}]}"
							/if (${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot})  /mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "item"
							/if (!${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot} && ${Me.AltAbility[${AA${CurrentSub}.Arg[${c},|]}]})  /mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "alt"
							/if (${Select[${CurrentSub},Mez,AEMez,PBAEMez]}) /mmoini "MyIni" "${slType}" "${slType}MaxNPCLevel${i}" ${Spell[${Me.AltAbility[${AA${CurrentSub}.Arg[${c},|]}].Spell.ID}].Slot[1].Arg[2,/].Replace[),]}
							/if (!${Defined[${slType}SpellGem${i}]}) /declare ${slType}SpellGem${i} string outer 
							/varset ${slType}SpellGem${i} ${Ini[MyIni,${slType},${slType}SpellGem${i}]}
							/if (${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot}) /declare ${CurrentSub}${AA${CurrentSub}.Arg[${c},|].Replace[ ,]} string outer item
							/if (!${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot} && ${Me.AltAbility[${AA${CurrentSub}.Arg[${c},|]}]}) /declare ${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID} string outer alt
							/if (!${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot} && ${Me.Book[${AA${CurrentSub}.Arg[${c},|]}]} && !${Me.Gem[${AA${CurrentSub}.Arg[${c},|]}]} && !${Defined[${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID}]}) /declare ${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID} string outer gem${MyGemTotal}
							/if (!${FindItem[${AA${CurrentSub}.Arg[${c},|]}].ItemSlot} && ${Me.Book[${AA${CurrentSub}.Arg[${c},|]}]} && ${Me.Gem[${AA${CurrentSub}.Arg[${c},|]}]}) {
								/if (!${Defined[${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID}]}) /declare ${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID} string outer gem${Me.Gem[${AA${CurrentSub}.Arg[${c},|]}]}
							}
							/if (${CurrentSub.Equal[aura]}) /mmoini "MyIni" "${slType}" "${slType}Name${i}"
							/if (${Me.CombatAbility[${AA${CurrentSub}.Arg[${c},|]}]})  {
								/mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "disc"
								/declare ${CurrentSub}${Spell[${AA${CurrentSub}.Arg[${c},|]}].ID} string outer disc
							}
							
							/goto :nexttrait
						}	
					/next c
					/for b ${bookspot} to ${bookmax}
						/varset bookcheck ${Me.Book[${b}]}
						/if (${bookcheck.NotEqual[NULL]} && ${Range.Between[${spelllevelcheck},${Me.Level}:${Spell[${bookcheck}].Level}]} && ${${CurrentSub}Check} && !${booklist.Find[${b}]} && ${bookcheck.NotEqual[Invigor]}) {
							/if (${Spell[${bookcheck}].Name.Find[Rk. II]}) {
								/mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[${slIniTraits.Arg[${a},|]},|]}${i}" "${Spell[${Me.Book[${b}]}].Name.Left[-7]}"
								/if (${Select[${CurrentSub},FightBuff,SelfBuff,Buff]}) /mmoini "MyIni" "${slType}" "${slType}SpellIcon${i}" "${Me.Book[${b}]}"
								/varset booklist ${booklist}${b}|
								/if (${Me.Gem[${Me.Book[${b}]}]}) {
									/mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "gem${Me.Gem[${Me.Book[${b}]}]}"
									/if (!${Defined[${slType}SpellGem${i}]}) /declare ${slType}SpellGem${i} string outer 
									/varset ${slType}SpellGem${i} gem${Me.Gem[${Me.Book[${b}]}]}
									/varset bookspot ${b}
								} 
								/if (!${Me.Gem[${Me.Book[${b}]}]}) {
									/mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "gem${MyGemTotal}"
									/if (!${Defined[${slType}SpellGem${i}]}) /declare ${slType}SpellGem${i} string outer 
									/varset ${slType}SpellGem${i} gem${MyGemTotal}
								}
								/goto :nextspell
							}
							/if (!${Spell[${bookcheck}].Name.Find[Rk. II]}) {
								/mmoini "MyIni" "${slType}" "${slType}${SpellLoadCats.Arg[${slIniTraits.Arg[${a},|]},|]}${i}" "${Me.Book[${b}]}"
								/if (${Select[${CurrentSub},FightBuff,SelfBuff,Buff]}) /mmoini "MyIni" "${slType}" "${slType}SpellIcon${i}" "${Me.Book[${b}]}"
								/varset booklist ${booklist}${b}|
								/if (${Me.Gem[${Me.Book[${b}]}]}) {
									/mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "gem${Me.Gem[${Me.Book[${b}]}]}"
									/if (!${Defined[${slType}SpellGem${i}]}) /declare ${slType}SpellGem${i} string outer 
									/varset ${slType}SpellGem${i} gem${Me.Gem[${Me.Book[${b}]}]}
									/varset bookspot ${b}
								}
								/if (!${Me.Gem[${Me.Book[${b}]}]}) {
									/mmoini "MyIni" "${slType}" "${slType}SpellGem${i}" "gem${MyGemTotal}"
									/if (!${Defined[${slType}SpellGem${i}]}) /declare ${slType}SpellGem${i} string outer 
									/varset ${slType}SpellGem${i} gem${MyGemTotal}
								}
								/break
							}
						}
					/next b
					:nextSpell
				}
			:nexttrait
			|/if (${Select[${CurrentSub},Mez,AEMez,PBAEMez]} && ${Spell[${Me.Book[${b}]}].Slot[1].Arg[2,/].Replace[),]}) /mmoini "MyIni" "${slType}" "${slType}MaxNPCLevel${i}" "${Spell[${Me.Book[${b}]}].Slot[1].Arg[2,/].Replace[),]}"
			|/if (${Select[${CurrentSub},Mez,AEMez,PBAEMez]} && ${Spell[${Me.Book[${b}]} Rk. II].Slot[1].Arg[2,/].Replace[),]}) /mmoini "MyIni" "${slType}" "${slType}MaxNPCLevel${i}" "${Spell[${Me.Book[${b}]} Rk. II].Slot[1].Arg[2,/].Replace[),]}"
			/next a
		/next i
	}
	:skipini
	/if (!${slIniLoad}) {
		/if (!${Defined[${slType}Total]}) /declare ${slType}Total int outer ${Ini[MyIni,${slType},${slType}Total,0]}
		/if (!${Defined[${slType}TotalIfNamed]}) /declare ${slType}TotalIfNamed int outer ${Ini[MyIni,${slType},${slType}TotalIfNamed,0]}
		/if (!${Defined[${slType}Announce]}) /declare ${slType}Announce bool outer ${Ini[MyIni,${slType},${slType}Announce,FALSE]}
		/if (!${Defined[ForceMem${slType}]} && ${ForceMemList.Find[|${slType}|]}) /declare ForceMem${slType} bool outer ${Ini[MyIni,${slType},ForceMem${slType},FALSE]}
		/for a 1 to ${${slType}Total}
			/for i 1 to ${Math.Calc[${SpellLoadCats.Count[|]}-1]}
				/if (${SpellLoadVars.Arg[${i},|].NotEqual[bool]}) /varset SpellLoadPH ${Ini[MyIni,${slType},${slType}${SpellLoadCats.Arg[${i},|]}${a},123456]}
				/if (${SpellLoadVars.Arg[${i},|].Equal[bool]}) /varset SpellLoadPH ${Ini[MyIni,${slType},${slType}${SpellLoadCats.Arg[${i},|]}${a},FALSE]}
				|/if (${i}==30) /noparse /varset SpellLoadPH ${Ini[MyIni,${slType},${slType}${SpellLoadCats.Arg[${i},|]}${a},1]}
				/if (!${Defined[${slType}${SpellLoadCats.Arg[${i},|]}${a}]}) /declare ${slType}${SpellLoadCats.Arg[${i},|]}${a} ${SpellLoadVars.Arg[${i},|]} outer ${Ini[MyIni,${slType},${slType}${SpellLoadCats.Arg[${i},|]}${a},123456]}
				/if (${Select[${slType},Buff,SelfBuff]} && (${SpellLoadCats.Arg[${i},|].Equal[SpellIcon]}||${SpellLoadCats.Arg[${i},|].Equal[IconAlt]}) && !${Defined[${slType}Orig${SpellLoadCats.Arg[${i},|]}${a}]}) /declare ${slType}Orig${SpellLoadCats.Arg[${i},|]}${a} string outer ${${slType}SpellName${a}}
				/if ((${Me.Book[${${slType}SpellName${a}} Rk. III]}||${Me.CombatAbility[${${slType}SpellName${a}} Rk. III]}) && ${${slType}SpellGem${a}.NotEqual[alt]}) /varset ${slType}SpellName${a} ${${slType}SpellName${a}} Rk. III
				/if ((${Me.Book[${${slType}SpellName${a}} Rk. II]}||${Me.CombatAbility[${${slType}SpellName${a}} Rk. II]}) && ${${slType}SpellGem${a}.NotEqual[alt]}) /varset ${slType}SpellName${a} ${${slType}SpellName${a}} Rk. II
				/if ((${Me.Book[${${slType}SpellName${a}} Rk.III]}||${Me.CombatAbility[${${slType}SpellName${a}} Rk.III]}) && ${${slType}SpellGem${a}.NotEqual[alt]}) /varset ${slType}SpellName${a} ${${slType}SpellName${a}} Rk.III
				/if ((${Me.Book[${${slType}SpellName${a}} Rk.II]}||${Me.CombatAbility[${${slType}SpellName${a}} Rk.II]}) && ${${slType}SpellGem${a}.NotEqual[alt]}) /varset ${slType}SpellName${a} ${${slType}SpellName${a}} Rk.II
				/if ((${Me.Book[${${slType}SpellName${a}} Rk III]}||${Me.CombatAbility[${${slType}SpellName${a}} Rk III]}) && ${${slType}SpellGem${a}.NotEqual[alt]}) /varset ${slType}SpellName${a} ${${slType}SpellName${a}} Rk III
				/if ((${Me.Book[${${slType}SpellName${a}} Rk II]}||${Me.CombatAbility[${${slType}SpellName${a}} Rk II]}) && ${${slType}SpellGem${a}.NotEqual[alt]}) /varset ${slType}SpellName${a} ${${slType}SpellName${a}} Rk II
				/varset SpellLoadPH ${${slType}${SpellLoadCats.Arg[${i},|]}${a}}
				/if (${SpellLoadPH.Equal[123456]} && ${i}!=30) /deletevar ${slType}${SpellLoadCats.Arg[${i},|]}${a}
			/next i
		/next a
	}
/return

|##########################> Loot Section <####################################

#Event CantLoot       	"#*#cannot loot this Lore Item#*#"
#Event CantLoot       	"#*#may not loot this corpse#*#"
#Event Sell             "#*#You receive#*# for the #1#(s)#*#"
#Event EditIniItem      "[MQ2] LootItem #1# #2#"
#Event SellStuff        "[MQ2] SellItems"
#Event DepositStuff     "[MQ2] DepositItems"
#Event Broke            "#*#you cannot afford#*#"
#Event Broke            "#*#you can't afford#*#"
#Event Forage           "Your forage mastery has enabled you to find something else!"
#Event Forage           "You have scrounged up #*#"
#Event LootCheck	"#*#LootID - #1#: #2#"
#Event Looted		"-- You have looted #1#.#*#"

Sub Event_LootCheck(line,int LootID,string lootitems)
	/declare i int local
	/for i 1 to ${Loot_${Me.CleanName}.Count[|]}
	/if (${lootitems.Find[${Loot_${Me.CleanName}.Arg[${i},|].Arg[1,-]}) /call LootCheck ${LootID} "${lootitems.Find[${Loot_${Me.CleanName}.Arg[${i},|]}"
	/next i
/return

Sub Event_Looted(line,string itemcheck)
	/if (!${Loot_${Me.CleanName}.Find[${itemcheck}]}) /return
	/declare i int local
	/for i 1 to ${Loot_${Me.CleanName}.Count[|]}
		/if (${itemcheck.Find[${Loot_${Me.CleanName}.Arg[${i},|].Arg[1,-]}]}) {
			/if (${Loot_${Me.CleanName}.Arg[${i},|].Arg[2,-].Equal[1]}) /varset Loot_${Me.CleanName} ${Loot_${Me.CleanName}.Replace[${Loot_${Me.CleanName}.Arg[${i},|]},]}
			/if (${Loot_${Me.CleanName}.Arg[${i},|].Arg[2,-].NotEqual[1]}) /varset Loot_${Me.CleanName} ${Loot_${Me.CleanName}.Replace[${Loot_${Me.CleanName}.Arg[${i},|]},${Loot_${Me.CleanName}.Arg[${i},|].Arg[1,-]}-${Math.Calc[${Loot_${Me.CleanName}.Arg[${i},|].Arg[2,-]}-1]}]}
		}
	/next i
/return

Sub LootCheck(int corpseid,itemtoloot)
	/declare i int local
	/moveto id ${corpseid}
	/squelch /tar id ${corpseid}
	/delay 5s ${Target.ID}==${corpseid}
	/delay 10s ${MoveTo.Stopped}
	
	:wait
	/delay 2s
	/if (!${Corpse.Open}) /goto :wait

	/loot
	/delay 1s
	/for i 1 to ${Corpse.Items}
	/if (${Corpse.Item[${i}].Name.Equal[${itemtoloot.Arg[1,-]}]}) /call LootItem ${i} Keep Right
	/doevents Looted
/return

Sub LootLoad
	/varset CurrentSub Loot
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	|**
	
	/if (!${Defined[LoadListVar]}) /declare LoadListVar string outer
	/if (!${Defined[LoadListVarType]}) /declare LoadListVar string outer
	/if (!${Defined[LoadListDefault]}) /declare LoadListVar string outer

	/declare DontLoot                         int                 outer
	/declare CorpseRotTimer                     timer               outer
	/declare LootVersion                      string              outer v2.25
	/if (!${Defined[AlertList]}) /declare AlertList int outer 9
	/if (!${Defined[AlertTimer${AlertList}]}) /declare AlertTimer${AlertList} timer outer
	/squelch /alert clear 25
	/declare i int local

	/varset LoadListVar Version|LootOnRaids|HideCorpseLooted|LootMobs|CorpseRadius|MobTooClose|ReportLoot|ReportOnlyGear|LootChannel|MinValue|LootTradeskills|LootDuringCombat|CorpseRotTime|OpenAllBags|AddNewSales|LootForage|LootIgnoreList|Loot_${Me.CleanName}|LootCollectibles|LootWhileInvis|
	/varset LoadListVarType string|bool|bool|bool|int|int|bool|bool|string|int|bool|bool|timer|bool|bool|bool|string|string|bool|bool|
	/varset LoadListDefault ${LootVersion}|FALSE|TRUE|TRUE|100|75|FALSE|FALSE|bc|0|TRUE|FALSE|29m|TRUE|TRUE|TRUE|"Ornamentation,Chorosene,Mamba,"|----|TRUE|TRUE|
	/for i 1 to ${LoadListVar.Count[|]}
		/call IniLoad "Loot.ini" "${LoadListVar.Arg[${i},|]}" "${LoadListVarType.Arg[${i},|]}" "Loot" "${LoadListDefault.Arg[${i},|]}"
	/next i
	/if (${HideCorpseLooted}) /hidecorpse looted

	/if (${Version.NotEqual[${LootVersion}]}) {
        /mmoini "Loot.ini" "Loot" "Version" "${LootVersion}"
	}
	**|
/return

| ****************  Loot Mobs Section ******************** |

Sub AlertRecheck(AlertList,alerttimer)
	/squelch /alert clear ${AlertList}
	/squelch /alert add ${AlertList} untargetable
	/squelch /alert add ${AlertList} campfire
	/squelch /alert add ${AlertList} aura
	/declare i int local
	/for i 1 to ${IgnoreList.Count[|]}
		/if (${IgnoreList.Arg[${i},|].NotEqual[NULL]}) /squelch /alert add ${AlertList} npc ${IgnoreList.Arg[${i},|]}
	/next i
	/for i 1 to ${IgnoreAll.Count[|]}
		/if (${IgnoreList.Arg[${i},|].NotEqual[NULL]}) /squelch /alert add ${AlertList} npc ${IgnoreList.Arg[${i},|]}
	/next i
	/if (!${Defined[AlertList${AlertList}]}) {
	/declare AlertList${AlertList} timer outer ${alerttimer}
	} else {
		/varset AlertTimer${AlertList} ${alerttimer}
	}
/return

Sub Event_CantLoot
   /varset DontLoot ${Target.ID}
/return

Sub LootMobs
	|**
	/if (!${LootLoaded}) /call LootLoad
	/if (!${LootOnRaids} && ${Raid.Members}||${Me.Invis} && !${LootWhileInvis}) /return
		/varset CurrentSub Loot

    /if (!${AlertTimer${AlertList}}) {
		/call AlertRecheck "${AlertList}" "${Ini[Loot.ini,Settings,CorpseRotTimer]}"
		/call AlertRecheck 25 "${Ini[Loot.ini,Settings,CorpseRotTimer]}"
	}
    /if (!${LootMobs} || ${SpawnCount[npc radius ${MobTooClose} zradius 30 noalert ${AlertList}]} || !${SpawnCount[corpse radius ${CorpseRadius} zradius 30 noalert 25]} || ${Me.Combat} || (${Cursor.NoDrop} && !${Me.FreeInventory}) || ${Me.CombatState.Equal[Combat]} && !${LootDuringCombat}) /return
    /declare i int local
    /declare CorpseList string local |
    /declare ZDist float local ${Math.Distance[${Target.Z}:${Me.Z}]}
    /for i 1 to ${SpawnCount[corpse radius ${CorpseRadius} zradius 50 noalert 25]}
        /varset CorpseList ${CorpseList}${NearestSpawn[${i},corpse radius ${CorpseRadius} noalert 25].ID}|
    /next i
    /declare DeadCount int local ${SpawnCount[corpse radius ${CorpseRadius} zradius 50 noalert 25]}
    | /if (${Me.Mount.ID}) /dismount
    /for i 1 to ${DeadCount}
        /if (${SpawnCount[npc radius ${MobTooClose} zradius 20]} && !${IgnoreList.Find[${NearestSpawn[1,npc]}]}) /return
        /if (${Spawn[${CorpseList.Arg[${i},|]}].Deity.ID} && ${Spawn[${CorpseList.Arg[${i},|]}].ID}) /squelch /alert add 25 id ${Spawn[${CorpseList.Arg[${i},|]}].Deity.ID}
        /if (${Spawn[${CorpseList.Arg[${i},|]}].ID} && ${Spawn[${CorpseList.Arg[${i},|]}].LineOfSight} && !${Spawn[${CorpseList.Arg[${i},|]}].Deity.ID}) {
            /if (${Target.ID}!=${Spawn[${CorpseList.Arg[${i},|]}].ID}) /target id ${Spawn[${CorpseList.Arg[${i},|]}].ID}
            /if (!${Me.Standing}) /stand
            /delay 2s ${Target.ID}==${Spawn[${CorpseList.Arg[${i},|]}].ID} && ${Me.Standing}
            /if (${Target.ID}!=${Spawn[${CorpseList.Arg[${i},|]}].ID}) /target id ${Spawn[${CorpseList.Arg[${i},|]}].ID}
            /if (${Spawn[${CorpseList.Arg[${i},|]}].Distance}>5) {
		/if (${AdvPath.Playing}) /play off
                /moveto mdist 8
                /moveto loc ${Spawn[${CorpseList.Arg[${i},|]}].Y} ${Spawn[${CorpseList.Arg[${i},|]}].X}
                /delay 250 ${MoveTo.Stopped}
                /call ZCheck ${ZDist} 5
                /if (${Target.ID}) /face
            }
            /delay 10s ${Spawn[${CorpseList.Arg[${i},|]}].Distance}<10
            /if (${Spawn[${CorpseList.Arg[${i},|]}].Distance}<10) /call LootCorpse
        }
    /next i
	**|
/return

Sub LootCorpse
	|**
	/declare b 		int 	local
	/declare i 		int	local
	/declare LootList	string	local
	/declare LootList2 string local
	/declare CurrentItem	string	local
	/call CheckCursor
	/loot
	/delay 3s ${Corpse.Open}
	/doevents CantLoot
	/if (${Target.ID}==${DontLoot} && ${Spawn[${DontLoot}].ID}) /squelch /alert add 25 id ${DontLoot}
	/delay 3s (${Corpse.Items} || ${Target.ID}==${DontLoot})
	/if (${Corpse.Open} && ${Corpse.Items}) {
		/declare loottotal int    local
		:lootlag
		/varset loottotal ${Corpse.Items}
		/delay 1s
		/if (${loottotal}!=${Corpse.Items}) /goto :lootlag
		/varset loottotal ${Corpse.Items}
		/for i 1 to ${loottotal}
			/for b 1 to ${LootIgnoreList.Count[,]} 
				/if (${Corpse.Item[${i}].Name.Find[${LootIgnoreList.Arg[${b},,]}]}) {
					/mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Ignore"
					/continue
				}
				/if (${Corpse.Item[${i}].Stackable} && ${Corpse.Item[${i}].Magic} && !${Corpse.Item[${i}].Collectible} && !${Corpse.Item[${i}].Tradeskills} && !${Corpse.Item[${i}].NoDrop} && !${Corpse.Item[${i}].Lore} && (${Corpse.Item[${i}].Name.Find[Glowing ]}||${Corpse.Item[${i}].Name.Find[Greater ]}||${Corpse.Item[${i}].Name.Find[Median ]}||${Corpse.Item[${i}].Name.Find[Lessor ]}||${Corpse.Item[${i}].Name.Find[Minor ]})) {
					/mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Keep"
					}
			/next b
			/varset CurrentItem ${If[${Corpse.Item[${i}].Name.Find[,]},${Corpse.Item[${i}].Name.Arg[1,,]}${Corpse.Item[${i}].Name.Arg[2,,]},${Corpse.Item[${i}].Name}]}     
			/if (${Corpse.Item[${i}].ID} && !${Select[${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"]},Collectible,Ignore,Keep,Destroy,Sell,Tradeskills]}) {
				/if (!${Select[${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"]},Collectible,Ignore,Keep,Destroy,Sell,Tradeskills]} && ${LootCollectibles} && ${Corpse.Item[${i}].Collectible}) /mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Collectible"
				/if (!${Select[${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"]},Collectible,Ignore,Keep,Destroy,Sell,Tradeskills]} && ${LootTradeskills} && ${Corpse.Item[${i}].Tradeskills} && (!${MinValue}||${Math.Calc[${Corpse.Item[${i}].Value}/1000]}<${MinValue})) /mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Tradeskills"
				/if (!${Select[${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"]},Collectible,Ignore,Keep,Destroy,Sell,Tradeskills]} && !${Corpse.Item[${i}].NoDrop}  && !${Corpse.Item[${i}].WornSlots} && !${Corpse.Item[${i}].Lore}  && ${Math.Calc[${Corpse.Item[${i}].Value}/1000]}>=${MinValue} && !${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Tradeskills]}) /mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Sell"
				/if (!${Select[${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"]},Collectible,Ignore,Keep,Destroy,Sell,Tradeskills]} && !${Corpse.Item[${i}].NoDrop} && (${Corpse.Item[${i}].Lore}||${Corpse.Item[${i}].WornSlots})) /mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Keep"
				/if (!${Select[${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"]},Collectible,Ignore,Keep,Destroy,Sell,Tradeskills]} && ${Corpse.Item[${i}].NoDrop}||${Math.Calc[${Corpse.Item[${i}].Value}/1000]}<${MinValue} && (!${LootTradeskills}||!${Corpse.Item[${i}].Tradeskills})) /mmoini "loot.ini" "${Corpse.Item[${i}].Name.Left[1]}" "${Corpse.Item[${i}]}" "Ignore"
			}   
			/if (!${ReportOnlyGear} && (${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].NotEqual[Destroy]} && !${Me.FreeInventory} && (!${FindItemCount[=${Corpse.Item[${i}].Name}]} )|| (${FindItemCount[=${Corpse.Item[${i}].Name}]} && ${Corpse.Item[${i}].Stackable} && !${Corpse.Item[${i}].FreeStack})) || (${Corpse.Item[${i}].Lore} && ${FindItem[${Corpse.Item[${i}]}].ID}) || ${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Ignore]}) /varset LootList ${LootList}${Corpse.Item[${i}]},
			/if (${ReportOnlyGear} && !${Corpse.Item[${i}].Name.Find[Consigned Bite ]} && (${Corpse.Item[${i}].NoDrop}||${Corpse.Item[${i}].Lore} && (${FindItemCount[=${Corpse.Item[${i}].Name}]}||${FindItemBank[${Corpse.Item[${i}]}].ID})) && ${Corpse.Item[${i}].WornSlots}) /varset LootList2 ${LootList2}${Corpse.Item[${i}]},
			/if ((${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Tradeskills]} && ${LootTradeskills}||${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Keep]} || ${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Sell]} || ${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Collectible]} && ${LootCollectibles}) && (!${Corpse.Item[${i}].Lore} || !${FindItem[${Corpse.Item[${i}]}].ID}) && (${Me.FreeInventory} || (${FindItemCount[=${Corpse.Item[${i}].Name}]} && ${Corpse.Item[${i}].Stackable} && ${Corpse.Item[${i}].FreeStack}))) /call LootItem ${i} Keep Right
			/if (${Ini[Loot.ini,"${Corpse.Item[${i}].Name.Left[1]}","${Corpse.Item[${i}]}"].Equal[Destroy]}) /call LootItem ${i} Destroy left


		:skipi
        /next i
        /if (${Corpse.Items}) {
            /if (!${ReportOnlyGear} && ${ReportLoot} && ${LootList.Length}) {
				/if (${LootChannel.NotEqual[bc]}) {
                	/keypress Enter
                	/keypress / chat
                	/call Type "${LootChannel}"
                	/keypress Space chat
                	/notify LootWND LW_BroadcastButton leftmouseup
                	/delay 5
                	|/call Type " left on corpse."
                	/keypress /
                	/keypress Enter chat
				}
				/if (${LootChannel.Equal[bc]}) {
				/bc LootID - ${Target.ID}: [+r+]${LootList}
				}
            }
	       /if (${ReportOnlyGear} && ${LootList2.Length}) {
				/if (${LootChannel.NotEqual[bc]}) {
                	/keypress Enter
                	/keypress / chat
                	/call Type "${LootChannel}"
                	/keypress Space chat
                	/notify LootWnd LW_BroadcastButton leftmouseup
                	/delay 5
                	|/call Type " left on corpse."
                	/keypress /
                	/keypress Enter chat
				}
				/if (${LootChannel.Equal[bc]}) {
					/bc LootID - ${Target.ID}: [+r+]${LootList}
				}
            	}
            /if (${Target.ID}) /squelch /alert add 25 id ${Target.ID}
            /varset CorpseRotTimer ${CorpseRotTime}
        }
    }
    :clickdoneffs
        /nomodkey /notify LootWnd LW_DoneButton leftmouseup
        /delay 5s !${Corpse.Open}
        /if (${Corpse.Open}) /goto :clickdoneffs
	**|
/return

Sub LootItem(int i,DoWhat,WhichButton)
    /declare CorpseItemID int local ${Corpse.Item[${i}].ID}
    /nomodkey /shift /itemnotify  ${Corpse.Item[${i}].InvSlot} ${WhichButton}mouseup
    /delay 5s ${Window[ConfirmationDialogBox].Open} || !${Corpse.Item[${i}].NoDrop}
    /if (${Window[ConfirmationDialogBox].Open}) /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
    /delay 5s ${Cursor.ID} || ${WhichButton.NotEqual[left]}
    /if (${DoWhat.Equal[Destroy]} && ${Cursor.ID}==${CorpseItemID}) /destroy
    /delay 3s !${Corpse.Item[${i}].ID}
    /if (${Cursor.ID}) /call CheckCursor
/return

Sub CheckCursor
	:ALauto_inv
	/if (${Cursor.ID}) {
		/if (${Cursor.NoDrop} && !${Me.FreeInventory}) /return
		/timed 5 /autoinventory
		/delay 2s !${Cursor.ID}
		/goto :ALauto_inv
	}
/return

| **************** Foraged Items Section ******************** |
Sub Event_Forage
		/if (${Defined[LootForage]}) {
    	/if (!${LootForage}||!${Me.FreeInventory}) /return
    }
    /declare ForagedItem string local

    :MoreToAutoInventory
    /if (${Cursor.ID}) {
		/if (${Cursor.NoDrop} && ${Me.FreeInventory}) {
			/autoinv
			/goto :MoreToAutoInventory
		}
		
		/varset ForagedItem ${Cursor.Name}
		/if (!${Select[${Ini[Loot.ini,"${Cursor.Name.Left[1]}","${Cursor.Name}"]},Ignore,Keep,Destroy,Sell,Tradeskills,Collectible]}) {
			/if (${Cursor.ID}) /mmoini "loot.ini" "${Cursor.Name.Left[1]}" "${Cursor.Name}" "Keep"
			/if (${ReportLoot}) /echo New foraged item >> ${Cursor.Name} << added to Loot.ini
		}
		/if (${Ini[Loot.ini,"${Cursor.Name.Left[1]}","${Cursor.Name}"].Equal[Destroy]} || ${Ini[Loot.ini,"${Cursor.Name.Left[1]}","${Cursor.Name}"].Equal[Ignore]}) {
			/if (${Cursor.Name.Equal[${ForagedItem}]})     /destroy
			/delay 5
			/if (${ReportLoot}) /echo Destroyed foraged ${ForagedItem}.
		} else /if ((${Ini[Loot.ini,"${Cursor.Name.Left[1]}","${Cursor.Name}"].Equal[Keep]} || ${Ini[Loot.ini,"${Cursor.Name.Left[1]}","${Cursor.Name}"].Equal[Sell]}) && (!${Cursor.Lore} || !${FindItem[${Cursor.Name}].ID}) && (${Me.FreeInventory} || (${FindItemCount[=${Cursor.Name}]} && ${Cursor.Stackable} && ${Cursor.FreeStack}))) {
			/if (${ReportLoot}) /echo Kept foraged ${ForagedItem}.
			/autoinventory
			/delay 5
		}
	}
    /if (${Cursor.ID} && ${Me.FreeInventory}) /goto :MoreToAutoInventory
/return

| **************** Search Loot Section ******************** |
Sub DoLootStuff(LootAction)
    /declare i int local
    /declare j int local
    /declare k int local
    /declare LootItem string
    /if (${OpenAllBags}) {
        /echo Opening all bags
        /keypress OPEN_INV_BAGS
	}
   	/call NPC "${Target.CleanName}"
   	| Top level inv has its own loop since ${FindItem[=${ItemToSell}].InvSlot} looks at top lev inv slots first in Sub SellToVendor for the item to sell.
   	| Loop through top level inventory slots for sellable items
   	/for k 1 to 10
        | Check if top level inv slot is not a container or bag
        /if (${InvSlot[pack${k}].Item.Container}==0) {
            | If top level inv slot is empty check for an item marked sell
            /if (${InvSlot[pack${k}].Item.ID}) {
                /varset LootItem ${InvSlot[pack${k}].Item}
                /if (${LootAction.Equal[sell]})  {
    	            /if (${Ini[Loot.ini,"${LootItem.Left[1]}","${LootItem}"].Equal[Sell]}) /call SellToVendor "${LootItem}"
                }
                /if (${LootAction.Equal[deposit]})  {
                    /if (${Ini[Loot.ini,"${LootItem.Left[1]}","${LootItem}"].Equal[Keep]} && ${Target.CleanName.Equal[a guild banker]}) /call DepositToGuildBank "${LootItem}"
                    /if (${Ini[Loot.ini,"${LootItem.Left[1]}","${LootItem}"].Equal[Keep]} && ${Target.CleanName.NotEqual[a guild banker]}) /call DepositToBank "${LootItem}"
                }
            }
        }
    /next k     
	
	| Loop through top level inventory slots for containers
    /for i 1 to 10
		| Check if top level inv slot has a bag
        /if (${InvSlot[pack${i}].Item.Container}==0) /continue
		| Set j 1 to number of bag slots and loop through slots looking for items marked sell
        /for j 1 to ${InvSlot[pack${i}].Item.Container}
            /if (${InvSlot[pack${i}].Item.Item[${j}].ID}) {
        	    /varset LootItem ${InvSlot[pack${i}].Item.Item[${j}].Name}
            	/if (${LootAction.Equal[sell]})  {
                	/if (${Ini[Loot.ini,"${LootItem.Left[1]}","${LootItem}"].Equal[Sell]}) /call SellToVendor "${LootItem}"
                }
                /if (${LootAction.Equal[deposit]})  {
                    /if (${Ini[Loot.ini,"${LootItem.Left[1]}","${LootItem}"].Equal[Keep]} && ${Target.CleanName.Equal[a guild banker]}) /call DepositToGuildBank "${LootItem}"
                    /if (${Ini[Loot.ini,"${LootItem.Left[1]}","${LootItem}"].Equal[Keep]} && ${Target.CleanName.NotEqual[a guild banker]}) /call DepositToBank "${LootItem}"
                }
            }
        /next j
    /next i

    /if (${OpenAllBags}) {
        /echo Closing all bags
        /keypress CLOSE_INV_BAGS
    }
	| Prevent spam from Sell event after selling items in Sub SellStuff
    /doevents flush Sell
    /if (${Window[MerchantWnd].Open}) {
        /echo Closing merchant window
        /nomodkey /notify MerchantWnd MW_Done_Button LeftMouseUp
    }
    /if (${Window[GuildBankWnd].Open}||${Window[BigBankWnd].Open}) {
        /echo Closing bank/guildbank window
        /keypress esc
    }
/return
   
Sub NPC(NPCName)
    /target npc ${NPCName}
    /delay 1s
    /if (!${Select[${Target.Type},npc,pet]} || !${Target.ID} || ${Target.Type.Equal[pet]} && !${Target.CleanName.Find[familiar]}) {
        /echo Please target a vendor or guildbanker
        /return
    }
    /echo Doing business with ${NPCName}
    /target id ${Spawn[${NPCName}].ID}
    /delay 3s ${Target.ID}==${Spawn[${NPCName}].ID}
    /if (${Target.Distance}>15) {
        /moveto id  ${Spawn[${NPCName}].ID}
        /delay 250 ${MoveTo.Stopped}
    }
    /face nolook
    /delay 1s
    /echo Opening merchant/bank/guildbank window
    /nomodkey /click right target
    /echo Waiting 5s for merchant, banker or guildbank window to populate
    /delay 5s
/return

| **************** Sell Loot Section ******************** |
Sub Event_Sell(string soldstr, string ItemName)
    /if (!${Defined[AddNewSales]}) /declare AddNewSales bool outer FALSE
	/if ( ${AddNewSales} ) {
        /echo Setting ${ItemName} to sell
        /mmoini "loot.ini" "${ItemName.Left[1]}" "${ItemName}" "Sell"
    }
/return

Sub SellToVendor(ItemToSell)
    /if (${Window[MerchantWnd].Open}) {
    	:sell
        /echo Selling ${ItemToSell}
        /nomodkey /itemnotify ${FindItem[=${ItemToSell}].InvSlot} leftmouseup
        /delay 5
        /nomodkey /shiftkey /notify merchantwnd MW_Sell_Button leftmouseup
        /delay 2s
    	/if (${FindItem[${ItemToSell}].InvSlot}) /goto :sell
    }
/return

| **************** Deposit Guild Bank Loot Section ********************
Sub DepositToGuildBank(ItemToDeposit)
    /if (${Window[GuildBankWnd].Open}) {
        :deposit
        /if (${Window[GuildBankWnd].Child[GBANK_DepositCountLabel].Text.Arg[2,:]}==0) {
        	/echo Guildbank Deposited Items is full.
            /return
        }
        /echo Depositing ${ItemToDeposit}
		/nomodkey /shiftkey /itemnotify ${FindItem[=${ItemToDeposit}].InvSlot} leftmouseup
		/delay 5
		/nomodkey /notify GuildBankWnd GBANK_DepositButton leftmouseup
		/delay 2s
        /if (${FindItem[${ItemToSell}].InvSlot}) /goto :deposit
    }
/return

| **************** Deposit Personal Bank Loot Section ********************
#event NoBankRoom "You have no room left in the bank."
Sub Event_NoBankRoom
	/if (!${Defined[BankFull]}) /declare BankFull int outer
	/varset BankFull 1
/return

Sub DepositToBank(ItemToDeposit)
	/if (${BankFull}) /return
    /if (${Window[BigBankWnd].Open}) {
        :deposit
        /doevents NoBankRoom
		/if (${BankFull}) {
			/echo Bank is full.  Clear room and restart macro to add items.
			/return
		}
		/echo Depositing ${ItemToDeposit}
		/nomodkey /shiftkey /itemnotify ${FindItem[=${ItemToDeposit}].InvSlot} leftmouseup
		/delay 5
		/nomodkey /notify BigBankWnd BIGB_AutoButton leftmouseup
		/delay 2s
		/if (${FindItem[${ItemToSell}].InvSlot}) /goto :deposit
    }
/return

| **************** Item set ini file event ********************
Sub Event_EditIniItem(ItemString,ItemAction,ItemName)
	/if (${Cursor.ID}) {
		/echo -- Setting ${ItemName} to ${ItemAction}
		/mmoini "loot.ini" "${ItemName.Left[1]}" "${ItemName}" "${ItemAction}"
	} else {
		/echo No item on cursor.
	}
/return

| **************** Sell Stuff Event ********************
Sub Event_SellStuff
	/call DoLootStuff sell
/return
   
| **************** Deposit Stuff Event *******************
Sub Event_DepositStuff
	/call DoLootStuff deposit
/return
   
| **************** Broke Event ********************
Sub Event_Broke
    /if (!${Window[MerchantWnd].Open}) /return
    /echo You are out of money!
    /endmacro
/return

| **************** Type Stuff  ********************
| Lifted from commonsubs.inc by Armysoldier   
Sub Type(InStr)
    /declare char string local
    /declare loopctr int local
    /for loopctr 1 to ${InStr.Length}
        /varset char ${InStr.Mid[${loopctr},1]}
        /if (!${char.Length}) {
            /nomodkey /keypress space chat
        } else {
            /nomodkey /keypress ${char} chat
        }
    /next loopctr
/return

| **************** Buy Stuff ******************** 
Sub Buy(string ItemToBuy, int amount)
    /declare i int local
    | /echo Buying ${ItemToBuy}!
    /declare QTY int local
    /declare ListItem int local
    /varset QTY ${Math.Calc[${amount}-${FindItemCount[${ItemToBuy}]}]}
    /delay 1s
    /if (${FindItemCount[${ItemToBuy}]}>= ${amount}) {
        /echo I have enough ${ItemToBuy}.
        /return
    }   
    /varset ListItem ${Window[MerchantWnd].Child[ItemList].List[=${ItemToBuy},2]}
    /if (!${ListItem}) {
        /echo couldn't find ${ItemToBuy}
        /return
    } else {
        /notify MerchantWnd ItemList listselect ${ListItem}
        /delay 1s       
    }
    /echo Buying ${ItemToBuy} Till I get ${amount}
    :Loop
    /if (${QTY}>1) {
        /if (${QTY}>19) {
            /Shiftkey /notify merchantwnd MW_Buy_Button leftmouseup
            /delay 5s ${FindItemCount[${ItemToBuy}]}>=${amount}
            /echo ${FindItemCount[${ItemToBuy}]} ${ItemToBuy} in inventory
            /varset QTY ${Math.Calc[${amount}-${FindItemCount[${ItemToBuy}]}]}
            /delay 3
            /if (${QTY}<=0) /return
            /goto :Loop
        }
        /if (${QTY}>0 && ${QTY}<20) {
            /for i 1 to ${QTY}
                /ctrlkey /notify merchantwnd MW_Buy_Button leftmouseup
                /echo Buying ${ItemToBuy} ${i} of ${QTY}
                /varcalc QTY ${amount}-${FindItemCount[${ItemToBuy}]}
                /delay 3
                /if (${QTY}<=0) /return
            /next i
        }
    }
/return
   
Sub ZCheck(float Zcur, float Zdiff)
    | Move down if Z distance more than Zcheck due to levitation
    /if (${Zcur}>=${Zdiff}) {
        /keypress end hold
        /delay 10
        /keypress end
    }
/return


|CustomEvents
#event TaskGet "#*#TaskGet #1# #2#"
Sub Event_TaskGet(line,npcname,phrase)
	/if (!${SpawnCount[${npcname}]}) /return
	/target ${npcname}
	/delay 1s ${Target.Name.Equal[${npcname}]})
	/if (${phrase.Find[ noinvis]}) {
		/if (${Me.Invis}) /call Event_InvisOff
		/varset phrase ${phrase.Replace[ noinvis,]}
		/delay 1s !${Me.Invis}
	}
	/delay ${Math.Rand[40]}
	/if (${phrase.NotEqual[Hail]}) /say ${phrase}
	/if (${phrase.Equal[Hail]}) /hail
/return

#event LootSomething "#*#LootThis #1# #2# #3#"
Sub Event_LootThis(line,int corpseid,toon,itemname)
	/if (${Me.Name.NotEqual[${toon}]}||!${Spawn[${corpseid}].ID}) /return
	/if (${Me.Invis}) /declare wasinvis bool local
	/squelch /tar id ${corpseid}
	/delay 1s ${Target.ID}==${corpseid}
	/if (${Spawn[${corpseid}].Distance}<15) {
		/declare moveback bool TRUE
		/declare myloc string local ${Me.Y} ${Me.X} ${Me.Z}
		/declare myheading ${Me.Heading.DegreesCCW}
		/moveto id ${corpseid}
	}
	/delay 10s ${Spawn[${corpseid}].Distance}<15
	/loot
	/delay 2s

	/declare i int local
	/for i 1 to ${Corpse.Items}
		/if (${Corpse.Item[${i}].Name.Equal[${itemname}]}||${Corpse.Item[${i}].Name.Equal[${itemname.Right[-57].Left[-1]}]}) /call LootItem ${i} Keep Right
	/next i
	
	/if (${moveback}) {
		/moveto loc ${myloc}
		/delay 1s ${MoveTo.Moving}
		/delay 10s ${MoveTo.Stopped}
		/face ${myheading}
	}
	/if (${wasinvis}) /call Event_InvisOn
/return

#event ToggleInvis "#*#ToggleInvis #1#"
Sub Event_ToggleInvis(line,type)
	/if (${type.Equal[ivu]}) {
		/varset InvisSpell ${Ini[MyIni,${CurrentSub},InvisUndeadSpell]}
		/varset InvisSpellGem ${Ini[MyIni,${CurrentSub},InvisUndeadSpellGem]}
		/echo Now using ${InvisSpell} to invis vs undead
	} else {
		/varset InvisSpell ${Ini[MyIni,${CurrentSub},InvisSpell]}
		/varset InvisSpellGem ${Ini[MyIni,${CurrentSub},InvisSpellGem]}
		/echo Now using ${InvisSpell} to invis
	}
/return

Sub Init2
	/declare Init2Loaded int outer 1
	/declare i int local
	/for i 1 to 20
		/if (${Ini[MyIni,Initialize,Command${i}].Length}) /docommand ${Ini[MyIni,Initialize,Command${i}]}
	/next i
/return


#event Banestrike "Your Banestrike fails because you have not yet mastered slaying this race."
Sub Event_Banestrike
	/if (!${Defined[Banestrike]}) /declare Banestrike string outer |
	/if (${Target.ID} && !${Banestrike.Find[|${Target.Race}|]}) /varset Banestrike ${Banestrike}${Target.Race}|
/return

|AA start
#event AATimer "[ #1#: #2# ] (Reuse Time: #3# seconds)#*#"

Sub AALoad
	/varset CurrentSub AA
	/if (!${Defined[AALoaded]}) /declare AALoaded bool outer FALSE
	/if (${AALoaded}) /return
	/varset AALoaded TRUE
	/declare i int local 10
	/if (${Select[${Me.Class.ShortName},SHD,PAL]}) /varset i 10
	/if (${Select[${Me.Class.ShortName},CLR,RNG,ENC]}) /varset i 15
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/call SpellLoad "AA" ${i} "|1|3|4|7|8|9|17|30|" "|${i}|FALSE|----|96|5|1s|FALSE|TRUE|"
		/declare b string local
		/varset b ${Ini[MyIni,AA,AASpellName1,123456]}
		/if (${b.NotEqual[123456]}) /goto :skipaaini
		/declare aaEventTimer timer outer 3s
		/aa List timers
		
		:aaLoop
		/doevents
		/if (${aaEventTimer}) /goto :aaLoop
	}
	
	:skipaaini
	/call SpellLoad2 "${CurrentSub}" "3|4|7|8|9|17|30|"
/return

Sub AA
	/if (${Me.Hovering}) /return
	/varset CurrentSub AA
	/if (${Defined[${CurrentSub}Conditions]}) {
		/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	}
	/if (!${Defined[${CurrentSub}Conditions]}) /return
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${ImNotReady} && ${Me.Class.ShortName.Equal[BRD]}||${NeedLoad}) /return
	/if (!${${CurrentSub}Total}) /return
	/declare i int local
	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
 		/if (${ValidEnemy} && (!${Me.Casting.ID}||${Me.Class.ShortName.Equal[BRD]})) {
 			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset AAConditions${i} ${Ini[MyIni,AA,AAConditions${i},123456]}
			/if (!${Defined[AAIgnoreRecast${i}]}) /Declare AAIgnoreRecast${i} bool outer FALSE
			/if (!${Defined[AAOn${i}]}) /Declare AAOn${i} bool outer FALSE
			/if (!${Defined[AAMaxTries${i}]}) /Declare AAMaxTries${i} int outer 0
			/if (!${Defined[AAResisted${i}]}) /Declare AAResisted${i} bool outer FALSE
			/if (!${Defined[AASpellGem${i}]}) /Declare AASpellGem${i} string outer alt
			/if (${ValidSpellType} && ${ValidSpell} && (${CanCastOnMob}||${Me.AltAbility[${${CurrentSub}SpellName${i}}].Spell.SpellType.Equal[beneficial]}) && (${ShouldCastOnMob}||${Me.AltAbility[${${CurrentSub}SpellName${i}}].Spell.SpellType.Equal[beneficial]} && ${Spell[${Me.AltAbility[${${CurrentSub}SpellName${i}}].Spell.ID}].Stacks}) && ${CastIsReady} && ${NamedOk} && ${AAConditions${i}}) {
				|FINDME|
				|/if (${Me.AltAbilityReady[Banestrike]} && !${Banestrike.Find[|${Target.Race}|]} && ${Target.Distance}<${Me.AltAbility[Banestrike].Spell.Range}) {
				|	/call ${EchoSub} "${Purple} Banestrike --> ${White} ${Target}"
				|	/alt act ${Me.AltAbility[Banestrike].ID}
				|	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Banestrike --> ${Target.CleanName}
				|	/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} Banestrike --> ${Target.CleanName}
				|	/doevents
				|}
  				/call ${EchoSub} "${Purple} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
				/alt act ${Me.AltAbility[${${CurrentSub}SpellName${i}}].ID}
				/delay 2
				/delay 5 !${Me.Casting.ID}
				/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
			}
		}
	:skip
	/next i
/return

Sub Event_AATimer(line, string aaNumber, string aaName, string aaReuseTime)
	/if (!${NeedLoad}) /return
	/declare i int local
	/if (!${Defined[aa_ph]}) /declare aa_ph int outer 1
	/if (${AALeap.Find[${aaName}]}||${AAFeignDeath.Find[${aaName}]}||${AAPet.Find[${aaName}]}||${AAMount.Find[${aaName}]}||${AARez.Find[${aaName}]}||${AAIgnore.Find[${aaName}]}||${AACure.Find[${aaName}]}||${AAVeteran.Find[${aaName}]}||${AAInvisUndead.Find[${aaName}]}||${aaReuseTime}<0||${AALeap.Find[${aaName}]}||${AADA.Find[${aaName}]}${AAGlyph.Find[${aaName}]}||${AASummon.Find[${aaName}]}||${AACharm.Find[${aaName}]}||${AAPort.Find[${aaName}]}||${AAManaBurn.Find[${aaName}]}||${AAIllusion.Find[${aaName}]}) /goto :aadone
	/if (${AARoot.Find[${aaName}]}||${AAMana.Find[${aaName}]}||${AALifetap.Find[${aaName}]}||${AADebuff.Find[${aaName}]}||${AAJolt.Find[${aaName}]}||${AANuke.Find[${aaName}]}||${AADot.Find[${aaName}]}||${AAStun.Find[${aaName}]}||${AASnare.Find[${aaName}]}||${AASelfBuff.Find[${aaName}]}||${AABuff.Find[${aaName}]}||${AAHeal.Find[${aaName}]}||${AAImHit.Find[${aaName}]}||${AAInvis.Find[${aaName}]}||${AAFightBuff.Find[${aaName}]}) /got :aadone
	/if (${AARngArrow.Find[${aaName}]}||${AAFade.Find[${aaName}]}||${AAPetIgnore.Find[${aaName}]}||${AAMainTankBuff.Find[${aaName}]}||${AADot.Find[${aaName}]}) /goto :aadone
	/if (${AAEndurance.Find[${aaName}]}||${AABattleLeap.Find[${aaName}]}||${AAPulling.Find[${aaName}]}||${AAWizFury.Find[${aaName}]}||${AAWizFam.Find[${aaName}]}||${AAWizMancy.Find[${aaName}]}||${AAMagCore.Find[${aaName}]}||${AAMagForm.Find[${aaName}]}) /goto :aadone
	/if (${Select[${Me.AltAbility[${aaName}].Spell.Subcategory},Illusion: Player]}||${aaName.Find[Spire]}||${AAHealPet.Find[${aaName}]}||${AASwarmPet.Find[${aaName}]}||${AAArcanum.Find[${aaName}]}||${AAAEAggro.Find[${aaName}]}||${AAAggro.Find[${aaName}]}||${AAEnchant.Find[${aaName}]}||${AAPush.Find[${aaName}]}||${AAPull.Find[${aaName}]}||${AAMez.Find[${aaName}]}) /goto :aadone

	/declare sName	string local
	/varset sName ${aaName}

	/mmoini "MyIni" "AA" "AASpellName${aa_ph}" "${sName}"
	/varcalc aa_ph ${aa_ph}+1

	:aadone
	/varset aaEventTimer 2s
/return

|AA end

|Aggro Start

Sub AggroLoad
	/call Debug 3 "In Sub AggroLoad"
	/varset CurrentSub Aggro
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${AggroLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local
	/if (!${Defined[AEAggroCheck]}) {
		/declare AEAggroCheck int outer 0
		/declare AEAggroSpell string outer
		/declare AEAggroSpellGem string outer
	}
	/if (${Me.Class.ShortName.Equal[SHD]} && !${AEAggroCheck}) {
		/varset AEAggroCheck 1
		/varset AEAggroSpell 123456
	}
	/if (${Me.Class.ShortName.Equal[WAR]} && !${AEAggroCheck}) {
		/varset AEAggroCheck 1
		/varset AEAggroSpell 123456
		/if (${Me.AltAbility[area taunt]}) /varset AEAggroSpell Area Taunt
		/if (${Me.AltAbility[enhanced area taunt]}) /varset AEAggroSpell Enhanced Area Taunt
		/varset AEAggroSpellGem alt
	}
	/declare ChallengeSpellName string outer
	/declare ChallengeSpellGem string outer
	/declare ChallengeSpellRecourse string outer
	/declare AudacitySpellName string outer
	/declare AudacitySpellGem string outer
	/declare TerrorSpellName string outer
	/declare TerrorSpellGem string outer
	/declare UndividedSpellName string outer
	/declare UndividedLevel int local 0
	/declare BladeSpellName string outer
	/for i 1 to 300
		/if (!${Me.CombatAbility[${i}].ID}) /break
		/if ((${Me.CombatAbility[${i}].Name.Find[unbroken]}||${Me.CombatAbility[${i}].Name.Find[undivided]}) && ${Me.CombatAbility[${i}].Level}>${UndividedLevel}) {
			/varset UndividedSpellName ${Me.CombatAbility[${i}]}
			/varset UndividedLevel ${Me.CombatAbility[${i}].Level}
		}
		/if (${Me.Class.ShortName.Equal[WAR]} && ${Me.CombatAbility[${i}].Name.Find[ blade]}) /varset BladeSpellName ${Me.CombatAbility[${i}]}
	/next i

	:skip
	/for i 1 to ${MyGemTotal}
		/if (${Spell[${Me.Gem[${i}]}].Slot[1].Find[Increase hat]} && ${Spell[${Me.Gem[${i}]}].TargetType.Equal[PB AE]} && !${Spell[${Me.Gem[${i}]}].Slot[2].Find[Decrease hit]}) {
			/varset AEAggroSpell ${Me.Gem[${i}]}
			/varset AEAggroSpellGem gem${i}
			/if (${Me.Book[${AEAggroSpell} Rk. III]}||${Me.CombatAbility[${AEAggroSpell} Rk. III]}) /varset AEAggroSpell ${AEAggroSpell} Rk. III
			/if (${Me.Book[${AEAggroSpell} Rk. II]}||${Me.CombatAbility[${AEAggroSpell} Rk. II]}) /varset AEAggroSpell ${AEAggroSpell} Rk. II
		}
		/if (${Me.Gem[${i}].Name.Find[for Honor]}||${Me.Gem[${i}].Name.Find[for Power]}) {
			/varset ChallengeSpellName ${Me.Gem[${i}]}
			/varset ChallengeSpellGem gem${i}
			/varset ChallengeSpellRecourse ${Spell[${Me.Gem[${i}].AutoCast}]}
		}
		/if (${Me.Gem[${i}].Name.Find[Audacity]}) {
			/varset AudacitySpellName ${Me.Gem[${i}]}
			/varset AudacitySpellGem gem${i}	
		}
		/if (${Me.Gem[${i}].Name.Left[6].Equal[Terror]}) {
			/varset TerrorSpellName ${Me.Gem[${i}]}
			/varset TerrorSpellGem gem${i}	
		}
	/next i
	
	/declare Audacity int outer
	/declare GroupAggro int outer
	/declare AggroSpellName string outer ${Ini[MyIni,Aggro,AggroSpellName,NULL]}
	/if (${AggroSpellName.Equal[NULL]}) /mmoini "MyIni" "Aggro" "AggroSpellName"
	/if (${Me.Book[${AggroSpellName} Rk. III]}||${Me.CombatAbility[${AggroSpellName} Rk. III]}) /varset AggroSpellName ${AggroSpellName} Rk. III
	/if (${Me.Book[${AggroSpellName} Rk. II]}||${Me.CombatAbility[${AggroSpellName} Rk. II]}) /varset AggroSpellName ${AggroSpellName} Rk. II
	/declare AEAggroMinMobCount int outer ${Ini[MyIni,Aggro,AEAggroMinMobCount,1]}
	/if (${AEAggroMinMobCount}==1) /mmoini "MyIni" "Aggro" "AEAggroMinMobCount" "1"
	/declare AggroSpellGem string outer ${Ini[MyIni,Aggro,AggroSpellGem,NULL]}
	/if (${AggroSpellGem.Equal[NULL]}) /mmoini "MyIni" "Aggro" "AggroSpellGem" "gem1"
	/declare AggroConditions string outer ${Ini[MyIni,Aggro,AggroConditions,NULL]}
	/if (${AggroConditions.Equal[NULL]}) /mmoini "MyIni" "Aggro" "AggroConditions"
	/declare AggroAtAggroPct int outer ${Ini[MyIni,Aggro,AggroAtAggroPct,65]}
	/if (${AggroAtAggroPct}==65) /mmoini "MyIni" "Aggro" "AggroAtAggroPct" "65"
	/if (${Me.Class.ShortName.Equal[WAR]}) {
		/declare RampageMobCount int outer ${Ini[MyIni,Aggro,RampageMobCount,0]}
		/if (!${RampageMobCount}) /mmoini "MyIni" "Aggro" "RampageMobCount" "0"
	} else {
		/declare RampageMobCount int outer 0
	}
	/declare AggroCheck timer outer
	/call Debug 3 "Leaving Sub AggroLoad"
/return

Sub Aggro
	/call Debug 3 "In Sub Aggro"
	/if (!${Defined[AggroLoaded]}) /call AggroLoad
	/varset CurrentSub Aggro
	/if (!${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,1]}||${AggroCheck}) {
		/call Debug 2 "Leaving Sub Aggro - AggroCheck: ${AggroCheck} - !Ini: !${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,1]}"
		/return
	}
	
	/if (${Defined[Melee]}) {
		/if (!${Melee.AggroMode} && ${Plugin[mq2melee].Name.Equal[mq2melee]}||!${Group}||${Me.Moving}) {
			/call Debug 2 "Leaving Sub Aggro - Melee.AggroMode: ${Melee.AggroMode} - Group: ${Group} - Moving: ${Me.Moving}"
			/return
		}
	}
	/declare i int local
	/varset GroupAggro 0
	/for i 1 to ${Group.GroupSize}
		/if (${Group.Member[${i}].ID}) {
			/declare aggro${i} int local ${Group.Member[${i}].PctAggro}
			/if (${aggro${i}}>${GroupAggro}) /varset GroupAggro ${aggro${i}}
		}
	/next i

	/for i 1 to ${XTarget.Max}
		/if (${Me.XTarget[${i}].ID}) {
			/declare xaggro${i} int local ${Me.XTarget[${i}].PctAggro}
			/if (${xaggro${i}}<${AggroAtAggroPct}) /varset GroupAggro 100
		}
	/next i

	/call Debug 2 "Calculated GroupAggro at ${GroupAggro}"

	/varset AggroConditions ${Ini[MyIni,Aggro,AggroConditions,1]}
	/if (${Target.AggroHolder.ID}!=${Me.ID} && ${Me.AbilityReady[taunt]}) /doability taunt
	/if ((${Me.SpellReady[${ChallengeSpellName}]}||${Me.AltAbilityReady[${ChallengeSpellName}]}||${Me.CombatAbilityReady[${ChallengeSpellName}]}) && !${Me.Song[${ChallengeSpellRecourse}].ID}) {
		/call Debug 3 "Attempting to use ${ChallengeSpellName}"
		/call Cast "${ChallengeSpellName}" ${ChallengeSpellGem} NULL NULL NULL
		/call ${EchoSub} "${DarkRed} ${ChallengeSpellName} --> ${White} ${Target}"
   		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${ChallengeSpellName} --> ${Target.CleanName}
   		/goto :aggroend	
	}
	/if (${Me.SpellReady[${AudacitySpellName}]} && ${Audacity}!=${Target.ID}) {
		/call Debug 3 "Attempting to use ${AudacitySpellName}"
		/call Cast "${AudacitySpellName}" ${AudacitySpellGem} NULL NULL NULL
		/call ${EchoSub} "${DarkRed} ${AudacitySpellName} --> ${White} ${Target}"
   		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${AudacitySpellName} --> ${Target.CleanName}
   		/varset Audacity ${Target.ID}
   		/goto :aggroend	
	}
	/if (${Me.SpellReady[${TerrorSpellName}]} && (${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF})) {
		/call Debug 3 "Attempting to use ${TerrorSpellName}"
		/call Cast "${TerrorSpellName}" ${TerrorSpellGem} NULL NULL NULL
		/call ${EchoSub} "${DarkRed} ${TerrorSpellName} --> ${White} ${Target}"
   		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${TerrorSpellName} --> ${Target.CleanName}
   		/goto :aggroend
	}
	/if ((${Me.SpellReady[${AggroSpellName}]}||${Me.AltAbilityReady[${AggroSpellName}]}||${Me.CombatAbilityReady[${AggroSpellName}]}) && ${AggroConditions} && (${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF})) {
		/call Debug 3 "Attempting to use ${AggroSpellName}"
		/call Cast "${AggroSpellName}" ${AggroSpellGem} NULL NULL NULL
		/call ${EchoSub} "${DarkRed} ${AggroSpellName} --> ${White} ${Target}"
   		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${AggroSpellName} --> ${Target.CleanName}
   		/goto :aggroend
	}
	/if (${AEAggroSpell.NotEqual[NULL]} && ${AEAggroSpell.NotEqual[123456]} && (${Me.SpellReady[${AEAggroSpell}]}||${Me.AltAbilityReady[${AEAggroSpell}]}||${Me.CombatAbilityReady[${AEAggroSpell}]}) && ${AddCount}>=${AEAggroMinMobCount} && !${Me.AltAbilityReady[Explosion of Spite]} && !${Me.AltAbilityReady[Explosion of Hatred]} && !${Raid.Members}) {
		/call Debug 3 "Attempting to use ${AEAggroSpell}"
		/call Cast "${AEAggroSpell}" ${AEAggroSpellGem} NULL NULL NULL
		/call ${EchoSub} "${DarkRed} ${AEAggroSpell} --> ${White} All mobs"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${AEAggroSpell}
    	/goto :aggroend
	}
	/if (${Me.CurrentEndurance}>${Spell[${BladeSpellName}].EnduranceCost} && ${BladeSpellName.NotEqual[NULL]} && ${BladeSpellName.NotEqual[123456]} && ${Me.CombatAbilityReady[${BladeSpellName}]} && ${AddCount}>=${AEAggroMinMobCount} && !${Raid.Members} && ${GroupAggro}>${AggroAtAggroPct}) {
		/call Debug 3 "Attempting to use ${BladeSpellName}"
		/disc ${BladeSpellName}
		/call ${EchoSub} "${DarkRed} ${BladeSpellName} --> ${White} All mobs"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${BladeSpellName}
    	/goto :aggroend
	}
	/if (${RampageMobCount} && ${SpawnCount[npc radius 30]}>=${RampageMobCount} && ${Me.AltAbilityReady[Rampage]} && ${AddCount}>=${RampageMobCount} && !${Raid.Members}) {
		/call Debug 3 "Attempting to use Rampage"
		/call Cast "Rampage" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Rampage --> ${White} All mobs"
	    /if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Rampage
	    /goto :aggroend
	}
	/if (${Me.AltAbilityReady[Explosion of Spite]} && ${SpawnCount[npc radius 30]}>=${AEAggroMinMobCount} && ${AddCount}>=${AEAggroMinMobCount} && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF}) && !${Me.AltAbilityReady[Explosion of Hatred]} && !${Raid.Members}) {
		/call Debug 3 "Attempting to use Explosion of Spite"
		/call Cast "Explosion of Spite" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Explosion of Spite --> ${White} All mobs"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Explosion of Spite
    	/goto :aggroend
	}
	/if (${Me.AltAbilityReady[Explosion of Hatred]} && ${SpawnCount[npc radius 30]}>=${AEAggroMinMobCount} && ${AddCount}>=${AEAggroMinMobCount} && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF}) && !${Raid.Members}) {
		/call Debug 3 "Attempting to use Explosion of Hatred"
		/call Cast "Explosion of Hatred" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Explosion of Hatred --> ${White} All mobs"
	    /if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Explosion of Hatred
	    /goto :aggroend
	}
	/if (${Me.AltAbilityReady[Ageless Enmity]} && (${Target.Name.Find[#]}||${Target.Named}) && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF})) {
		/call Debug 3 "Attempting to use Ageless Enmity"
		/call Cast "Ageless Enmity" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Ageless Enmity --> ${White} ${Target}"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Ageless Enmity --> ${Target.CleanName}
	}
	/if (${Me.Class.ShortName.Equal[SHD]} && ${Me.AltAbilityReady[Projection of Doom]} && (${Target.Name.Find[#]}||${Target.Named}) && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF})) {
		/call Cast "Projection of Doom" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Projection of Doom --> ${White} ${Target}"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Projection of Doom --> ${Target.CleanName}
       	/goto :aggroend
	}
	/if (${Me.Class.ShortName.Equal[WAR]} && ${Me.AltAbilityReady[Projection of Fury]} && (${Target.Name.Find[#]}||${Target.Named}) && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF})) {
		/call Cast "Projection of Fury" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Projection of Fury --> ${White} ${Target}"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Projection of Fury --> ${Target.CleanName}
       	/goto :aggroend
	}
	/if (${Me.AltAbilityReady[Beacon of the Righteous]} && ${SpawnCount[npc radius 30]}>=${AEAggroMinMobCount} && ${AddCount}>=${AEAggroMinMobCount} && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF}) && !${Raid.Members}) {
		/call Cast "Beacon of the Righteous" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Beacon of the Righteous --> ${White} All mobs"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Beacon of the Righteous
      	/goto :aggroend
	}	
	/if (${Me.Class.ShortName.Equal[PAL]} && ${Me.AltAbilityReady[Projection of Piety]} && (${Target.Name.Find[#]}||${Target.Named}) && (${Me.PctAggro}<100||${GroupAggro}>${AggroAtAggroPct}||!${FacingMe} && !${Me.ROF})) {
		/call Cast "Projection of Piety" alt NULL NULL NULL
		/call ${EchoSub} "${DarkRed} Projection of Piety --> ${White} ${Target}"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Projection of Piety --> ${Target.CleanName}
       	/goto :aggroend
	}

	:aggroend
	/varset AggroCheck 1s
	/call Debug 3 "Leaving Sub Aggro"
/return
|Aggro end

|Aura start

#event AuraDelay	"You do not have sufficient focus to maintain that ability."

Sub AuraLoad
	/varset CurrentSub Aura
	/if (!${Defined[AuraLoaded]}) /declare AuraLoaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/if (!${Defined[NeedAura]}) /declare NeedAura bool outer TRUE
	/declare i int local 2
	/if (${Select[${Me.Class.ShortName},RNG,BST,WAR,MNK,ROG,BER,SHD,NEC,MAG,WIZ]}) /varset i 1
	/if (${Select[${Me.Class.ShortName},ENC,CLR]}) /varset i 2

	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/call SpellLoad "Aura" ${i} "|1|3|4|5|6|" "|${i}|FALSE|----|----|----|"
	}
	/call SpellLoad2 "${CurrentSub}" "|3|4|5|6|"
	/declare meleeaura string outer |WAR|MNK|ROG|BER|
	/declare dblaura string outer |ENC|CLR|
	/if (!${Defined[AuraDelay]}) /declare AuraDelay timer outer
	/if (!${Defined[twisting]}) /declare twisting bool outer
/return

Sub Aura
	|** Beastlords don't have an Aura **|
	/if (${Me.Class.ShortName.Equal[BST]}) /return
	/if (${Me.Hovering}) /return
	/varset CurrentSub Aura
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${${CurrentSub}Total}) /return
	/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis}) /goto :bard
	
	/if (${ImNotReady}||${Bool[${Me.Aura[1]}]} && !${Me.AltAbility[Spirit Mastery]} && !${Me.AltAbility[Auroria Mastery]}||${Bool[${Me.Aura[2]}]}||${AuraDelay}||${NeedLoad}) /return
	
	:bard
  	/if (${Me.Class.ShortName.Equal[BRD]}) {
	  	/if (${Bool[${Me.Aura[1]}]}) {
			/if (${NeedAura}) /varset NeedAura FALSE
			/return
		}
	}
  	
	/if (${Bool[${Me.Aura[1]}]} && !${Me.AltAbility[Spirit Mastery]} && !${Me.AltAbility[Auroria Mastery]}||${Bool[${Me.Aura[2]}]}||${AuraDelay}||${NeedLoad}) /return
	
	/if (${${CurrentSub}Total}) {
		/if (${${CurrentSub}Use1}) {
			/if (${Me.Aura[1].Find[${AuraSpellName1}]}) /varset NeedAura FALSE
			/if (!${Me.Aura[1].Find[${AuraSpellName1}]} && !${Me.Aura[2].Find[${AuraSpellName1}]}) {
				/varset NeedAura TRUE
				/if (${meleeaura.Find[${Me.Class.ShortName}]}) {
					/cechob \ag${AuraSpellName1} \aw<~~ 
					/disc ${${CurrentSub}SpellName1}
				} else /if (!${meleeaura.Find[${Me.Class.ShortName}]} && ${Me.Class.ShortName.NotEqual[BRD]}) {
					/casting "${${CurrentSub}SpellName1}" ${${CurrentSub}SpellGem1}
					/cechob \ag${AuraSpellName1} \aw<~~ 
					/delay 2s !${Me.Casting.ID}
				} else /if (${Me.Class.ShortName.Equal[BRD]} && ${NeedAura} && ${Plugin[MQ2Twist].Name.Length}) {
					/squelch /twist once ${Me.Gem[${${CurrentSub}SpellName1}]}
					/cechob \ag${AuraSpellName1} \aw<~~ 
					/delay 35 ${Me.Aura[1].Find[${AuraSpellName1}]}
				}
			}
		}
		
		/if (${dblaura.Find[${Me.Class.ShortName}]}) {
			/if (${${CurrentSub}Use2}) {
				/if (!${Me.Aura[1].Find[${AuraSpellName2}]} && !${Me.Aura[2].Find[${AuraSpellName2}]}) {
					/if ((${Me.AltAbility[Spirit Mastery]}||${Me.AltAbility[Auroria Mastery]})) {
						/casting "${${CurrentSub}SpellName2}" ${${CurrentSub}SpellGem2}
						/delay 2s !${Me.Casting.ID}
					}
				}
			}
		}
	}

/return

Sub Event_AuraDelay
	/if (!${Defined[AuraDelay]}) /declare AuraDelay timer outer
	/varset AuraDelay 1m
/return

|Aura end

|Autoclickies start

Sub AutoClickies
	/if (!${Defined[AutoClickiesLoad]}) /call AutoClickiesLoad
	/if (${NeedLoad}) /return
	/call DoClickies
	/if (${FindItem[Chalandria's Fang].ItemSlot} && !${FindItem[Chalandria's Fang].Timer}) {
		/if (${Me.HaveExpansion[Veil of Alaris]} && ${Me.Subscription.Equal[GOLD]}) /useitem ${FindItem[=Chalandria's Fang].ItemSlot} ${FindItem[=Chalandria's Fang].ItemSlot2}
		/if (!${Me.HaveExpansion[Veil of Alaris]}) /casting "Chalandria's Fang"|item
		/delay 1s
		/autoinventory
	}
/return

Sub AutoClickiesLoad
	/varset CurrentSub AutoClickies
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${NeedLoad}) /return
	/if (${AutoClickiesLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare iBuffTotal int outer 17
	/declare ClickyArray[${iBuffTotal},4] string outer 0
	/declare sBuff1 string outer Ancestral Memories
	/declare sBuffClass1 string outer |BER|BST|BRD|MNK|PAL|RNG|ROG|SHD|WAR|
	/declare sBuff2 string outer Taelosian Guard
	/declare sBuffClass2 string outer |BER|BST|BRD|MNK|PAL|RNG|ROG|SHD|WAR|
	/declare sBuff3 string outer Might of Stone
	/declare sBuffClass3 string outer |BER|BST|BRD|MNK|PAL|RNG|ROG|SHD|WAR|
	/declare sBuff4 string outer Form of Defense
	/declare sBuffClass4 string outer |PAL|SHD|WAR|
	/declare sBuff5 string outer Prismatic Ward
	/declare sBuffClass5 string outer |BER|BST|BRD|CLR|DRU|ENC|MAG|MNK|NEC|PAL|RNG|ROG|SHD|SHM|WAR|WIZ|
	/declare sBuff6 string outer Form of Endurance
	/declare sBuffClass6 string outer |BER|BST|BRD|CLR|DRU|ENC|MAG|MNK|NEC|PAL|RNG|ROG|SHD|SHM|WAR|WIZ|
	/declare sBuff7 string outer Myrmidon's Skill
	/declare sBuffClass7 string outer |BER|BST|BRD|CLR|DRU|ENC|MAG|MNK|NEC|PAL|RNG|ROG|SHD|SHM|WAR|WIZ|
	/declare sBuff8 string outer Knowledge of the Past
	/declare sBuffClass8 string outer |BST|CLR|DRU|ENC|MAG|NEC|PAL|RNG|SHD|SHM|WIZ|
	/declare sBuff9 string outer Soothing Breath
	/declare sBuffClass9 string outer |BST|CLR|DRU|ENC|MAG|NEC|PAL|RNG|SHD|SHM|WIZ|
	/declare sBuff10 string outer Illusionary Spikes
	/declare sBuffClass10 string outer |
	/declare sBuff11 string outer Geomantra
	/declare sBuffClass11 string outer |
	/declare sBuff12 string outer Expanding Mind
	/declare sBuffClass12 string outer |BST|CLR|DRU|ENC|MAG|NEC|PAL|RNG|SHD|SHM|WIZ|
	/declare sBuff13 string outer Symphony of Battle
	/declare sBuffClass13 string outer |BRD|
	/declare sBuff14 string outer Twitching Speed
	/declare sBuffClass14 string outer |BER|BST|MNK|PAL|RNG|ROG|SHD|WAR|
	/declare sBuff15 string outer Aura of Pure Arcanum
	/declare sBuffClass15 string outer |BER|BST|BRD|CLR|DRU|ENC|MAG|MNK|NEC|PAL|RNG|ROG|SHD|SHM|WAR|WIZ|
	/declare sBuff16 string outer Aura of Rage
	/declare sBuffClass16 string outer |BER|BST|MNK|PAL|RNG|ROG|SHD|WAR|
	/declare sBuff17 string outer Ancient Flames
	/declare sBuffClass17 string outer |BER|BST|BRD|CLR|DRU|ENC|MAG|MNK|NEC|PAL|RNG|ROG|SHD|SHM|WAR|WIZ|

	/declare BuffRank string outer , I , II , III , IV , V , VI , VII , VIII , IX , X , XI , XII , XII , XIV , XV , XVI , XVII , XVIII , XIX , XX , XXI , XXII , XXIII , XXIV , XXV , XXVI , XXVII , XXVIII , XXIX , XXX ,
	/call GetEquipment
	/call CalculateBest
/return

Sub CalculateBest
	/declare CalculateBest int outer 1
	|Soothing vs KotP
	|${Spell[Knowledge of the Past].Slot[8].Left[-9].Right[-17]}

	/if (${ClickyArray[9,1]} && ${ClickyArray[8,1]}) {
		/if (${Spell[${ClickyArray[8,2]}].Base[8]}>${Spell[${ClickyArray[9,2]}].Base[8]}) {
			/varset ClickyArray[9,1] 0
		} else {
			/varset ClickyArray[8,1] 0
		}
	}

	|FoD vs Pris Ward
	|${Spell[name].Slot[10].Left[-15]}

	/if (${ClickyArray[4,1]} && ${ClickyArray[5,1]}) {
		/if (${Spell[${ClickyArray[4,2]}].Base[10]}>${Spell[${ClickyArray[5,2]}].Base[10]}) {
			/varset ClickyArray[5,1] 0
		} else {
			/varset ClickyArray[4,1] 0
		}
	}

	|Taelosian vs AM
	|${Spell[Ancestral Memories III].Slot[1].Left[-1].Right[-21]}
	/if (${ClickyArray[2,1]} && ${ClickyArray[1,1]}) {
		/if (${Spell[${ClickyArray[1,2]}].Base[1]}>${Spell[${ClickyArray[2,2]}].Base[1]}) {
			/varset ClickyArray[2,1] 0
		} else {
			/varset ClickyArray[1,1] 0
		}
	}

	|ACoF
	/if (${ClickyArray[17,1]} && ${ClickyArray[1,1]}||${ClickyArray[17,1]} && ${ClickyArray[2,1]}) {
		/varset ClickyArray[2,1] 0
		/varset ClickyArray[1,1] 0
	}
/return

Sub DoClickies
	/if (${Me.Hovering}||!${MMOBugs.FreeBuffs} && ${MMOBugs}||${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]}) /return
	/varset CurrentSub DoClickies
	/declare i int local
	/for i 1 to ${iBuffTotal}
		/if (${ClickyArray[${i},1]} && ${Spell[${ClickyArray[${i},2]}].Stacks} && !${Me.Buff[${ClickyArray[${i},2]}].ID} && (!${Me.Invis}||${AutoBreakInvis} && ${AutoInvis}) && !${Me.Sitting} && (!${Me.Moving}||${Me.Class.ShortName.Equal[BRD]}) && (!${Me.Song[Commanding Voice].ID} && !${Me.Buff[Commanding Voice].ID} && !${Me.Song[Guardian Circle I Effect].ID} && !${Me.Song[Guardian Circle II Effect].ID} && !${Me.Song[Guardian Circle III Effect].ID}||${i}!=7)  && (${i}!=14||!${Me.Hasted.ID})) {
			/if (${Me.Hovering}||!${MMOBugs.FreeBuffs} && ${MMOBugs}||${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]}) /return
			/if (${Plugin[MQ2Twist].Name.Length}) {
				/if (${Twist.Twisting}) {
					/declare temptwist bool local TRUE
					/twist stop
					/delay 2
				}
			}
			/if (${FindItem[${ClickyArray[${i},3]}].EffectType.Equal[Click Inventory]} && ${Me.HaveExpansion[Veil of Alaris]} && (${Me.Subscription.Equal[GOLD]}||${FindItem[=${ClickyArray[${i},3]}].InvSlot}<33)) /useitem ${FindItem[=${ClickyArray[${i},3]}].ItemSlot} ${FindItem[=${ClickyArray[${i},3]}].ItemSlot2}
			/if (${FindItem[${ClickyArray[${i},3]}].EffectType.Equal[Click Worn]}||!${Me.HaveExpansion[Veil of Alaris]}||${Me.Subscription.NotEqual[GOLD]}) /casting "${ClickyArray[${i},3]}"|item
			/delay 1s ${Me.Casting.ID}
			/echo ${ClickyArray[${i},3]} --> ${ClickyArray[${i},2]}
			/delay 10s !${Me.Casting.ID}
			/if (${Plugin[MQ2Twist].Name.Length}) {
				/if (${temptwist}) /twist start
			}
		}
	/next i
/return

Sub GetEquipment
	/declare GetEquipment int outer 1
	/declare sTempName string local
	/declare i int local
	/declare ii int local
	/declare iSlot int outer
	/declare iItemNum int outer
	/declare sItemName string outer
	/declare iClickyRank int outer
   	/for iSlot 1 to 32
		|top level inventory
		/if (${InvSlot[${iSlot}].Item.Name.NotEqual[NULL]}) {
			/varset sItemName ${InvSlot[${iSlot}].Item.Spell.Name}
			/if (${sItemName.NotEqual[NULL]} && ${InvSlot[${iSlot}].Item.EffectType.Find[Click]} && ${Me.Level}>=${Me.Inventory[${iSlot}].RequiredLevel} && ${Me.Inventory[${iSlot}].Class[${Me.Class}].Name.Equal[${Me.Class}]} && (!${Me.Inventory[${iSlot}].Attuneable}||${Me.Inventory[${iSlot}].Attuneable} && ${Me.Inventory[${iSlot}].NoDrop})) {
				/for i 1 to ${iBuffTotal}
					/if (${Me.Inventory[${iSlot}].Spell.Name.Find[${sBuff${i}}]}) {
						/for ii 1 to 25
							/if (${Me.Inventory[${iSlot}].Spell.Name.Equal[${sBuff${i}}]}) {
								/varset iClickyRank 26
								/break
							}
						
							/varset sTempName "${Me.Inventory[${iSlot}].Spell.Name} "
							/varset sTempName ${sTempName.Left[-1].Right[-1]}
							
							/if (${sTempName.Find[${BuffRank.Arg[${ii},,]}]}) {
								/varset iClickyRank ${ii}
							}
						/next ii
						
						/if (${sBuffClass${i}.Find[${Me.Class.ShortName}]} && ${iClickyRank}>${ClickyArray[${i},4]}) {
							/varset ClickyArray[${i},1] 1
							/varset ClickyArray[${i},2] ${Me.Inventory[${iSlot}].Spell}
							/varset ClickyArray[${i},3] ${Me.Inventory[${iSlot}]}
							/varset ClickyArray[${i},4] ${iClickyRank}
						}
					}
				/next i
			}			
		}
	
		|Bag inventory
      	/if (${InvSlot[${iSlot}].Item.Container}>0) {
        	/for iItemNum 1 to ${InvSlot[${iSlot}].Item.Container}
				/if (${Me.Inventory[${iSlot}].Item[${iItemNum}].ID} && ${Me.Inventory[${iSlot}].Item[${iItemNum}].Spell.ID} && ${Me.Inventory[${iSlot}].Item[${iItemNum}].CastTime} && ${Me.Inventory[${iSlot}].Item[${iItemNum}].WornSlots} && ${Me.Level}>=${Me.Inventory[${iSlot}].Item[${iItemNum}].RequiredLevel} && ${Me.Inventory[${iSlot}].Item[${iItemNum}].Class[${Me.Class}].Name.Equal[${Me.Class}]} && ${Spell[${Me.Inventory[${iSlot}].Item[${iItemNum}].Spell}].Duration}>50 && (!${Me.Inventory[${iSlot}].Item[${iItemNum}].Attuneable}||${Me.Inventory[${iSlot}].Item[${iItemNum}].Attuneable} && ${Me.Inventory[${iSlot}].Item[${iItemNum}].NoDrop})) {
					/for i 1 to ${iBuffTotal}
						/if (${Me.Inventory[${iSlot}].Item[${iItemNum}].Spell.Name.Find[${sBuff${i}}]}) {
							/for ii 1 to 2
								/if (${Me.Inventory[${iSlot}].Item[${iItemNum}].Spell.Name.Equal[${sBuff${i}}]}) {
									/varset iClickyRank 26
									/break
								}
								/if (${Me.Inventory[${iSlot}].Item[${iItemNum}].Spell.Name.Find[${BuffRank.Arg[${ii},,].Left[-1]}]}) /varset iClickyRank ${ii}

							/next ii

							/if (${sBuffClass${i}.Find[${Me.Class.ShortName}]} && ${iClickyRank}>${ClickyArray[${i},4]}) {
								/varset ClickyArray[${i},1] 1
								/varset ClickyArray[${i},2] ${Me.Inventory[${iSlot}].Item[${iItemNum}].Spell}
								/varset ClickyArray[${i},3] ${Me.Inventory[${iSlot}].Item[${iItemNum}].Name}
								/varset ClickyArray[${i},4] ${iClickyRank}
							}
						}
					
					/next i
				}
         	/next iItemNum
		}
	/next iSlot
/return

|Autoclickies end

|bard start
Sub BardLoad
	/if (!${Defined[BardLoaded]}) /declare BardLoaded bool outer FALSE
	/if (${BardLoaded}) /return
	/varset BardLoaded TRUE
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/declare i int local
		/declare UseSelos bool outer ${Ini[MyIni,Bard,UseSelos,FALSE]}
		/if (!${UseSelos}) /mmoini "MyIni" "Bard" "UseSelos" "FALSE"
		/declare SelosSong string outer ${Ini[MyIni,Bard,SelosSong,-1]}
		/if (${SelosSong.Equal[-1]}) /mmoini "MyIni" "Bard" "SelosSong" "----"
		/declare UseSingleMez bool outer ${Ini[MyIni,Bard,UseSingleMez,FALSE]}
		/if (!${UseSingleMez}) /mmoini "MyIni" "Bard" "UseSingleMez" "FALSE"
		/declare UseCrescendo bool outer ${Ini[MyIni,Bard,UseCrescendo,FALSE]}
		/if (!${UseCrescendo}) /mmoini "MyIni" "Bard" "UseCrescendo" "FALSE"
		/declare CrescendoAtGroupMana int outer ${Ini[MyIni,Bard,CrescendoAtGroupMana,30]}
		/if (${CrescendoAtGroupMana}==30) /mmoini "MyIni" "Bard" "CrescendoAtGroupMana" "30"
		/declare CrescendoAtGroupEndurance int outer ${Ini[MyIni,Bard,CrescendoAtGroupEndurance,30]}
		/if (${CrescendoAtGroupEndurance}==30) /mmoini "MyIni" "Bard" "CrescendoAtGroupEndurance" "30"
		/declare CrescendoMyMinMana int outer ${Ini[MyIni,Bard,CrescendoMyMinMana,30]}
		/if (${CrescendoMyMinMana}==30) /mmoini "MyIni" "Bard" "CrescendoMyMinMana" "30"
		/declare UseSlow bool outer ${Ini[MyIni,Bard,UseSlow,FALSE]}
		/declare SlowName string outer ${Ini[MyIni,Bard,SlowName,NULL]}
		/declare UseTashOrb bool outer ${Ini[MyIni,Bard,UseTashOrb,FALSE]}
		/if (!${UseSlow}) /mmoini "MyIni" "Bard" "UseSlow" "FALSE"
		/if (${SlowName.Equal[NULL]}) /mmoini "MyIni" "Bard" "SlowName" "Requiem of Time" 
		/if (!${UseTashOrb}) /mmoini "MyIni" "Bard" "UseTashOrb" "FALSE"
		/declare RestTwist string outer ${Ini[MyIni,Bard,RestTwist,NULL]}
		/declare CombatTwist string outer ${Ini[MyIni,Bard,CombatTwist,NULL]}
		/declare StopSongsIfPullerIsThisDistanceOrMore int outer ${Ini[MyIni,Bard,StopSongsIfPullerIsThisDistanceOrMore,0]}
		/if (${RestTwist.Equal[NULL]} && ${Plugin[MQ2Twist].Name.Length}) /mmoini "MyIni" "Bard" "RestTwist" "${Twist.List}"
		/if (${CombatTwist.Equal[NULL]} && ${Plugin[MQ2Twist].Name.Length}) /mmoini "MyIni" "Bard" "CombatTwist" "${Twist.List}"
		/if (!${StopSongsIfPullerIsThisDistanceOrMore}) /mmoini "MyIni" "Bard" "StopSongsIfPullerIsThisDistanceOrMore" "0"
		/declare BardTimer timer outer
		/declare BardMezList string outer
		/for i 1 to ${MyGemTotal}
			/if (${Me.Gem[${i}].Name.Find[Crescendo]}) {
				/if (!${Defined[CrescendoFound]}) /declare CrescendoFound bool outer TRUE
				/declare Crescendo string outer ${Me.Gem[${i}]}
				/declare CrescendoGem string outer ${i}
				/goto :bardmez
			} else {
				/if (!${Defined[CrescendoFound]}) /declare CrescendoFound bool outer FALSE
			}
		/next i
		
		:bardmez
		/declare BardMezTotal int outer
		/if (${Me.AltAbility[Dirge of the Sleepwalker]}) {
			/varcalc BardMezTotal ${BardMezTotal}+1
			/declare BardMezSpellName${BardMezTotal} string outer Dirge of the Sleepwalker
			/declare BardMezSpellGem${BardMezTotal} string outer alt
			/declare BardMezSpellLevel${BardMezTotal} int outer ${Me.AltAbility[Dirge of the Sleepwalker].Spell.Max[3]}
			/declare BardMezTimer${BardMezTotal} timer outer 54s
		}
		
		/for i 1 to ${MyGemTotal}
			/if (${Me.Gem[${i}].Subcategory.Equal[enthrall]}) {
				/varcalc BardMezTotal ${BardMezTotal}+1
				/declare BardMezSpellName${BardMezTotal} string outer ${Me.Gem[${i}]}
				/declare BardMezSpellGem${BardMezTotal} string outer ${i}
				/declare BardMezSpellLevel${BardMezTotal} int outer ${Spell[${BardMezSpellName${BardMezTotal}}].Max[1]}
				/declare BardMezTimer${BardMezTotal} timer outer 15s
			}
		/next i
	}
/return

Sub BardRest
	/declare i int local
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /return
	/varset CurrentSub BardRest
	/if (${UseCrescendo} && ${CrescendoFound} && ${Group}) {
		/if (${Me.PctMana}>${CrescendoMyMinMana}) {
			/for i 1 to ${Group}
				/if ((${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM,PAL,SHD,RNG,BST,WIZ,MAG,NEC,ENC]} && ${Group.Member[${i}].PctMana}<${CrescendoAtGroupMana}||${Select[${Group.Member[${i}].Class.ShortName},MNK,WAR,ROG,BER,SHD,PAL,RNG,BST]} && ${Group.Member[${i}].PctEndurance}<${CrescendoAtGroupEndurance}) && !${Me.GemTimer[${Crescendo}]} && ${Me.Gem[${Crescendo}]}) {
					/if (${Plugin[MQ2Twist].Name.Length}) {
						/twist once ${CrescendoGem}
						/echo Twisting once - Crescendo
						/call ${EchoSub} "${Orange} ${Crescendo} ${White} --> Group"
						/delay 38
					}
				}
			/next i
		}
	}
/return

Sub BardMez
	/if (${Me.Class.ShortName.NotEqual[BRD]}||!${UseSingleMez}) /return
	/varset CurrentSub BardMez
	/declare i int local
	/declare a int local
	/for a 1 to ${BardMezList.Count[|]}
		/if (!${Spawn[${BardMezList.Arg[${a},|]}].ID} && ${BardMezList.Length}) /varset BardMezList ${BardMezList.Replace[${BardMezList.Arg[${a},|]},]}
	/next a
	/for a 1 to ${AddList.Count[|]} 
		/for i 1 to ${BardMezTotal}
			/if (!${Defined[IgnoreImmuneLists]}) /declare IgnoreImmuneLists ${Ini[MyIni,Mez,IgnoreImmuneLists,False]}
			/if (!${Defined[BardMez${AddList.Arg[${a},|]}]} && ${TarID} && ${Spawn[id ${AddList.Arg[${a},|]}].ID} && ${AddList.Arg[${a},|]}!=${TarID} && ${Spawn[id ${AddList.Arg[${a},|]}].Distance}<=${AttackRange} && (${IgnoreImmuneLists}||!${MezImmuneList.Find[${Spawn[id ${AddList.Arg[${a},|]}].CleanName}]})) /call BardMezAdd ${AddList.Arg[${a},|]}
		/next i
	/next a
/return

Sub BardMezAdd(int mezid)
	/varset CurrentSub BardMezAdd
	/if (!${BardMezList.Find[${mezid}]}) /varset BardMezList ${BardMezList}${mezid}|
	/if (!${Defined[BardMez${mezid}]}) /declare BardMez${mezid} timer outer
	/declare i int local
	/for i 1 to ${BardMezTotal}
		/if (${Spawn[${mezid}].Level}<=${BardMezSpellLevel${i}} && (${Me.AltAbilityReady[${BardMezSpellName${i}}]}||${Me.Gem[${BardMezSpellName${i}}]})) {
			/squelch /attack off
			/squelch /tar id ${mezid}
			/delay 1s ${Target.ID}==${mezid}
			/if (${BardMezSpellName${i}.Equal[Dirge of the Sleepwalker]}) {
				/alt act ${Me.AltAbility[Dirge of the Sleepwalker].ID}
				/call ${EchoSub} "${Pink} ${BardMezSpellName${i}} ${White} --> ${Target.CleanName}"
				/varset BardMez${mezid} ${BardMezTimer${i}.OriginalValue}
				/return
			}
			/if (${Me.Gem[${BardMezSpellName${i}}]} && ${Plugin[MQ2Twist].Name.Length}) {
				/twist once ${BardMezSpellGem${i}}
				/call ${EchoSub} "${Pink} ${BardMezSpellName${i}} ${White} --> ${Target.CleanName}"
				/varset BardMez${mezid} ${BardMezTimer${i}.OriginalValue}
				/delay 38
				/return
			}
		}
	/next i
/return

Sub Bard
	/if (!${Target.ID}) /return
	/varset CurrentSub Bard
	/if (${Me.Class.ShortName.NotEqual[BRD]}||${Defined[${Target.ID}TashOrbTimer]} && ${Defined[${Target.ID}SlowTimer]}||${Me.Hovering}) /return
	/if (${Me.Hovering}||${Pulling}) /return
	/if (${UseTashOrb} && !${Defined[${Target.ID}TashOrbTimer]} && !${FindItem[Orb of Tishan].Timer} && ${FindItem[Orb of Tishan].ItemSlot} && ${Target.PctHPs}<=${AssistAt} && ${TarID}==${Target.ID}) {
		/if (${Plugin[MQ2Twist].Name.Length}) /squelch /twist stop
		/delay 2s !${Me.Casting.ID}
		/casting "Orb of Tishan"|item
		/call ${EchoSub} "${DarkYellow} Howl of Tashan ${White} --> ${Target.CleanName}"
		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} Howl of Tashan --> ${Target.CleanName}
		/if (!${Defined[${Target.ID}TashOrbTimer]}) /declare ${Target.ID}TashOrbTimer timer outer 14m
		/delay 35
		/delay !${Me.Casting.ID}
		/if (${Plugin[MQ2Twist].Name.Length}) /squelch /twist start
		/if (!${Melee.Combat}) /call Attacking2
	}
	/doevents
	/if (!${Target.ID}) /return
	/if (${UseSlow} && !${Defined[${Target.ID}SlowTimer]}) {
		/if (!${Me.GemTimer[${SlowName}]} && ${Me.Gem[${SlowName}]} || ${FindItem[${SlowName}].ItemSlot} && !${FindItem[${SlowName}].Timer} && ${Target.PctHPs}<=${AssistAt} && ${TarID} == ${Target.ID}) {
			/if (${Me.Gem[${SlowName}]}) {
				/squelch /twist once ${Me.Gem[${SlowName}]}
				/echo Twist once - ${SlowName}
			}
			/if (${FindItem[${SlowName}].ItemSlot}) {
				/twist stop
				/delay 1s !${Me.Casting.ID}
				/casting "${SlowName}"|item
			}
			/call ${EchoSub} "${DarkYellow} ${SlowName} ${White} --> ${Target.CleanName}"
			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${SlowName} --> ${Target.CleanName}
			/delay 38 !${Me.Casting.ID}
			/squelch /twist start
			/if (!${Defined[${Target.ID}SlowTimer]}) /declare ${Target.ID}SlowTimer timer outer 90s
			/if (!${Melee.Combat}) /call Attacking2
		}
	}
	/doevents
/return
|Bard end

|Buff start
#chat bc
#chat EQBC

#event EQBC                  	"<#1#> #2#"
#event EQBC                   	"[#1#(msg)] #2#"
#event CastSpell  	      	"#1# tells the group#*#, '#2# on #3#'"
#event CastSpell  	      	"#1# tells the group#*#, '#2#'"
#event CastSpell  	      	"#1# tells the fellowship#*#, '#2# on #3#'"
#event CastSpell  	      	"#1# tells the fellowship#*#, '#2#'"
#event CastSpell              	"#1# tells you#*#, '#2# on #3#'"
#event CastSpell              	"#1# tells you#*#, '#2#'"
#event CastSpell              	"#1# told you, '#2#'"
#event CastSpell            	"#1# told you, '#2# on #3#'"
#event InvisOn                  "#*#invison#*#"
#event InvisUndeadOn            "#*#ivuon#*#"
#event InvisOff                 "#*#invisoff#*#"
#event LevitateOn            	"#*#levon#*#"
#event LevitateOff              "#*#levoff#*#"
#event BuffWornOff 		"Your #1# spell has worn off of #2#."

Sub BuffLoad
	/varset CurrentSub Buff
	/if (!${Defined[BuffLoaded]}) /declare BuffLoaded bool outer FALSE
	/if (${BuffLoaded}) /return
	/call Debug 3 "Entering ${CurrentSub}Load"
	/varset BuffLoaded TRUE
	/declare i int local 3
	/declare b int local
	/declare x string local
	
	|** Changed to if/then/else because it can't be all of them. **|
	/if (${Select[${Me.Class.ShortName},SHD,MNK,ROG,BER,WAR,NEC]}) {
		/varset i 1
	} else /if (${Select[${Me.Class.ShortName},SHM,PAL,BST,MAG]}) {
		/varset i 7
	} else 	/if (${Select[${Me.Class.ShortName},RNG,CLR,ENC]}) {
		/varset i 10
	} else /if (${Select[${Me.Class.ShortName},BRD]}) {
		/varset i 1
	}
	
	/if (!${Defined[BuffXTargets]}) /declare BuffXTargets bool outer ${Ini[MyIni,Buff,BuffXTargets,FALSE]}
	/if (!${BuffXTargets}) /mmoini "MyIni" "Buff" "BuffXTargets" "FALSE"
	/if (!${Defined[BuffPets]}) /declare BuffPets bool outer ${Ini[MyIni,Buff,BuffPets,FALSE]}
	/if (!${BuffPets}) /mmoini "MyIni" "Buff" "BuffPets" "FALSE"
	/if (!${Defined[AutoInvis]}) /declare AutoInvis bool outer ${Ini[MyIni,Buff,AutoInvis,FALSE]}
	/if (!${AutoInvis}) /mmoini "MyIni" "Buff" "AutoInvis" "FALSE"
	/if (!${Defined[AutoBreakInvis]}) /declare AutoBreakInvis bool outer ${Ini[MyIni,Buff,AutoBreakInvis,FALSE]}
	/if (!${AutoBreakInvis}) /mmoini "MyIni" "Buff" "AutoBreakInvis" "FALSE"
	
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	
	/if (${NeedLoad} && !${tempsubtotal}) {
		/for b 1 to ${AAInvis.Count[|]} 
			/if (${Me.AltAbility[${AAInvis.Arg[${b},|]}]} && !${Spell[${x}].TargetType.Find[group]}) /varset x ${AAInvis.Arg[${b},|]}
		/next b
		/if (${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisSpell" "${x}"
		/if (${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisSpellGem" "alt"
		/if (!${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisSpell"
		/if (!${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisSpellGem"
		/varset x
		/for b 1 to ${AAInvisUndead.Count[|]} 
			/if (${Me.AltAbility[${AAInvisUndead.Arg[${b},|]}]} && !${Spell[${x}].TargetType.Find[group]}) /varset x ${AAInvisUndead.Arg[${b},|]}
		/next b
		/if (${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisUndeadSpell" "${x}"
		/if (${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisUndeadSpellGem" "alt"
		/if (!${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisUndeadSpell"
		/if (!${x.Length})	/mmoini "MyIni" "${CurrentSub}" "InvisUndeadSpellGem"
		/varset x
		/if (${Defined[AALevitate]}) {
			/for b 1 to ${AALevitate.Count[|]}
				/if (${Me.AltAbility[${AALevitate.Arg[${b},|]}]} && !${Spell[${x}].TargetType.Find[group]}) /varset x ${AALevitate.Arg[${b},|]}
			/next b
		}
		/if (${x.Length})	/mmoini "MyIni" "${CurrentSub}" "LevitateSpell" "${x}"
		/if (${x.Length})	/mmoini "MyIni" "${CurrentSub}" "LevitateSpellGem" "alt"
		/if (!${x.Length})	/mmoini "MyIni" "${CurrentSub}" "LevitateSpell"
		/if (!${x.Length})	/mmoini "MyIni" "${CurrentSub}" "LevitateSpellGem"
		/call SpellLoad "Buff" ${i} "|1|3|4|5|6|25|24|30|" "|0|TRUE|----|----|----|----|BER,BRD,BST,CLR,DRU,ENC,MAG,MNK,NEC,PAL,RNG,ROG,SHD,SHM,WAR,WIZ|TRUE|"
	}

	/call SpellLoad2 "${CurrentSub}" "3|4|5|6|25|24|30|"
	/declare BuffArray[50,2] string outer 0
	/declare BuffQueueString string outer
	/declare BuffTimerString string outer
	/declare MyBuffString string outer
	/declare TargetBuff[45,5] string outer
	/declare TargetBuffCount int outer
	/declare UnknownBuff bool outer
	/declare BuffParsePH string outer
	/declare MyBuffCount int outer


	/declare MyBuff[50,4] string outer
	/for i 1 to ${BuffTotal}
		/declare BuffType${i} string outer
		/if (!${Defined[BuffSpellIcon${i}]}) /declare BuffSpellIcon${i} string outer
		/call BuffParse "${BuffSpellIcon${i}}" ${i}
		/varset BuffQueueString ${BuffQueueString}${BuffSpellIcon${i}}|
	/next i
	
	/if (!${Defined[BuffCheckTimer]}) /declare BuffCheckTimer timer outer 1s
	/if (!${Defined[BuffString1]}) /declare BuffString1 string outer
	/if (!${Defined[BuffString2]}) /declare BuffString2 string outer
	/if (!${Defined[BuffTimerString]}) /declare BuffTimerString string outer
	/if (!${Defined[iTargetBuff]}) /declare iTargetBuff int outer
	/if (!${Defined[InitialBuffList]}) /declare InitialBuffList string outer
	/if (!${Defined[ChatSenderHold]}) /declare ChatSenderHold string outer
	/if (!${Defined[SpellHold]}) /declare SpellHold string outer
	/if (!${Defined[timehold]}) /declare timehold timer outer
	/if (!${Defined[InvisSpell]}) /declare InvisSpell string outer ${Ini[MyIni,${CurrentSub},InvisSpell]}
	/if (!${Defined[InvisSpellGem]}) /declare InvisSpellGem string outer ${Ini[MyIni,${CurrentSub},InvisSpellGem]}
	/if (!${Defined[InvisUndeadSpell]}) /declare InvisUndeadSpell string outer ${Ini[MyIni,${CurrentSub},InvisUndeadSpell]}
	/if (!${Defined[InvisUndeadSpellGem]}) /declare InvisUndeadSpellGem string outer ${Ini[MyIni,${CurrentSub},InvisUndeadSpellGem]}
	/if (!${Defined[LevitateSpell]}) /declare LevitateSpell string outer ${Ini[MyIni,${CurrentSub},LevitateSpell]}
	/if (!${Defined[LevitateSpellGem]}) /declare LevitateSpellGem string outer ${Ini[MyIni,${CurrentSub},LevitateSpellGem]}
	/if (!${Defined[BuffExtension]}) /declare BuffExtension float outer
	
	|** Convert to if else statement, it can't be both, no need to evaluate both every time. Also adjusted for AugSlot2 and Augslot3 to avoid false negative.**|
	|** Was using Depreciated syntax, updated from ${InvSlot[back].AugSlot1} to current **|
	|** There was no base case (IE: You have neither aug slot or no back item. This is what was making the timer 0.) **|
	|** Added a boolean check to see if the back item had a spell on it to avoid a false positive for lower level characters **|
	/if (${Bool[${Me.Inventory[back].Spell}]}) {
		/if (${Me.Inventory[back].AugSlot1} == 7 || ${Me.Inventory[back].AugSlot2} == 7 || ${Me.Inventory[back].AugSlot3} == 7) {
			/varset BuffExtension 1.26
		} else /if (${Me.Inventory[back].AugSlot1} == 8 || ${Me.Inventory[back].AugSlot2} == 8 || ${Me.Inventory[back].AugSlot3} == 8) {
			/varset BuffExtension 1.35
		}
	} else {
		/varset BuffExtension 1
	}
	
	|** Calculate Spell Casting Reinforcement in reverse order in /if then else statements to reduce total needed parses at higher levels **|
	/if (${Me.AltAbility[Spell Casting Reinforcement]}>=28) {
		/varcalc BuffExtension ${BuffExtension}+.20
	} else /if (${Me.AltAbility[Spell Casting Reinforcement]}>=20) {
		/varcalc BuffExtension ${BuffExtension}+.20
	} else /if (${Me.AltAbility[Spell Casting Reinforcement]}>=12) {
		/varcalc BuffExtension ${BuffExtension}+.15
	} else /if (${Me.AltAbility[Spell Casting Reinforcement]}>=6) {
		/varcalc BuffExtension ${BuffExtension}+.10
	} else /if (${Me.AltAbility[Spell Casting Reinforcement]}>=2) {
		/varcalc BuffExtension ${BuffExtension}+.05
	}
	
	/call Debug 3 "Leaving ${CurrentSub}Load"
/return

Sub Buff
	/varset CurrentSub Buff
	/call Debug 3 "Entering Sub ${CurrentSub} The real one."
	/if (!${Defined[${CurrentSub}Loaded]}) {
		/call Debug 3 "${CurrentSub}Loaded not defined, calling BuffLoad"
		/call BuffLoad
	}
	
	/declare i int local
	/declare b int local
	/if (!${BuffTotal}||${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /return
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/for b 1 to ${BuffTotal}
		/if (!${BuffUse${b}}) /goto :skipbuff
		/if (${BuffConditions${b}.NotEqual[123456]}) /varset BuffConditions${b} ${Ini[MyIni,Buff,BuffConditions${b},1]}
		/if (!${Defined[${Me.ID}_Buff${b}]}) /declare ${Me.ID}_Buff${b} timer outer 0
		/if	(!${${Me.ID}_Buff${b}} && ${BuffClasses${b}.Find[${Me.Class.ShortName}]} && (${BuffConditions${b}})) /call BuffQueue ${Me.ID} ${b}
		/if (${BuffPets} && ${Me.Pet.ID} && ${BuffClasses${b}.Find[${Me.Pet.Class.ShortName}]} && ${Spawn[${Me.Pet.ID}].Distance}<=100 && (${BuffConditions${b}})) /call BuffQueue ${Me.Pet.ID} ${b}
		/if (!${Group}) /goto :skipgroup
		/for i 1 to ${Group}
			/if (!${Defined[${Group.Member[${i}].ID}_Buff${b}]}) /declare ${Group.Member[${i}].ID}_Buff${b} timer outer 0
			/if (!${${Group.Member[${i}].ID}_Buff${b}} && ${BuffClasses${b}.Find[${Group.Member[${i}].Class.ShortName}]} && ${Spawn[${Group.Member[${i}].ID}].Distance}<=100 && (${BuffConditions${b}})) /call BuffQueue ${Group.Member[${i}].ID} ${b}
			/if (!${Defined[${Group.Member[${i}].Pet.ID}_Buff${b}]}) /declare ${Group.Member[${i}].Pet.ID}_Buff${b} timer outer 0
			/if (${BuffPets} && !${Group.Member[${i}].Pet.Name.Find[Familiar]} && !${Group.Member[${i}].Pet.Name.Find[_pet]} && ${Group.Member[${i}].Pet.ID} && !${${Group.Member[${i}].Pet.ID}_Buff${b}} && ${BuffClasses${b}.Find[${Group.Member[${i}].Pet.Class.ShortName}]} && ${Spawn[${Group.Member[${i}].Pet.ID}].Distance}<=100 && (${BuffConditions${b}})) /call BuffQueue ${Group.Member[${i}].Pet.ID} ${b}
		/next i

		:skipgroup
		/if (!${BuffConditions${b}}) /goto :skipbuff
		/for i 2 to ${XTarget.Max}
			/if (!${Defined[${Me.XTarget[${i}].ID}_Buff${b}]}) /declare ${Me.XTarget[${i}].ID}_Buff${b} timer outer 0
			/if (${BuffXTargets}) {
				/if (${Me.XTarget[${i}].ID}) {
					/if (!${${Me.XTarget[${i}].ID}_Buff${b}} && (${Select[${Spawn[${Me.XTarget[${i}].ID}].Type},pc,mercenary]}||${Spawn[${Me.XTarget[${i}].ID}].Master.Type.Equal[pc]}) && ${Spawn[${Me.XTarget[${i}].ID}].Distance}<=100 && ${Me.XTarget[${i}].Type.NotEqual[auto hater]} && ${BuffClasses${b}.Find[${Me.XTarget[${i}].Class.ShortName}]} && (${BuffConditions${b}})) /call BuffQueue ${Me.XTarget[${i}].ID} ${b}
				}
			}
		/next i

		:skipbuff
	/next b

	/for i 1 to 50
		/if (!${Defined[${BuffArray[${i},1]}_Buff${BuffArray[${i},2]}]}) /declare ${BuffArray[${i},1]}_Buff${BuffArray[${i},2]} timer outer 0
		/if (${${BuffArray[${i},1]}_Buff${BuffArray[${i},2]}}) {
			/varset BuffArray[${i},1] 0
			/varset BuffArray[${i},2] 0
		}
		/if (${Me.CombatState.Equal[COMBAT]}||${AddCount}) /return
		/if (${Spawn[${BuffArray[${i},1]}].ID} && ${Spawn[${BuffArray[${i},1]}].Distance}<100) {
			/call Debug 3 "/call BuffList "${BuffArray[${i},1]}" "${BuffArray[${i},2]}""
			/call BuffList "${BuffArray[${i},1]}" "${BuffArray[${i},2]}"
		}
	/next i
	/call Debug 3 "Leaving Sub ${CurrentSub}"
/return

Sub BuffList(int TNameID, int iB)
	/varset CurrentSub BuffList
	/call Debug 3 "Entering Sub ${CurrentSub}"
	/call BuffCheck ${TNameID}
	/declare i int local
	/if (${Me.Book[${BuffSpellName${iB}}]} && !${If[${Me.SpellReady[${BuffSpellName${iB}}]},TRUE,FALSE]} && ${BuffSpellGem${iB}.Find[gem]}) {
		/memorize "${BuffSpellName${iB}}" "${BuffSpellGem${iB}}"
		:gemwait
		/doevents
		/if (${Me.CombatState.Equal[COMBAT]}||${AddCount}) /return
		/delay 2
		/if (!${Me.SpellReady[${BuffSpellName${iB}}]}) /goto :gemwait
	}
	/if ((${Me.SpellReady[${BuffSpellName${iB}}]}||${Me.AltAbilityReady[${BuffSpellName${iB}}]}||${FindItem[${BuffSpellName${iB}}].ItemSlot} && !${FindItem[${BuffSpellName${iB}}].Timer}) && !${${TNameID}_Buff${iB}}) {
		/if (${Spawn[id ${TNameID}].Type.Equal[corpse]}) /return
		/if (${Spawn[id ${TNameID}].ID}) /squelch /tar id ${TNameID}
		/delay 1s ${Target.ID}==${TNameID}
		/call ${EchoSub} "${Pink} ${BuffSpellName${iB}} --> ${White} ${Target.CleanName}"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${BuffSpellName${iB}} --> ${Target.CleanName}
		/if (!${Defined[BuffListAnnounce]}) /declare BuffListAnnounce bool outer FALSE
    	/if (${BuffListAnnounce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${BuffSpellName${iB}} --> ${Target.CleanName}
    	/if (${Spell[${BuffSpellName${iB}}].TargetType.Find[group]} && ${Me.AltAbilityReady[Tranquil Blessings]} && (${Me.CombatState.Equal[Active]}||${Me.CombatState.Equal[RESTING]})) /alt act ${Me.AltAbility[Tranquil Blessings].ID}
		/call Cast "${BuffSpellName${iB}}" "${BuffSpellGem${iB}}" 0 CheckStuff NULL
		/delay 30s !${Me.Casting.ID}
		/if (!${Defined[${TNameID}_Buff${iB}]}) {
			/declare ${TNameID}_Buff${iB} timer outer
			/call Debug 3 "Defined a new timer for ${TNameID}_Buff${iB} for ${${TNameID}_Buff${iB}}"
		}
		/if (${Macro.Return.Equal[CAST_NOTHOLD]}||${Macro.Return.Equal[CAST_SUCCESS]}) {
			/if (!${Defined[${TNameID}_Buff${iB}]}) /declare ${TNameID}_Buff${iB} timer outer
			/varset ${TNameID}_Buff${iB} ${Spell[${BuffSpellName${iB}}].Duration.TotalSeconds}s
			|/varset ${TNameID}_Buff${iB} ${Math.Calc[${Spell[${BuffSpellIcon${iB}}].Duration}*60*${BuffExtension}].Int}
			/call Debug 3 "${Math.Calc[${${TNameID}_Buff${iB}}/10/60].Int} Minute timer set."
			/if (${Spell[${BuffSpellName${iB}}].TargetType.Find[group]} && (${SpawnCount[group ${Target.CleanName}]}||!${Target.ID})) {
				/for i 0 to ${Group}
					/if (${Group.Member[${i}].Distance}<${Spell[${BuffSpellName${iB}}].AERange}) {
						/if (!${Defined[${Group.Member[${i}].ID}_Buff${iB}]}) /declare ${Group.Member[${i}].ID}_Buff${iB} timer outer
						/varset ${Group.Member[${i}].ID}_Buff${iB} ${Math.Calc[${Spell[${BuffSpellIcon${iB}}].Duration}*60*${BuffExtension}].Int}
					}
				/next i
			}
		}
		/call Debug 3 "Leaving Sub ${CurrentSub}"
		/call BuffCheck ${TNameID}
	}
/return

Sub BuffQueue(buffid,buffnum)
	/call Debug 3 "Entering Sub BuffQueue"
	/varset CurrentSub BuffQueue
	/if (!${Defined[${buffid}BuffCheck]}) {
		/call Debug 3 "${buffid}BuffCheck undefined, calling BuffCheck on buffid ${buffid}"
		/call BuffCheck ${buffid}
	}
	/call Debug 3 "BuffQueue ${Spawn[${buffid}]} - ${BuffSpellIcon${buffnum}}"
	/declare i int local
	/declare j int local
	
    /for i 1 to 50
		/if (!${Defined[${BuffArray[${i},1]}_${BuffArray[${i},2]}]}) /declare ${BuffArray[${i},1]}_${BuffArray[${i},2]} timer outer 0
		/if (${${BuffArray[${i},1]}_${BuffArray[${i},2]}}) {
			/if (${Defined[${BuffArray[${i},1]}_Buff${BuffArray[${i},2]}]}) {
				/call BuffList ${BuffArray[${i},1]} ${BuffArray[${i},2]}
			}
			/call Debug 3 "BuffQueue Removing ${Spawn[${BuffArray[${i},1]}]} ${BuffSpellName${BuffArray[${i},2]}} from BuffQueue"
			/varset BuffArray[${i},1] 0
			/varset BuffArray[${i},2] 0
		}
		/if (${BuffArray[${i},1].Equal[${buffid}]} && ${BuffArray[${i},2].Equal[${buffnum}]}) /goto :skipq
		/if (${BuffArray[${i},1].Equal[0]} && !${j}) /varset j ${i}
	/next i
	/varset BuffArray[${j},1] ${buffid}
	/varset BuffArray[${j},2] ${buffnum}
	:skipq
	/call Debug 3 "Leaving BuffQueue"
/return

Sub BuffCheck(int iID)
	/call Debug 3 "Entering Sub BuffCheck - iID: ${iID}"
	/call Debug 3 "Checking Buff for ${Spawn[${iID}]}"
	/varset CurrentSub BuffCheck
	/if (!${Defined[${iID}BuffCheck]}) /declare ${iID}BuffCheck int outer 1
	/declare x int local
	/declare t int local
	/declare d int local
	/declare b int local
	/declare q int local
	/declare i int local
	/squelch /tar id ${iID}
	/delay 1s ${Target.ID}==${iID}
	/delay 1s
	/declare z int
	/for z 1 to 45
		/varset TargetBuffCount 0
		/if (${Target.BuffDuration[${z}]}) /call BuffParse "${Target.Buff[${z}].Name.Arg[1,Rk.]}"
		/for q 1 to ${BuffTotal}
			/if (${BuffSpellIcon${q}.Find[${Target.Buff[${z}].Name.Arg[1,Rk.]}]}||${BuffType${q}.Find[${TargetBuff[${x},2]}]}) {
				/if (!${Defined[${iID}_Buff${q}]}) /declare ${iID}_Buff${q} timer outer
				/varset ${iID}_Buff${q} ${Math.Calc[6*${Target.BuffDuration[${z}]}].Int}
			}
		/next q
	/next z
	
	|** I'm trying to wrap my head about this, but I'm not understanding the point of it ~Chatwiththisname~ 
	 ** 40oz: not sure, looks like a way to setup timers to hand out buffs, 
	 **       but if the timer is never set to a time, it will never do anything
	 **|
	/for i 1 to ${BuffTotal}
		/for x 1 to ${BuffType${i}.Count[|]}
			/if (${${Target.ID}BuffString.Find[${BuffType${i}.Arg[${x},|]}]}) /goto :skip 
		/next x
		/if (!${Defined[${Target.ID}_Buff${i}]}) /declare ${Target.ID}_Buff${i} timer outer
		/call Debug 3 "${Target} needs ${BuffSpellIcon${i}}"
		:skip
	/next i
/return

Sub BuffParse(buffname,int mybuff)
	/varset CurrentSub BuffParse
	/call Debug 3 "Entering Sub ${CurrentSub}"
	/declare i int local
	/declare icon int local
	/varset BuffParsePH ${buffname}
	/varset UnknownBuff TRUE
	/if (!${Defined[${Target.ID}BuffString]}) /declare ${Target.ID}BuffString string outer
	/if (${Spell[${buffname}].Slot[1].Find[Increase Max Hitpoints]}) /call BuffArray Shielding ${Spell[${buffname}].Icon} 1 ${mybuff}
	/if (${Spell[${buffname}].Slot[2].Find[Increase Max Hitpoints]}) /call BuffArray ACHP ${Spell[${buffname}].Icon} 2 ${mybuff} 
	/if (${Spell[${buffname}].Slot[3].Find[Increase Max Hitpoints]}) /call BuffArray Symbol ${Spell[${buffname}].Icon} 3 ${mybuff} 
	/if (${Spell[${buffname}].Slot[4].Find[Increase Max Hitpoints]}) /call BuffArray HybridHP ${Spell[${buffname}].Icon} 4 ${mybuff} 
	/if (${Spell[${buffname}].Slot[5].Find[Increase Attack Speed]}) /call BuffArray Haste ${Spell[${buffname}].Icon} 2 ${mybuff} 
	/if (${Spell[${buffname}].Slot[1].Find[Increase Attack Speed]}) /call BuffArray Haste2 ${Spell[${buffname}].Icon} 1 ${mybuff} 
	/if (${Spell[${buffname}].Slot[2].Find[Increase Mana by]}) /call BuffArray Clarity ${Spell[${buffname}].Icon} 2 ${mybuff}
	/if (${Spell[${buffname}].Slot[1].Find[Increase Hitpoints by]} && ${Spell[${buffname}].Slot[1].Find[per tick]}) /call BuffArray Regen ${Spell[${buffname}].Icon} 1 ${mybuff}
	/if (${Spell[${buffname}].Slot[2].Find[Increase ATK by ]}) /call BuffArray Attack ${Spell[${buffname}].Icon} 2 ${mybuff}
	/if (${Spell[${buffname}].Slot[2].Find[Increase AC by ]}) /call BuffArray AC1 ${Spell[${buffname}].Icon} 2 ${mybuff}	
	/if (${Spell[${buffname}].Slot[3].Find[Increase AC by ]}) /call BuffArray AC2 ${Spell[${buffname}].Icon} 3 ${mybuff}
	/if (${Spell[${buffname}].Slot[1].Find[Increase Damage Shield by ]}) /call BuffArray DS1 ${Spell[${buffname}].Icon} 1 ${mybuff}
	/if (${Spell[${buffname}].Slot[2].Find[Increase Damage Shield by ]}) /call BuffArray DS2 ${Spell[${buffname}].Icon} 2 ${mybuff}
	/if (${Spell[${buffname}].Slot[1].Find[Mitigate Melee Damage by ]}) /call BuffArray Mitigate ${Spell[${buffname}].Icon} 1 ${mybuff}
	/if (${UnknownBuff} && ${mybuff}) /call BuffArray Unknown ${Spell[${buffname}].Icon} 0 ${mybuff}
/return

Sub BuffArray(buffarrayname,int buffarrayicon,int buffarrayslot,int myarraybuff)
	/varset CurrentSub BuffArray
	/call Debug 3 "Entering Sub ${CurrentSub}"
	/varset UnknownBuff FALSE
	/if (!${myarraybuff}) {
		/if (!${Defined[${Target.ID}_${Spell[${BuffParsePH}].ID}]}) /declare ${Target.ID}_${Spell[${BuffParsePH}].ID} string outer
		/varset ${Target.ID}_${Spell[${BuffParsePH}].ID} ${${Target.ID}_${Spell[${BuffParsePH}].ID}}${buffarrayname}|
		/varset ${Target.ID}BuffString ${${Target.ID}BuffString}${buffarrayname}|
		/varcalc TargetBuffCount ${TargetBuffCount}+1
		/varset TargetBuff[${TargetBuffCount},1] ${Target.CleanName}
		/varset TargetBuff[${TargetBuffCount},2] ${buffarrayname}
		/varset TargetBuff[${TargetBuffCount},3] ${buffarrayicon}
		/varset TargetBuff[${TargetBuffCount},4] ${buffarrayslot}
		/varset TargetBuff[${TargetBuffCount},5] ${BuffParsePH}
	}

	/if (${myarraybuff}) {
		/varset MyBuffString ${MyBuffString}${buffarrayname}|
		/varcalc MyBuffCount ${MyBuffCount}+1
		/varset MyBuff[${MyBuffCount},1] ${BuffSpellIcon${myarraybuff}}
		/varset MyBuff[${MyBuffCount},2] ${buffarrayname}
		/varset MyBuff[${MyBuffCount},3] ${buffarrayicon}
		/varset MyBuff[${MyBuffCount},4] ${buffarrayslot}
		/varset BuffType${myarraybuff} ${BuffType${myarraybuff}}${buffarrayname}|
	}
/return

Sub Event_BuffWornOff(Line,string SpellWornOff,string ChatSender)
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
   	/varset ChatSenderHold ${Spawn[${ChatSender}].CleanName.Replace[ ,]}
   	/varset SpellHold ${SpellWornOff}
   	/declare b int local
   	/declare bf int local
   	/for b 1 to ${BuffTotal}
		/if (!${Defined[BuffSpellName${b}]}) /continue
  		/if (${SpellHold.Find[${BuffSpellIcon${b}}]}||${SpellHold.Find[${BuffSpellName${b}}]}) {
			/varset bf ${b}
			/goto :buffdetected
		}
	/next b
   	/if (!${bf}) /return

   	:buffdetected
   	/if (!${Defined[${Spawn[${ChatSender}].ID}_Buff${bf}]}) /declare ${Spawn[${ChatSender}].ID}_Buff${bf} timer outer
   	/varset ${Spawn[${ChatSender}].ID}_Buff${bf} 0
/return

Sub Event_EQBC(EQBCSay,EQBCSender,EQBCCommand)
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
  	/if (${EQBCCommand.Left[2].Equal[//]}) /return
  	/if (${EQBCCommand.Left[1].Equal[/]}) {
    	/docommand ${EQBCCommand}
  	} else {
    	/call Event_Chat "EQBC" "${EQBCSender}" "${EQBCCommand}"
  	}
/return

Sub Event_CastSpell(string line,string ChatSender,string SName,string TName)
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
	/varset ChatSenderHold ${ChatSender}
 	/if (${ChatSender.Left[1].Compare[ ]} < 0) /varset ChatSenderHold ${ChatSender.Right[-2].Left[-1]}
	/if (!${AuthorizedUsers.Find[${ChatSenderHold}]} && ${AuthorizedUsers.NotEqual[NULL]} && !${Select[${Spawn[${ChatSender}].Type},mercenary,pet]}) {
		/echo ${ChatSender} not found on [Settings] AuthorizedUsers list. Ignoring request.
		/return
	}
	/if (${SName.Equal[ivuon]}) {
		/call Event_InvisUndeadOn
		/return
	}
	/if (${SName.Equal[invison]}) {
		/call Event_InvisOn
		/return
	}
	/if (${SName.Equal[invisoff]}) {
		/call Event_InvisOff
		/return
	}
	/if (${SName.Equal[levon]}) {
		/call Event_LevitateOn
		/return
	}
	/if (${SName.Equal[levoff]}) {
		/call Event_LevitateOff
		/return
	}
	/if (${SName.Equal[${MoveUpCommand}]}) {
		/call Event_Follow "${ChatSenderHold}" "1"
		/return
	}
	/if (${SName.Equal[${StopFollowCommand}]}) {
		/call Event_StopFollow "${ChatSenderHold}"
		/return
	}
	/if (${SName.Equal[${FollowCommand}]}) {
		/call Event_Follow "${ChatSenderHold}" "0"
		/return
	}

	/declare b int local
	/for b 1 to ${BuffTotal}
		/if (!${Defined[BuffAlias${b}]}) /declare BuffAlias${b} ${Ini[MyIni,Buff,BuffAlias${b},12345]}
		/if (${BuffAlias${b}.Find[|${SName}|]}) {
			/if (${TName.Length}) {
				/if (${SpawnCount[pc ${TName}]}) /call BuffList "${Spawn[pc ${TName}].ID}" "${b}"
				/if (!${SpawnCount[pc ${TName}]}) /call BuffList "${Spawn[${TName}].ID}" "${b}"
			} else {
				/if (!${line.Find[ on ]}) {
					/if (${SpawnCount[pc ${ChatSenderHold}]}) /call BuffList "${Spawn[pc ${ChatSenderHold}].ID}" "${b}"
					/if (!${SpawnCount[pc ${ChatSenderHold}]}) /call BuffList "${Spawn[${ChatSenderHold}].ID}" "${b}"
				}
				/if (${SpawnCount[pc ${ChatSenderHold}]}) /call BuffCheck ${Spawn[pc ${ChatSenderHold}].ID}
				/if (!${SpawnCount[pc ${ChatSenderHold}]}) /call BuffCheck ${Spawn[${ChatSenderHold}].ID}
			}
		}
	/next b

/return

Sub Event_InvisOn
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
  	/if (${Me.Book[${InvisSpell}]} || ${InvisSpellGem.Equal[alt]} && ${Me.AltAbilityReady[${InvisSpell}]} || ${InvisSpellGem.Equal[item]} && !${FindItem[${InvisSpell}].Timer}) {
  		/if (${Spell[${InvisSpell}].TargetType.Equal[Single]}) {
			/squelch /target myself
  			/delay 3s ${Target.ID}==${Me.ID}
  		}

		/if (${InvisSpellGem.Equal[alt]}) /alt act ${Me.AltAbility[${InvisSpell}].ID}
  	  	/if (!${InvisSpellGem.Equal[alt]}) /call Cast "${InvisSpell}" ${InvisSpellGem} 5s NULL NULL
  	  	/delay 5
  	}
/return

Sub Event_InvisUndeadOn
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
  	/if (${Me.Book[${InvisUndeadSpell}]} || ${InvisUndeadSpellGem.Equal[alt]} && ${Me.AltAbilityReady[${InvisUndeadSpell}]} || ${InvisUndeadSpellGem.Equal[item]} && !${FindItem[${InvisUndeadSpell}].Timer}) {
  		/if (${Spell[${InvisUndeadSpell}].TargetType.Equal[Single]}) {
			/squelch /target myself
  			/delay 3s ${Target.ID}==${Me.ID}
  		}

		/if (${InvisUndeadSpellGem.Equal[alt]}) /alt act ${Me.AltAbility[${InvisUndeadSpell}].ID}
  	  	/if (!${InvisUndeadSpellGem.Equal[alt]}) /call Cast "${InvisUndeadSpell}" ${InvisUndeadSpellGem} 5s NULL NULL
  	  	/delay 5
  	}
/return

Sub Event_InvisOff
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
    /declare invisid int local
    /if (${Target.ID}) /varset invisid ${Target.ID}
    /squelch /tar clear
    /squelch /attack on
    /delay 1
    /squelch /attack off
    /if (${invisid} && ${Spawn[${invisid}.Type.NotEqual[corpse]}) /squelch /tar id ${invisid}
    /if (${Me.Buff[Shared Camouflage].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Shared Camouflage].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Sun Cloak].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Sun Cloak].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Sunskin].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Sunskin].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Fool the Fallen].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Fool the Fallen].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Cloud of Indifference].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Cloud of Indifference].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Perfected Invisibility].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Perfected Invisibility].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Perfected Invisibility to Undead].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Perfected Invisibility to Undead].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Group Perfected Invisibility].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Group Perfected Invisibility].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Group Perfected Invisibility to Undead].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Group Perfected Invisibility to Undead].ID}-1].Int} leftmouseup
    /if (${Me.Buff[${InvisSpell}].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[${InvisSpell}].ID}-1].Int} leftmouseup
    /if (${Me.Buff[${InvisUndeadSpell}].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[${InvisSpell}].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Group Silent Presence].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Group Silent Presence].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Silent Presence].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Silent Presence].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Cloak of Shadows].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Cloak of Shadows].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Invisibility of Group Spirit Walk].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Invisibility of Group Spirit Walk].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Invisibility of Spirit Walk].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Invisibility of Spirit Walk].ID}-1].Int} leftmouseup
    /if (${Me.Buff[Shauri's Sonorous Clouding].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Shauri's Sonorous Clouding].ID}-1].Int} leftmouseup
/return

Sub Event_LevitateOn
  	/if (${Me.Book[${LevitateSpell}]} || ${LevitateSpellGem.Equal[alt]} && ${Me.AltAbilityReady[${LevitateSpell}]} || ${LevitateSpellGem.Equal[item]} && !${FindItem[${LevitateSpell}].Timer}) {
		/if (${Spell[${LevitateSpell}].TargetType.Equal[Single]}) {
			/squelch /target myself
			/delay 3s ${Target.ID}==${Me.ID}
		}

		/if (${LevitateSpellGem.Equal[alt]}) /alt act ${Me.AltAbility[${LevitateSpell}].ID}
		/if (!${LevitateSpellGem.Equal[alt]}) /call Cast "${LevitateSpell}" ${LevitateSpellGem} 5s NULL NULL
		/delay 5
  	}
/return

Sub Event_LevitateOff
  	/if (${Me.Buff[Flight of Eagles].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Flight of Eagles].ID}-1].Int} leftmouseup
  	/if (${Me.Buff[Spirit of Eagle].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Spirit of Eagle].ID}-1].Int} leftmouseup
  	/if (${Me.Buff[Levitation].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Levitation].ID}-1].Int} leftmouseup
  	/if (${Me.Buff[Dead Man Floating].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Dead Man Floating].ID}-1].Int} leftmouseup
  	/if (${Me.Buff[Perfect Dead Man Floating].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Perfected Dead Man Floating].ID}-1].Int} leftmouseup
  	/if (${Me.Buff[Perfected Levitation].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Perfected Levitation].ID}-1].Int} leftmouseup
	/if (${Me.Buff[Group Perfected Levitation].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[Group Perfected Levitation].ID}-1].Int} leftmouseup
	/if (${Me.Buff[${LevitateSpell}].ID}) /nomodkey /notify BuffWindow Buff${Math.Calc[${Me.Buff[${LevitateSpell}].ID}-1].Int} leftmouseup
/return

Sub Event_Chat(string ChatType,string ChatSender,string ChatText)
	/if (!${Defined[BuffLoaded]}) /call BuffLoad
  	/declare b int local
  	/declare i int local
	/varset ChatSenderHold ${ChatSender}
	/if (${ChatSender.Left[1].Compare[ ]} < 0) /varset ChatSenderHold ${ChatSender.Right[-2].Left[-1]}
	/if (!${AuthorizedUsers.Find[${ChatSenderHold}]} && ${AuthorizedUsers.NotEqual[NULL]} && !${Select[${Spawn[${ChatSender}].Type},mercenary,pet]}) {
		/echo ${ChatSender} not found on [Settings] AuthorizedUsers list. Ignoring request.
		/return
	}
  	/if (${ChatText.Equal[${MoveUpCommand}]}) {
		/call Event_Follow "${ChatSender}" "1"
		/return
	}
  	/if (${ChatText.Equal[${FollowCommand}]}) {
		/call Event_Follow "${ChatSender}" "0"
		/return
	}
	/if (${ChatText.Equal[${StopFollowCommand}]}) {
		/call Event_StopFollow "${ChatSender}"
		/return
	}

  	/if (!${Spawn[pc ${ChatSender}].ID}) {
		/return
	}
  	/if (${BuffTotal} && ${ChatSender.NotEqual[${Me.CleanName}]} && ${Spawn[pc ${ChatSender}].ID}) {
    	/for b 1 to ${BuffTotal}
        	/if (${BuffAlias${b}.Find[${ChatText}]}) {
            	/call BuffList "${Spawn[pc ${ChatSender}].ID}" "${b}"
         	}
    	/next b
    }
/return

|Buff end

|camp start

#event AnchorMe "#*#AnchorMe#*#"

Sub CampLoad
	/varset CurrentSub Camp
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare XLOC int outer ${Me.X} 
	/declare YLOC int outer ${Me.Y}
	/declare ZLOC int outer ${Me.Z}
	/declare MyHeading int outer ${Me.Heading.DegreesCCW}
	/declare Camp_Zone int outer ${Zone.ID}
	/declare UseCamp bool outer ${Ini[MyIni,Settings,UseCamp,FALSE]}
	/declare CampRadius int outer ${Ini[MyIni,Settings,CampRadius]}
	/declare CampRadiusMax int outer ${Ini[MyIni,Settings,CampRadiusMax,150]}
	/if (${NeedLoad} && !${UseCamp} && !${CampRadius}) {
		/mmoini "MyIni" "Settings" "UseCamp" "TRUE"
		/mmoini "MyIni" "Settings" "CampRadius" "30"
		/mmoini "MyIni" "Settings" "CampRadiusMax" "150"
		/echo UseCamp loaded to MyIni 
	}
/return

Sub HitObstacle(int strafetime)
	/if (${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}) {
		/keypress back
		/call ReturnCamp
		/goto :skip1
	}
	/if (${Navigation}) {
		/if (${Navigation.Active}) /return
	}
	|/echo Obstacle hit, moving around it... 
	/keypress forward 
	/keypress back hold 
	/delay 3 
	/keypress back 
	/if (${Math.Rand[2]}) { 
		/keypress strafe_right hold 
	} else { 
		/keypress strafe_left hold 
	} 
	/if (${Me.CombatState.Equal[COMBAT]}||${Me.XTarget}) {
		/keypress back
		/call ReturnCamp
		/goto :skip1
	}
	/delay ${If[${strafetime},${strafetime},5]}
	/keypress strafe_right 
	/keypress strafe_left 
	/keypress forward hold 
	:skip1
/return

#event CannotSeeTarget "You cannot see your target."

Sub Event_CannotSeeTarget
	/if (${Pulling}) {
		/if (${Me.Pet.ID}) /pet attack
		/keypress forward hold
		/delay 5
		/keypress forward
		/call HitObstacle 5
		|/call MoveToLoc ${Target.Y} ${Target.X}
	}
/return

Sub MoveToLoc(MoveToY, MoveToX) 
   	/if (!${Defined[CampLoaded]}) /call CampLoad
   	/doevents
   	/declare running int local 
   	/declare distanceNow float local 
   	/declare distanceBefore float local 
   	/declare distanceModifier int local 
   	/declare distanceTimer timer local 25 
   	/varset running 0 
   	/varset distanceBefore ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]} 
   	/varset distanceModifier 1 
	|   /echo Moving to Location: ${MoveToY}, ${MoveToX}. 
	|   /echo Distance: ${distanceBefore} 
   	:moveToLocation  
    /face loc ${MoveToY},${MoveToX} 
    /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}<10) { 
    	/keypress forward 
		|/face heading ${MyHeading}
		/keypress home
        /return 
    } 
    /if (${distanceTimer}==0) { 
		/varset distanceModifier 5
		/if (${Me.Sneaking})  	/varset distanceModifier 10
		/if (${Me.FeetWet}) 	/varset distanceModifier 20  
		/varset distanceNow ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]} 
		/if (${Math.Calc[${distanceBefore}-${distanceNow}]}<${Math.Calc[50/${distanceModifier}]}) { 
			/call HitObstacle 
		} 
		/varset distanceBefore ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]} 
		/varset distanceTimer 25 
	} 
	/if (${running}==0) { 
        /keypress forward 
        /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}>10) { 
        	/varset running 1 
            /keypress forward hold 
        } 
    } else { 
    	/if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}<11) { 
        	/varset running 0 
            /keypress forward 
        } 
    }
    /if (${Target.ID}==${MoveID} && ${Target.ID}) /face 
    /goto :moveToLocation 
/return

Sub Event_AnchorMe
	/varset XLOC ${Int[${Me.X}]}
	/varset YLOC ${Int[${Me.Y}]}
	/varset ZLOC ${Int[${Me.Z}]}
	/varset Camp_Zone ${Zone.ID}
	/echo New Camp: X: ${XLOC}  - Y: ${YLOC} - Z: ${ZLOC}
	/campon
/return

|camp end

|campfire start

Sub CampfireLoad
	/if (!${Defined[CampfireLoaded]}) /declare CampfireLoaded bool outer FALSE
	/if (${CampfireLoaded}) /return
	/varset CampfireLoaded TRUE
	/if (${Me.HaveExpansion[Prophecy of Ro]}) /blockspell add me 7618
	/if (!${Defined[CampfireLoaded]}) /declare CampfireLoaded int outer 1
	/if (!${Defined[AutoUseCampfire]}) /declare AutoUseCampfire bool outer ${Ini[MyIni,Campfire,AutoUseCampfire,FALSE]}
	/if (!${AutoUseCampfire}) 	/mmoini "MyIni" "Campfire" "AutoUseCampfire"
	/declare SetCampfire bool outer ${Ini[MyIni,Campfire,SetCampfire,FALSE]}
	/if (!${SetCampfire}) 	/mmoini "MyIni" "Campfire" "SetCampfire"
	/declare CampfireName string outer ${Ini[MyIni,Campfire,CampfireName,NULL]}
	/if (${CampfireName.Equal[NULL]}) 	/mmoini "MyIni" "Campfire" "CampfireName"
	/declare CF_Item1 string outer ${Ini[MyIni,Campfire,CF_Item1,Fellowship Kit:]}
	/if (${CF_Item1.Equal[Fellowship Kit:]})		/mmoini "MyIni" "Campfire" "CF_Item1" "Fellowship Kit: "
	/declare CF_Item2 string outer ${Ini[MyIni,Campfire,CF_Item2,Fellowship Lumber Bundle:]}
	/if (${CF_Item2.Equal[Fellowship Lumber Bundle:]}) 	/mmoini "MyIni" "Campfire" "CF_Item2" "Fellowship Lumber Bundle: "
/return

Sub Campfire
	/if (${Me.Hovering}) /return
	/if (!${Defined[CampfireLoaded]}) /call CampfireLoad
	/varset CurrentSub Campfire
	/if (!${Me.Fellowship.Campfire} && ${SetCampfire}) {
	/declare i int local
	/declare campcalc int local
	/for i 1 to ${Me.Fellowship.Members}
		/if (${SpawnCount[${Me.Fellowship.Member[${i}]} radius 50]}) /varcalc campcalc ${campcalc}+1
	/next i

	/if (${campcalc}>2) {

		/nomodkey /notify FP_CampPage FP_RefreshList leftmouseup
		/delay 4

		/if (${FindItem[${CF_Item1}].ItemSlot} && ${FindItem[${CF_Item2}].ItemSlot}) {

			/for i 1 to 12
				/if (!${Window[FP_CampPage].Child[FP_CampsiteKitList].List[1,2].Equal[Fellowship Of Honor]}) {
					/nomodkey /notify FP_CampPage FP_RefreshList leftmouseup
					/delay 1s 
				}
 				/if (${CampfireName.Equal[${Window[FP_CampPage].Child[FP_CampsiteKitList].List[${i},2]}]}) {
					/if (!${Window[FP_CampPage].Child[FP_CampsiteKitList].List[1,2].Equal[Fellowship of Honor]}) /nomodkey /notify FP_CampPage FP_RefreshList leftmouseup
					/nomodkey /notify FP_CampPage FP_CampsiteKitList listselect ${i}
					/delay 2s
					/nomodkey /notify FP_CampPage FP_CreateCampsite leftmouseup
				}
			/next i
		}

		/if (!${FindItem[${CF_Item1}].ItemSlot}||!${FindItem[${CF_Item2}].ItemSlot} && !${Me.Fellowship.Campfire}) {
			/if (!${Window[FP_CampPage].Child[FP_CampsiteKitList].List[1,2].Equal[Fellowship Of Honor]}) {
				/nomodkey /notify FP_CampPage FP_RefreshList leftmouseup
				/delay 1s 
			}			
			/nomodkey /notify FP_CampPage FP_CampsiteKitList listselect 1
			/delay 2s
			/nomodkey /notify FP_CampPage FP_CreateCampsite leftmouseup
		}
	}
/return

Sub AutoUseCampfire
	/if (${Me.Fellowship.Campfire} & ${Select[${Zone.ID},344,202,151,345]} && ${AutoUseCampfire} && ${Select[${Me.CombatState.Equal},RESTING,ACTIVE]} && ${If[(${Me.Buff[Revival Sickness].ID}||${Me.Buff[Resurrection Sickness].ID}),1,0]}) {
		/if (${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=Fellowship Registration Insignia].ItemSlot} ${FindItem[=Fellowship Registration Insignia].ItemSlot2}
		/if (!${Me.HaveExpansion[Veil of Alaris]}) /casting "Fellowship Registration Insignia"|item
	}
/return

|campfire end

|Checkstuff start
Sub CheckStuff
	/if (!${Defined[CheckStuffHold]}) /declare CheckStuffHold string outer
	/varset CheckStuffHold ${CurrentSub}
	/if (!${OptionsCheck.Find[|Heal|]} && !${OptionsCheck.Find[XHeal]}) /goto :lifetap
	/declare z int local
	/declare y int local
	/declare t int local
	/declare stop int local
    /for z 0 to 5
		/if (${Group.Member[${z}].ID} && ${Range.Between[1,${InterruptToHealAt}:${Group.Member[${z}].PctHPs}]} && ${OptionsCheck.Find[|Heal]}) {
			/for y 1 to 5
				/for t 1 to ${${Heals.Arg[${y},|]}Total}
					/if (!${Defined[${Heals.Arg[${y},|]}Recast${t}]}) /declare ${Heals.Arg[${y},|]}Recast${t} int outer 1
					/if (${${Heals.Arg[${y},|]}Use${t}} && !${${Heals.Arg[${y},|]}Recast${t}} && (${Me.SpellReady[${${Heals.Arg[${y},|]}SpellName${t}}]}||${Me.AltAbilityReady[${${Heals.Arg[${y},|]}SpellName${t}}]}||${FindItem[${${Heals.Arg[${y},|]}SpellName${t}}].ItemSlot} && !${FindItem[${${Heals.Arg[${y},|]}SpellName${t}}].Timer})) {
						/call Interrupt
						/call Heal
						/goto :skipcheck	
					}
				/next t
			/next y
		}
   	/next z

	/if (${Select[${Me.Class.ShortName},BST,MAG,SHM,NEC,]}) {
		/if (!${Me.Pet.Following.ID} && ${Me.Pet.ID} && ${Target.ID} && ${Target.PctHPs}<=${PetAttackAt} && ${Target.ID}==${TarID} && ${Target.Distance}<=${AttackRange}) /pet attack
	}
	
	/if (${XTarget.Max} && ${XHealTotal}) {
    	/for z 2 to ${XTarget.Max}
			/if (${XHealTotal} && !${Me.XTarget[${z}].TargetType.Equal[Auto Hater]} && ${Select[${Spawn[id ${Me.XTarget[${z}].ID}].Type},pet,pc,mercenary]} && ${Me.XTarget[${z}].ID} && ${Range.Between[1,${InterruptToXHealAt}:${Spawn[${Me.XTarget[${z}].ID}].PctHPs}]} && ${OptionsCheck.Find[XHeal]}) {
				/for t 1 to ${XHealTotal}
					/if (${XHealUse${t}} && !${XHealRecast${t}} && (${Me.SpellReady[${XHealSpellName${t}}]}||${Me.AltAbilityReady[${XHealSpellName${t}}]}||${FindItem[${XHealSpellName${t}}].ItemSlot} && !${FindItem[${XHealSpellName${t}}].Timer})) {
						/call Interrupt
						/call XHeal
						/goto :skipcheck
					}
				/next t
			}
   		/next z
	}

	:lifetap
	/if (!${OptionsCheck.Find[Lifetap]}) /goto :skipcheck
	/if (${Defined[LifeTapTotal]} && ${Range.Between[1,${InterruptToLifetapAt}:${Me.PctHPs}]} && ${OptionsCheck.Find[|Lifetap|]}) {
		/if (${LifeTapTotal}) {
			/for t 1 to ${LifetapTotal}
				/if (${LifetapUse${t}} && !${LifetapRecast${t}} && (${Me.SpellReady[${LifetapSpellName${t}}]}||${Me.AltAbilityReady[${LifetapSpellName${t}}]}||${FindItem[${LifetapSpellName${t}}].ItemSlot} && !${FindItem[${LifetapSpellName${t}}].Timer})) {
					/call Interrupt
					/call Lifetap
					/break
				}
			/next t
		}
	}
	:skipcheck
	/varset CurrentSub ${CheckStuffHold}
/return

|checkstuff end

|clickymaintenance start

#event InDoors         		"#*#You can only cast this spell in the outdoors#*#"
#event InDoors         		"#*#This spell does not work here#*#"
#event InDoors				"#*#You are already on a mount#*#"
#event InDoors         		"#*#You can not summon a mount here#*#"

#event additem "#*#Add Clicky #0#"
#event removeitem "#*#Remove Clicky #0#"
#event ClickyToggle "#*#ClickyToggle#*#"

Sub Event_InDoors
	/if (!${Defined[Outside]}) /declare Outside bool outer
   	/varset Outside FALSE
   	/echo Inside. No mounts allowed.
/return

Sub ClickyMaintenanceLoad
	/if (!${Defined[ClickyMaintenanceLoaded]}) /declare ClickyMaintenanceLoaded bool outer FALSE
	/if (${ClickyMaintenanceLoaded}) /return
	/varset ClickyMaintenanceLoaded TRUE
	/if (!${Defined[clickies]}) {
		/if (${Plugin[MQ2Cast].Name.Length}) {
			/declare casttype int outer 1
		} else {
			/declare casttype int outer 0
		}
		/declare clickies int outer ${Ini[MyIni,ClickyMaintenance,clickies,0]}
		/if (!${clickies}) /mmoini "MyIni" "ClickyMaintenance" "clickies" "0"
		/declare doclickies int outer ${Ini[MyIni,ClickyMaintenance,doclickies,0]}
	}
/return

Sub ClickyMaintenance
	/if (${Me.Hovering}||!${MMOBugs.FreeBuffs}) /return
	/if (!${Defined[ClickyMaintenanceLoaded]}) /call ClickyMaintenanceLoad
	/varset CurrentSub ClickyMaintenance
	/declare temp int local
	/declare loopid int local

	/if (${clickies}) {
		/for temp 1 to ${clickies}
			/if (${Ini[MyIni,ClickyMaintenance,click${temp}].Length} && !${Defined[click${temp}]}) /declare click${temp} string outer ${Ini[MyIni,ClickyMaintenance,click${temp}]}
		/next temp
	}

	/doevents
	/delay 1
	/if (${Me.Moving} && ${Me.Class.ShortName.NotEqual[BRD]} || ${Me.Invis} && !${AutoBreakInvis} && !${AutoInvis} || ${Me.Stunned} || ${Me.Sitting} || ${Me.Ducking} || !${clickies} || !${doclickies}||!${MMOBugs.FreeBuffs}) /return
	/for loopid 1 to ${clickies}
		:topclickloop
		/if (!${Me.Buff[${FindItem[${click${loopid}}].Spell}].ID} && ${FindItem[${click${loopid}}].Spell.Stacks} && (${Outside}||!${FindItem[${click${loopid}}].Spell.Slot[1].Find[Summon]})) {
			/if (${Plugin[MQ2Twist].Name.Length}) {
				/if (${Twist.Twisting} && ${Me.Class.ShortName.Equal[BRD]}) {
					/declare temptwist bool local TRUE
					/twist stop
					/delay 1s !${Me.Casting.ID}
				}
			}
			/if (${casttype} && ${FindItem[${click${loopid}}].EffectType.Equal[Click Worn]}||!${Me.HaveExpansion[Veil of Alaris]}) /casting "${click${loopid}}"|item
			/if (${casttype} && ${FindItem[${click${loopid}}].EffectType.NotEqual[Click Worn]} && ${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=${click${loopid}}].ItemSlot} ${FindItem[=${click${loopid}}].ItemSlot2}
			/delay 1s ${Me.Casting.ID}
			/delay 10s !${Me.Casting.ID}
			/if (${temptwist}) /twist start
		}
		|/if (${casttype}) /casting "${click${loopid}}"|item
		|/if (!${casttype}) /call Cast "${click${loopid}}" item NULL NULL NULL
		/goto :bottomloop
	
		/if (${Me.Buff[${FindItem[${click${loopid}}].Spell}].ID} && ${Me.Buff[${FindItem[${click${loopid}}].Spell}].Duration}<5 && (!${Outside}||!${FindItem[${click${loopid}}].Spell.Slot[1].Find[Summon]})) {
			/if (${Plugin[MQ2Twist].Name.Length}) {
				/if (${Twist.Twisting} && ${Me.Class.ShortName.Equal[BRD]}) {
					/declare temptwist bool local TRUE
					/twist stop
					/delay 1s !${Me.Casting.ID}
				}
			}
			/if (${casttype} && ${FindItem[${click${loopid}}].EffectType.Equal[Click Worn]}||!${Me.HaveExpansion[Veil of Alaris]}||${Me.Subscription.NotEqual[GOLD]}) /casting "${click${loopid}}"|item
			/if (${casttype} && ${FindItem[${click${loopid}}].EffectType.NotEqual[Click Worn]} && ${Me.HaveExpansion[Veil of Alaris]} && (${Me.Subscription.Equal[GOLD]}||${FindItem[=${click${loopid}}].InvSlot}<33)) /useitem ${FindItem[=${click${loopid}}].ItemSlot} ${FindItem[=${click${loopid}}].ItemSlot2}
			/delay 1s ${Me.Casting.ID}
			/delay 10s !${Me.Casting.ID}
			/if (${temptwist}) /twist start
			|/if (${casttype}) /useitem ${FindItem[=${click${loopid}}].ItemSlot} ${FindItem[=${click${loopid}}].ItemSlot2}
			|/if (!${casttype}) /call Cast "${click${loopid}}" item NULL NULL NULL
			/goto :bottomloop
		}
	
		:bottomloop
		/delay 1
		/if (${Me.Casting.ID} && ${Me.Casting.ID}==${Spell[${FindItem[${click${loopid}}].Spell}].ID}) /goto :bottomloop
	/next loopid
/return

Sub Event_additem(string itemtoadd)
	/if (!${Defined[ClickyMaintenanceLoaded]}) /call ClickyMaintenanceLoad
    /varcalc clickies ${clickies}+1
    /varset itemtoadd ${itemtoadd.Right[-57]}
    /varset itemtoadd ${itemtoadd.Left[-1]}
    /mmoini "MyIni" "ClickyMaintenance" "click${clickies}" "${itemtoadd}"
    /mmoini "MyIni" "ClickyMaintenance" "clickies" "${clickies}"
	/if (!${Defined[click${clickies}]}) /declare click${clickies} string outer
	/varset click${clickies} ${itemtoadd}
    /echo Item Added ${itemtoadd}.
/return

Sub Event_removeitem(string itemtoremove)
	/if (!${Defined[ClickyMaintenanceLoaded]}) /call ClickyMaintenanceLoad
    /varset itemtoremove ${itemtoremove.Right[-57]}
    /varset itemtoremove ${itemtoremove.Left[-1]}
    /declare temp int local
    /declare remove int local
    /declare temp1 int local
    /for temp 1 to ${clickies}
    	/if (${click${temp}.Equal[${itemtoremove}]}) /goto :found
    /next temp
	/echo ${itemtoremove} not found.
	/return

	|TODO: This looks like dead code, but isn't because goto's suck
    :found
    /varset remove ${temp}
    /for temp 1 to ${clickies}
    	/varcalc temp1 ${temp}+1
        /if (${temp}>=${remove}) {
        	/varset click${temp} ${click${temp1}}
            /mmoini "MyIni" "ClickyMaintenance" "click${temp}" "${click${temp}}"
        }
    /next temp
	
    /mmoini "MyIni" "ClickyMaintenance" "click${clickies}" "NULL"
	/varcalc clickies ${clickies}-1
	/mmoini "MyIni" "ClickyMaintenance" "clickies" "${clickies}"
	/echo Item Removed ${itemtoremove}
/return

Sub Event_ClickyToggle
	/if (!${Defined[ClickyMaintenanceLoaded]}) /call ClickyMaintenanceLoad
	/if (${doclickies}) {
		/varset doclickies 0
		/mmoini "MyIni" "ClickyMaintenance" "doclickies" "${doclickies}"
		/echo Clicky Maintenance is off
	} else {
		/if (!${doclickies}) {
			/varset doclickies 1
			/mmoini "MyIni" "ClickyMaintenance" "doclickies" "${doclickies}"
			/echo Clicky Maintenance is on
		}
	}
/return

|clickymaintenance end

|clickynuke start

Sub ClickyNukeLoad
	/varset CurrentSub ClickyNuke
	/if (!${Defined[ClickyNukeLoaded]}) /declare ClickyNukeLoaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/if (${InvSlot[17].Item.Spell.ID}) /varset AAClickyNuke ${AAClickyNuke}${InvSlot[17].Item}|
		/call SpellLoad "ClickyNuke" 3 "|1|3|15|9|7|8|17|30|" "|2|TRUE|----|1s|96|1|FALSE|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "|3|7|8|9|15|17|30|"
	
	/declare i int local
	/for i 1 to ${ClickyNukeTotal}
		/if (!${Defined[ClickyNukeUseAtMobPctHP${i}]}) /declare ClickyNukeUseAtMobPctHP${i} int outer ${Ini[MyIni,ClickyNuke,ClickyNukeUseAtMobPctHP${i},0]}
		/if (!${Defined[ClickyNukeStopAtMobPctHP${i}]}) /declare ClickyNukeStopAtMobPctHP${i} int outer ${Ini[MyIni,ClickyNuke,ClickyNukeStopAtMobPctHP${i},100]}
		/if (!${Defined[${CurrentSub}MaxTries${i}]}) /declare ${CurrentSub}MaxTries${i} int outer 2
		/if (!${Defined[${CurrentSub}Resisted${i}]}) /declare ${CurrentSub}Resisted${i} bool outer FALSE
		/if (!${Defined[${CurrentSub}Conditions${i}]}) /declare ${CurrentSub}Conditions${i} string outer ${Ini[MyIni,ClickyNuke,ClickyNukeConditions${i},----]}
		/if (!${Defined[${CurrentSub}Name${i}]}) /declare ${CurrentSub}Name${i} string outer ${Ini[MyIni,ClickyNuke,ClickyNukeName${i},----]}
		/if (!${Defined[${CurrentSub}On${i}]}) /declare ${CurrentSub}On${i} bool outer FALSE
		/if (!${Defined[${CurrentSub}NamedOnly${i}]}) /declare ${CurrentSub}NamedOnly${i} bool outer ${Ini[MyIni,ClickyNuke,ClickyNukeNamedOnly${i},FALSE]}
		/if (!${Defined[${CurrentSub}Recast${i}]}) /declare ${CurrentSub}Recast${i} int outer ${Ini[MyIni,ClickyNuke,ClickyRecast${i},2]}
	/next i
/return

Sub ClickyNuke
	/if (${Me.Hovering}) /return
	/varset CurrentSub ClickyNuke
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (!${Me.XTarget}) /return
	/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis}) /goto :bard
  	/if (${ImNotReady}||!${${CurrentSub}Total}||${NeedLoad}) /return
	/if (!${Me.XTarget}) /return
  	
	:bard
 	/declare i int local
 	/for i 1 to ${${CurrentSub}Total}
		/if (!${Me.XTarget}) /return
 		/if (!${Defined[${CurrentSub}Use${i}]}||${Defined[${CurrentSub}Recast${i}]}) /continue
		/if (${ValidEnemy} && ${ShouldCastOnMob}) {
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset ClickyNukeConditions${i} ${Ini[MyIni,ClickyNuke,ClickyNukeConditions${i},123456]}
			/if (${FindItem[${${CurrentSub}Name${i}}].ItemSlot} && !${FindItem[${${CurrentSub}Name${i}}].Timer} && ${NamedOk} && ${ClickyNukeConditions${i}} && (${Target.Distance}<=${FindItem[${${CurrentSub}Name${i}}].Spell.Range} && ${FindItem[${${CurrentSub}Name${i}}].Spell.Range}||${FindItem[${${CurrentSub}Name${i}}].Spell.SpellType.NotEqual[detrimental]}||${Target.Distance}<=${FindItem[${${CurrentSub}Name${i}}].Spell.AERange} && ${FindItem[${${CurrentSub}Name${i}}].Spell.AERange})) {
				/if (${Me.Class.ShortName.Equal[BRD]}) {
					/squelch /twist stop
					/delay 2s !${Me.Casting.ID}
					/casting "${${CurrentSub}Name${i}}"|item
					/delay 2s
					/delay 2s !${Me.Casting.ID}
					/squelch /twist start
					/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
					/return
				}
				/if (${FindItem[${${CurrentSub}Name${i}}].EffectType.Equal[Click Worn]}||!${Me.HaveExpansion[Veil of Alaris]}) /casting "${${CurrentSub}Name${i}}"|item
				/if (${FindItem[${${CurrentSub}Name${i}}].EffectType.NotEqual[Click Worn]} && ${Me.HaveExpansion[Veil of Alaris]} && ${Me.Subscription.Equal[GOLD]}) /useitem ${FindItem[=${${CurrentSub}Name${i}}].ItemSlot} ${FindItem[=${${CurrentSub}Name${i}}].ItemSlot2}
				/delay 3s !${Me.Casting.ID}
				
				:bard2
				/call ${EchoSub} "${Cyan} ${${CurrentSub}Name${i}} --> ${White} ${Target}"
				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}Name${i}} --> ${Target.CleanName}
				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}Name${i}} --> ${Target.CleanName}
				/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
			}
		}
	/next i
/return

|clickynuke end

|cure start
#event AddCureIgnoreList "#*#AddCureIgnoreList #1#"
Sub Event_AddCureIgnoreList(line,addcureignore)
	/mmoini "MyIni" "Cure" "${CureIgnoreList}${addcureignore}|"
	/varset CureIgnoreList ${CureIgnoreList}${addcureignore}|
/return 


#event Cure "#*#NeedCure #1#|#2#|#3#|#4#|#5#|#6#|#7#"
|pois|dis|corr|curse|detr|tash|malo

|TODO: This code does absolutely nothing
Sub Event_Cure(line,int pois,int dis,int corr,int curse,int detr,bool tash,bool malo)
	/if (!${CureLoaded}) /call CureLoad
	/if (!${CureTotal}||!${CureOthers}) /return
	/declare i int local
	/for i 1 to ${CureTotal}
		/if (${CureArray[${i},1]} && ${pois}||${CureArray[${i},2]} && ${dis}||${CureArray[${i},3]} && ${corr}||${CureArray[${i},4]} && ${curse}||${CureArray[${i},5]} && ${detr}||${CureTash} && ${tash} && (${CureArray[${i},1]}||${CureArray[${i},5]})||${CureMalo} && ${malo} && ${CureArray[${i},5]}) {
		}
	/next i
/return

Sub CureLoad
	/if (!${Defined[CureLoaded]}) {
		/declare CureLoaded bool outer FALSE
	}
	/if (${CureLoaded}) /return
	/varset CureLoaded TRUE
	/declare i int local 1
	/declare b int local
	/declare CureTash bool outer ${Ini[MyIni,Cure,CureTash]}
	/if (!${CureTash}) /mmoini "MyIni" "Cure" "CureTash" "FALSE"
	/declare CureMalo bool outer ${Ini[MyIni,Cure,CureMalo]}
	/if (!${CureMalo}) /mmoini "MyIni" "Cure" "CureMalo" "FALSE"
	/declare Tashed bool outer
	/declare TashBuff int outer
	/declare Malod bool outer
	/declare MaloBuff int outer
	/declare RezEffects bool outer
	/declare NeedCure bool outer
	/mmoini "MyIni" "Cure"  "AvailableCureTypes" "Poisoned,Diseased,Cursed,Corrupted,HPDrain,ManaDrain,EnduranceDrain,Slowed,SpellSlowed,Snared,Rooted,ManaCost,CastingLevel,HealingEff,SpellDmgEff,Blind,Charmed,Feared,"
	/declare CureTypes string outer ${Ini[MyIni,Cure,CureTypes,Poisoned,Diseased,Corrupted,Cursed,Slowed,Snared,SpellSlowed,]}
	/if (${CureTypes.Equal[Poisoned,Diseased,Corrupted,Cursed,Slowed,Snared,SpellSlowed,]}) /mmoini "MyIni" "Cure" "CureTypes" "Poisoned,Diseased,Corrupted,Cursed,Slowed,Snared,SpellSlowed,"
	/declare CureDuringCombat bool outer ${Ini[MyIni,Cure,CureDuringCombat,FALSE]}
	/if (!${CureDuringCombat}) /mmoini "MyIni" "Cure" "CureDuringCombat" "FALSE"
	/declare CureRequest bool outer ${Ini[MyIni,Cure,CureRequest,FALSE]}
	/if (!${CureRequest}) /mmoini "MyIni" "Cure" "CureRequest" "FALSE"
	/declare CureRequestTimer timer outer ${Ini[MyIni,Cure,CureRequest]}
	/if (!${CureRequestTimer}) /mmoini "MyIni" "Cure" "CureRequestTimer" "10s"
	/declare CureSelf bool outer ${Ini[MyIni,Cure,CureSelf]}
	/if (!${CureSelf}) /mmoini "MyIni" "Cure" "CureSelf" "FALSE"
	/declare CureOthers bool outer ${Ini[MyIni,Cure,CureOthers]}
	/if (!${CureOthers}) /mmoini "MyIni" "Cure" "CureOthers" "FALSE"
	/declare CureIgnoreList string outer ${Ini[MyIni,Cure,CureIgnoreList,|]}
	/if (${CureIgnoreList.Equal[|]}) /mmoini "MyIni" "Cure" "CureIgnoreList" "|"

	/if (${Select[${Me.Class.ShortName},SHM,CLR,DRU,PAL]}) /varset i 3
	/varset tempsubtotal ${Ini[MyIni,Cure,CureTotal]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/call SpellLoad "Cure" ${i} "|1|3|4|6|30|" "|${i}|TRUE|----|----|TRUE|"
	}
	/call SpellLoad2 "Cure" "3|4|6|30|"

	/declare CureArray[${CureTotal},5] string outer 0
	/declare numEffects int local 0
	/for i 1 to ${CureTotal}
		/varcalc numEffects ${Spell[${CureSpellName${i}}].NumEffects}
		/for b 1 to ${numEffects}
			/if (${Spell[${CureSpellName${i}}].Slot[${b}].Find[Decrease Poison Counter]}) /varcalc CureArray[${i},1] ${CureArray[${i},1]}+${Math.Abs[${Spell[${CureSpellName${i}}].Base[${b}]}]}
			/if (${Spell[${CureSpellName${i}}].Slot[${b}].Find[Decrease Disease Counter]}) /varcalc CureArray[${i},2] ${CureArray[${i},1]}+${Math.Abs[${Spell[${CureSpellName${i}}].Base[${b}]}]}
			/if (${Spell[${CureSpellName${i}}].Slot[${b}].Find[Decrease Corruption Counter]}) /varcalc CureArray[${i},3] ${CureArray[${i},1]}+${Math.Abs[${Spell[${CureSpellName${i}}].Base[${b}]}]}
			/if (${Spell[${CureSpellName${i}}].Slot[${b}].Find[Decrease Curse Counter]}) /varcalc CureArray[${i},4] ${CureArray[${i},1]}+${Math.Abs[${Spell[${CureSpellName${i}}].Base[${b}]}]}
			/if (${Spell[${CureSpellName${i}}].Slot[${b}].Find[Remove Detrimental]}) /varcalc CureArray[${i},5] ${CureArray[${i},1]}+${Math.Abs[${Spell[${CureSpellName${i}}].Base[${b}]}]}
		/next b
	/next i
/return

Sub Cure
	/if (!${Defined[CureLoaded]}) {
		/declare CureLoaded bool outer FALSE
	}
	/if (!${CureLoaded}) /call CureLoad
	/varset CurrentSub Cure
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/varset Tashed FALSE
	/varset Malod FALSE
	/declare i int local
	/declare b int local
	/for i 1 to ${MMOBugs.MaxBuffs}
		/if (${CureIgnoreList.Find[${Me.Buff[${i}]}]}) /return
		/if (${Me.Buff[${i}].Name.Find[tash]} && ${Spell[${Me.Buff[${i}]}].SpellType.Equal[detrimental]}) {
			/varset Tashed TRUE
			/varset TashBuff ${i}
			/if (${CureTash}) /varset NeedCure TRUE
			|/goto :needcure
		}
	
		/if (${Me.Buff[${i}].Name.Find[malo]} && ${Spell[${Me.Buff[${i}]}].SpellType.Equal[detrimental]}) {
			/varset Malod TRUE
			/varset MaloBuff ${i}
			/if (${CureMalo}) /varset NeedCure TRUE
			|/goto :needcure
		}
	/next i
	
	/if (${NeedCure}) /goto :needcure
	
	/if (${Me.Buff[Revival Sickness].ID}||${Me.Buff[Resurrection Sickness].ID}) {
		/varset RezEffects TRUE
	}

	/if (${Debuff.Count}||${Debuffed.Snared} && ${CureTypes.Find[Snare]}) {
		/for b 1 to ${CureTypes.Count[,]}
			/if (${Debuff.${CureTypes.Arg[${b},,]}}) {
				/if (${CureTypes.Arg[${b},,].Equal[Slowed]} && !${RezEffects}) /varset NeedCure TRUE
				/if (${CureTypes.Arg[${b},,].Equal[Poisoned]} && (!${Tashed}||${Debuff.Poisoned}>1)) /varset NeedCure TRUE
				/if (!${Select[${CureTypes.Arg[${b},,]},Slowed,Poisoned]}) /varset NeedCure TRUE
				/if (${NeedCure}) /goto :needcure
			}
		/next b
	}

	/if (!${NeedCure}) /return

	:needcure

	/for i 1 to ${CureTotal}
		/if (!${CureUse${i}}) /continue
		/if (${Debuff.Poisoned} && ${CureArray[${i},1]}||${Debuff.Diseased} && ${CureArray[${i},2]}||${Debuff.Corrupted} && ${CureArray[${i},3]}||${Debuff.Cursed} && ${CureArray[${i},4]}||(${Malod}||${Debuff.Count}) && ${CureArray[${i},5]}) {
			/if (${Me.Book[${CureSpellName${i}}]} && !${If[${Me.SpellReady[${CureSpellName${i}}]},TRUE,FALSE]} && ${CureSpellGem${i}.Find[gem]}) {
				/memorize "${CureSpellName${i}}" "${CureSpellGem${i}}"
				:gemwait
				/doevents
				/if (${Me.CombatState.Equal[COMBAT]} && !${CureDuringCombat}) /return
				/delay 2
				/if (!${Me.SpellReady[${CureSpellName${i}}]}) /goto :gemwait
			}
			
			/if (${Me.SpellReady[${CureSpellName${i}}]}||${Me.AltAbilityReady[${CureSpellName${i}}]}||${FindItem[${CureSpellName${i}}].ItemSlot} && !${FindItem[${CureSpellName${i}}].Timer}||${Me.CombatAbilityReady[${CureSpellName${i}}]}) {
				/if (${Spell[${CureSpellName${i}}].TargetType.Equal[Single]}) /tar myself
				/call Cast "${CureSpellName${i}}" ${CureSpellGem${i}} NULL NULL NULL
				/if (${Spell[${CureSpellName${i}}].TargetType.Equal[Single]}) /call ${EchoSub} "${Green} ${CureSpellName${i}} --> ${White} ${Target}"
				/if (${Spell[${CureSpellName${i}}].TargetType.NotEqual[Single]}) /call ${EchoSub} "${Green} ${CureSpellName${i}} --> ${White} Curing"			
				/delay 5
				/if (!${Debuff.Count} && (!${Malod}||!${Me.Buff[${MaloBuff}].Find[malo]})) /goto :cured
			}
		}
	/next i

	/if (${CureRequest} && !${CureRequestTimer}) {
		/docommand /${MyChannel} NeedCure ${Debuff.Poisoned}|${Debuff.Diseased}|${Debuff.Corrupted}|${Debuff.Count}|${Tashed}|${Malod}
		/varset CureRequestTimer ${Ini[MyIni,Cure,CureRequestTimer]}
	}

	:cured
/return
|cure end
|debuff start
Sub DebuffLoad
	/varset CurrentSub Debuff
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 1
	/if (${Select[${Me.Class.ShortName},CLR,PAL,BST]}) /varset i 3
	/if (${Select[${Me.Class.ShortName},SHM,ENC]}) /varset i 6
	/if (${Select[${Me.Class.ShortName},ENC]}) /varset i 12
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/mmoini "MyIni" "${CurrentSub}" "DontDebuffConColor" "|GREY|GREEN|"
		/mmoini "MyIni" "${CurrentSub}" "DebuffAdds" "FALSE"
		/call SpellLoad "Debuff" ${i} "|1|2|3|4|6|7|8|9|13|30|" "|${i}|${i}|TRUE|----|----|96|1|2m|2|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|7|8|9|13|30|"
	/declare DontDebuffConColor string outer ${Ini[MyIni,${CurrentSub},DontDebuffConColor,|GREY|GREEN|]}
	/if (!${Defined[DebuffAdds]}) /declare DebuffAdds bool outer ${Ini[MyIni,${CurrentSub},DebuffAdds,FALSE]}
	/for i 1 to ${DebuffTotal}
		/if (!${Defined[DebuffRecast${i}]}) /declare DebuffRecast${i} timer outer
		/varset DebuffRecast${i} 0
	/next i
/return

Sub DebuffClear(int DebuffMobID)
	/declare i int local
	/for i 1 to ${DebuffTotal}
		/if (${Defined[Debuff${i}${DebuffMobID}]}) /deletevar Debuff${i}${DebuffMobID}
		/if (${Defined[Debuff${i}${DebuffMobID}Resist]}) {
			/deletevar ${Debuff${i}${DebuffMobID}Resist}
		}
	/next i
/return

Sub Debuff
	/if (${Me.Hovering}) /return
	/varset CurrentSub Debuff
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${${CurrentSub}Total}||${NeedLoad}) /return
	/declare i int local
	/declare a int local
	/for i 1 to ${DebuffTotal}
		/if (!${Defined[Debuff${i}${TarID}]}) {
			/if (${TarID} && (${Spawn[id ${TarID}].Distance}<=${AttackRange}||${UseArchery})) /call DebuffAdd ${TarID}
		}
		/if (${Defined[Debuff${i}${TarID}]}) {
			/if (!${Debuff${i}${TarID}} && ${TarID} && (${Spawn[id ${TarID}].Distance}<=${AttackRange}||${UseArchery})) /call DebuffAdd ${TarID}
		}
	/next i
	/if (!${DebuffAdds}) /return
	/for a 1 to ${AddList.Count[|]}
		/for i 1 to ${DebuffTotal}
			/if (!${Defined[Debuff${i}]}) /continue
			/if (!${Debuff${i}${AddList.Arg[${a},|]}} && ${TarID} && ${Spawn[id ${AddList.Arg[${a},|]}].ID} && ${AddList.Arg[${a},|]}!=${TarID} && (${Spawn[id ${AddList.Arg[${a},|]}].Distance}<=${AttackRange}||${UseArchery})) /call DebuffAdd ${AddList.Arg[${a},|]}
		/next i
	/next a
/return

Sub DebuffAdd(int DebuffID)
	/varset CurrentSub Debuff
	/declare i int local
	/for i 1 to ${DebuffTotal}
		/if (!${Defined[${CurrentSub}Use${i}]}) /declare ${CurrentSub}Use${i} bool outer FALSE
		/if (!${${CurrentSub}Use${i}}) /continue
		/if (!${Defined[Debuff${i}${DebuffID}Resist]} && ${Spawn[id ${DebuffID}].ID}) /declare Debuff${i}${DebuffID}Resist int outer
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset DebuffConditions${i} ${Ini[MyIni,Debuff,DebuffConditions${i},123456]}
		
		/if (!${Defined[${CurrentSub}IgnoreRecast${i}]}) /Declare ${CurrentSub}IgnoreRecast${i} bool local FALSE
		/if (!${Defined[${CurrentSub}On${i}]}) /Declare ${CurrentSub}On${i} bool local FALSE
		/if (!${Defined[${CurrentSub}Resisted${i}]}) /Declare ${CurrentSub}Resisted${i} bool local FALSE
		/if (!${CastIsReady}) {
			/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
		}
		/if (${ValidSpell}  && ${CastIsReady} && ${CanCastOnMob} && ((${Target.PctHPs}>=${${CurrentSub}StopAtMobPctHP${i}} && ${Target.PctHPs}<=${${CurrentSub}UseAtMobPctHP${i}}||!${Defined[${CurrentSub}UseAtMobPctHP${i}]}) && !${${CurrentSub}On${i}} && (!${${CurrentSub}MaxTries${i}}||${${CurrentSub}MaxTries${i}}>${${CurrentSub}Resisted${i}})) && ${DebuffConditions${i}}) {
			/if (!${Defined[Debuff${i}${DebuffID}]} && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady} && !${DontDebuffConColor.Find[|${Spawn[${DebuffID}].ConColor}|]}) {
				/if (${Spell[${${CurrentSub}SpellName${i}}].Slot[2].Find[Decrease Attack Speed]} && ${SlowImmuneList.Find[${Target.CleanName}]}) {
					/declare Debuff${i}${DebuffID} timer outer 9999999
					/continue
				}
				/if (${Target.ID} && ${Target.ID}!=${DebuffID} && ${Spawn[id ${DebuffID}].ID}) /squelch /tar id ${DebuffID}
				/delay 1s ${Target.ID}==${DebuffID}
				/if (!${Target.ID}) /return
				/if ((${Target.Type.Equal[Corpse]}) && ${Target.ID}||${Defined[Debuff${i}${DebuffID}]}) /goto :nextdebuff
				/call ${EchoSub} "${DarkYellow} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[TRY]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
				/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
				/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
					/keypress f10
					/face
					/delay 5
					/click left center
					/keypress f10
				}
				/delay 2
				/delay 3s !${Me.Casting.ID}
				/if (${Macro.Return.Equal[CAST_SUCCESS]}||${Macro.Return.Equal[CAST_NOTHOLD]}||${DebuffSpellGem${i}.Equal[alt]}||${DebuffSpellGem${i}.Equal[item]}) {
					/if (!${Defined[Debuff${i}${DebuffID}]}) /declare Debuff${i}${DebuffID} timer outer ${Ini[MyIni,Debuff,DebuffRecast${i},2m]}
					/varset Debuff${i}${DebuffID} ${Ini[MyIni,Debuff,DebuffRecast${i},2m]}
					/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} SUCCESS						
				}
				/if (${Macro.Return.Equal[CAST_IMMUNE]})  {
					/if (!${Defined[Debuff${i}${DebuffID}]}) /declare Debuff${i}${DebuffID} timer outer 9999999
					/varset Debuff${i}${DebuffID} 9999999
				}
				/if (${Macro.Return.Equal[CAST_RESIST]})  {
					/varcalc Debuff${i}${DebuffID}Resist ${Debuff${i}${DebuffID}Resist}+1
					/if (${Debuff${i}${DebuffID}Resist}>${DebuffMaxTries${i}}) /declare Debuff${i}${DebuffID} timer outer 9999999
					/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} RESIST						
				}
			}
			/if (${Defined[Debuff${i}${DebuffID}]}) {
				/if (!${Debuff${i}${DebuffID}} && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady} && !${DontDebuffConColor.Find[|${Spawn[${DebuffID}].ConColor}|]}) {
					/if (${Spell[${${CurrentSub}SpellName${i}}].Slot[2].Find[Decrease Attack Speed]} && ${SlowImmuneList.Find[${Target.CleanName}]}) {
						/declare Debuff${i}${DebuffID} timer outer 9999999
						/continue
					}
					/if (${Target.ID} && ${Target.ID}!=${DebuffID} && ${Spawn[id ${DebuffID}].ID}) /squelch /tar id ${DebuffID}
					/delay 1s ${Target.ID}==${DebuffID}
					/if (!${Target.ID}) /return
					/if ((${Target.Type.Equal[Corpse]}) && ${Target.ID}||${Defined[Debuff${i}${DebuffID}]}) {
						/if (${Debuff${i}${DebuffID}}) {
							/goto :nextdebuff
						}
					}	
					/call ${EchoSub} "${DarkYellow} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
					/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[TRY]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
					/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
						/keypress f10
						/face
						/delay 5
						/click left center
						/keypress f10
					}
					/delay 2
					/delay 3s !${Me.Casting.ID}
					/if (${Macro.Return.Equal[CAST_SUCCESS]}||${Macro.Return.Equal[CAST_NOTHOLD]}||${DebuffSpellGem${i}.Equal[alt]}||${DebuffSpellGem${i}.Equal[item]}) {
						/if (!${Defined[Debuff${i}${DebuffID}]}) /declare Debuff${i}${DebuffID} timer outer ${Ini[MyIni,Debuff,DebuffRecast${i},2m]}
						/varset Debuff${i}${DebuffID} ${Ini[MyIni,Debuff,DebuffRecast${i},2m]}
						/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} SUCCESS						
					}
					/if (${Macro.Return.Equal[CAST_IMMUNE]})  {
						/if (!${Defined[Debuff${i}${DebuffID}]}) /declare Debuff${i}${DebuffID} timer outer 9999999
						/varset Debuff${i}${DebuffID} 9999999
					}
					/if (${Macro.Return.Equal[CAST_RESIST]})  {
						/varcalc Debuff${i}${DebuffID}Resist ${Debuff${i}${DebuffID}Resist}+1
						/if (${Debuff${i}${DebuffID}Resist}>${DebuffMaxTries${i}}) /declare Debuff${i}${DebuffID} timer outer 9999999
						/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} RESIST						
					}
				}
			}
		}
		:skip
		/doevents
		:nextdebuff
	/next i
/return

|debuff end

|disc start
Sub DiscLoad
	/varset CurrentSub Disc
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/if (!${Defined[DiscTotal]}) /declare DiscTotal int outer ${Ini[MyIni,Disc,DiscTotal]}
	/declare i int local
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/declare DiscConditions string outer
	/if (${NeedLoad} && !${tempsubtotal}) {
		/if (!${Defined[DiscList]}) /declare DiscList string outer |Thousand Blades|Fortitude Discipline|Whirlwind Discipline|Deftdance Discipline|Weapon Shield Discipline|Deflection Discipline|Speed Focus Discipline|Nimble Discipline|
		/mmoini "MyIni" "Disc" "DiscTotal" "0"
		|/if (${Select[${Me.Class.ShortName},WAR,SHD,PAL,RNG]}) /mmoini "MyIni" "Disc" "NormalBandolier"
		|/if (${Select[${Me.Class.ShortName},WAR,SHD,PAL,RNG]}) /mmoini "MyIni" "Disc" "DiscBandolier"
		/declare cLoop int local 1
		| ------------------- Combat Disciplines -------------------
		:openCombatSkills
		/if (!${Window[CombatSkillSelectWnd].Open}) /squelch /windowstate CombatSkillSelectWnd Open
		/delay 1s ${Window[CombatSkillSelectWnd].Open}
		/if (!${Window[CombatSkillSelectWnd].Open}) /goto :openCombatSkills
		/for i 1 to 200
			/if (${Window[CombatSkillSelectWnd].Child[CSSW_SkillSelectorList].List[${i}].Length} && (${Window[CombatSkillSelectWnd].Child[CSSW_SkillSelectorList].List[${i},2]}>=${Math.Calc[${Me.Level}-4].Int}||${DiscList.Find[${Window[CombatSkillSelectWnd].Child[CSSW_SkillSelectorList].List[${i},1]}]})) {
				/mmoini "MyIni" "Disc" "DiscTotal" "${cLoop}"
				/mmoini "MyIni" "Disc" "DiscUse${cLoop}" "FALSE"
				/mmoini "MyIni" "Disc" "DiscName${cLoop}" "${Window[CombatSkillSelectWnd].Child[CSSW_SkillSelectorList].List[${cLoop},1]}"
				/mmoini "MyIni" "Disc" "DiscNamedOnly${cLoop}" "TRUE"		
				/mmoini "MyIni" "Disc" "DiscRecast${cLoop}" "1s"
				/mmoini "MyIni" "Disc" "DiscConditions${cLoop}"
				/varcalc cLoop ${cLoop}+1
			}
		/next i
		
		:closeCombatSkills
		/if (${Window[CombatSkillSelectWnd].Open}) /squelch /windowstate CombatSkillSelectWnd close
		/delay 1s !${Window[CombatSkillSelectWnd].Open}
		/if (${Window[CombatSkillSelectWnd].Open}) /goto :closeCombatSkills
	}

	/if (${DiscTotal}) {
		/for i 1 to ${DiscTotal}
			/declare DiscUse${i} bool outer ${Ini[MyIni,Disc,DiscUse${i}]}
			/declare DiscName${i} string outer ${Ini[MyIni,Disc,DiscName${i}]}
			/declare DiscNamedOnly${i} bool outer ${Ini[MyIni,Disc,DiscNamedOnly${i}]}
			/declare DiscRecast${i} timer outer ${Ini[MyIni,Disc,DiscRecast${i}]}
			/declare DiscConditions${i} string outer 
			/if (${Me.CombatAbility[DiscName${i} Rk. III]}) /varset DiscName${i} ${DiscName${i}} Rk. III
			/if (${Me.CombatAbility[DiscName${i} Rk. II]}) /varset DiscName${i} ${DiscName${i}} Rk. II
		/next i
	}
/return

Sub Disc
	/if (${Me.Hovering}) /return
	/varset CurrentSub Disc
	/if (!${DiscLoaded}) /call DiscLoad
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${ImNotReady}||${NeedLoad}) /return
	/if (!${${CurrentSub}Total}) /return

	/declare i int local
	/for i 1 to ${${CurrentSub}Total}
		/if (!${DiscUse${i}}||${DiscRecast${i}}) /continue
 		/if (${ValidEnemy}) {
 			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset DiscConditions${i} ${Ini[MyIni,Disc,DiscConditions${i},123456]}
 			/if ((!${Spell[${DiscName${i}}].Duration.TotalSeconds}||!${Melee.DiscID}) && ${Target.LineOfSight} && (${Target.Distance}<=${Spell[${${CurrentSub}Name${i}}].Range}||${Spell[${${CurrentSub}Name${i}}].SpellType.NotEqual[detrimental]}) && ${Me.CombatAbilityReady[${DiscName${i}}]} && ${NamedOk} && ${Me.Endurance}>=${Spell[${DiscName${i}}].EnduranceCost} && ${DiscConditions${i}}) {
				/call ${EchoSub} "${Green} ${${CurrentSub}Name${i}} --> ${White} ${Target}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}Name${i}} --> ${Target.CleanName}
				/if (!${Defined[DiscAnnounce]}) /declare DiscAnnounce bool outer FALSE
				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}Name${i}} --> ${Target.CleanName}
    			/disc ${${CurrentSub}Name${i}}
				/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
				/if (${ExitSubEarly}) /return
			}
		}
	/next i
/return
|disc end


|dot start

#event DotResist1    	"#*#Your target resisted the |${DotSpellName1}|#*#"
#event DotResist2    	"#*#Your target resisted the |${DotSpellName2}|#*#"
#event DotResist3    	"#*#Your target resisted the |${DotSpellName3}|#*#"
#event DotResist4    	"#*#Your target resisted the |${DotSpellName4}|#*#"
#event DotResist5    	"#*#Your target resisted the |${DotSpellName5}|#*#"
#event DotResist6    	"#*#Your target resisted the |${DotSpellName6}|#*#"
#event DotResist7    	"#*#Your target resisted the |${DotSpellName7}|#*#"
#event DotResist8    	"#*#Your target resisted the |${DotSpellName8}|#*#"
#event DotResist9    	"#*#Your target resisted the |${DotSpellName9}|#*#"
#event DotResist10    	"#*#Your target resisted the |${DotSpellName10}|#*#"
#event DotResist11    	"#*#Your target resisted the |${DotSpellName11}|#*#"
#event DotResist12    	"#*#Your target resisted the |${DotSpellName12}|#*#"
#event DotResist13    	"#*#Your target resisted the |${DotSpellName13}|#*#"
#event DotResist14    	"#*#Your target resisted the |${DotSpellName14}|#*#"
#event DotResist15    	"#*#Your target resisted the |${DotSpellName15}|#*#"
#event DotOff1    	"#*#Your |${DotSpellName1}| spell has worn off#*#"
#event DotOff2    	"#*#Your |${DotSpellName2}| spell has worn off#*#"
#event DotOff3    	"#*#Your |${DotSpellName3}| spell has worn off#*#"
#event DotOff4    	"#*#Your |${DotSpellName4}| spell has worn off#*#"
#event DotOff5    	"#*#Your |${DotSpellName5}| spell has worn off#*#"
#event DotOff6    	"#*#Your |${DotSpellName6}| spell has worn off#*#"
#event DotOff7    	"#*#Your |${DotSpellName7}| spell has worn off#*#"
#event DotOff8    	"#*#Your |${DotSpellName8}| spell has worn off#*#"
#event DotOff9    	"#*#Your |${DotSpellName9}| spell has worn off#*#"
#event DotOff10    	"#*#Your |${DotSpellName10}| spell has worn off#*#"
#event DotOff11    	"#*#Your |${DotSpellName11}| spell has worn off#*#"
#event DotOff12    	"#*#Your |${DotSpellName12}| spell has worn off#*#"
#event DotOff13    	"#*#Your |${DotSpellName13}| spell has worn off#*#"
#event DotOff14    	"#*#Your |${DotSpellName14}| spell has worn off#*#"
#event DotOff15    	"#*#Your |${DotSpellName15}| spell has worn off#*#"

Sub DotLoad
	/if (!${Defined[GoMLoaded]}) /call GoMLoad
	/varset CurrentSub Dot
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare dtotal int outer
	/varset dtotal 1
	/if (${Select[${Me.Class.ShortName},ENC,RNG,BST,DRU]}) /varset dtotal 3
	/if (${Select[${Me.Class.ShortName},SHD,SHM]}) /varset dtotal 8
	/if (${Select[${Me.Class.ShortName},NEC]}) /varset dtotal 15

	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/call SpellLoad "DoT" ${dtotal} "|1|2|3|4|6|7|8|9|13|30|" "|${dtotal}|${dtotal}|TRUE|----|----|96|30|1s|2|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "|1|3|4|6|7|8|9|13|30|"
	/declare i int local
	/declare DotAmt int outer
	/if (!${Defined[DotTotalIfNamed]}) /declare DotTotalIfNamed int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}TotalIfNamed,0]}
	/if (${DotTotalIfNamed}>=${DotTotal}) /varset dtotal ${DotTotalIfNamed}
	/if (${DotTotalIfNamed}<=${DotTotal}) /varset dtotal ${DotTotal}

	/for i 1 to 15
		/declare DotResisted${i} int outer 0
		/declare DotOn${i} bool outer FALSE
		/if (!${Defined[DotSpellName${i}]}) /declare DotSpellName${i} string outer ${Ini[MyIni,Dot,DotSpellName${i},NULL]}
		/if (${Defined[DotSpellName${i}]}) /varset DotSpellName${i} ${Ini[MyIni,Dot,DotSpellName${i},NULL]}
	/next i
/return

Sub Dot
	/if (${Me.Hovering}) /return
	/varset CurrentSub Dot
	/if (!${Defined[${CurrentSub}Loaded]}) /call DotLoad
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${ImNotReady}||${NeedLoad}||${Target.ID}!=${TarID}||${Target.Distance}>${AttackRange}) /return
	/if (!${${CurrentSub}Total}) /return
	/varset DotAmt ${DotTotal}
  	/if (${ValidNamed}) /varset DotAmt ${${CurrentSub}TotalIfNamed}
    /declare i int local
    /for i 1 to ${DotAmt}
    	/if (!${DotUse${i}}) /continue
 		/if (${ValidSpellType} && ${ValidEnemy}) {
			/if (!${Defined[GoMUse${i}]}) /declare GoMUse${i} bool outer FALSE
			/if (${GoMUse${i}}) {
				/if (${Defined[GoMSpellIcon${i}]} && ${Defined[GoMSpellName${i}]}) {
					/if (${GoMCheck}) {
						/call ${EchoSub} "${Gray} ${GoMSpellName${i}} --> ${White} ${Target}"
						/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${GoMSpellName${i}} --> ${Target.CleanName}
						/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${GoMSpellName${i}} --> ${Target.CleanName}
						/call Cast "${GoMSpellName${i}}" ${GoMSpellGem${i}} 0 CheckStuff NULL
						/delay 3s !${Me.Casting.ID}
						/if (${CastCounts}) {
							/varcalc Hate ${Hate}+1
							|/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
						}
					}
				}
			}
			
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset DotConditions${i} ${Ini[MyIni,Dot,DotConditions${i},123456]}
			
			/if (!${Defined[${CurrentSub}IgnoreRecast${i}]}) /Declare ${CurrentSub}IgnoreRecast${i} bool outer FALSE
			
    		/if (${ValidSpellType} && ${ValidSpell} && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady} && ${DotConditions${i}} && ${Target.ID}==${TarID}) {
 				/if (${ResistCheck}) {
					/call ${EchoSub} "${Yellow} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
   					/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
   					/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
   					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
					/delay 3s !${Me.Casting.ID}
					/if (${CastCounts}) {
						/varcalc Hate ${Hate}+1
						/varset DotOn${i} TRUE
						/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
						/if (${ExitSubEarly}) /return
					}
				}
			}
		}
    /next i     
/return

Sub ClearDots
	/declare i int local
	/for i 1 to 15
		/varset DotResisted${i} 0
		/varset DotOn${i} FALSE
	/next i
/return

Sub Event_DotResist1
    /varcalc DotResisted1 ${DotResisted1}+1
    /varset DotOn1 FALSE
/return

Sub Event_DotResist2
    /varcalc DotResisted2 ${DotResisted2}+1
    /varset DotOn2 FALSE
/return

Sub Event_DotResist3
    /varcalc DotResisted3 ${DotResisted3}+1
    /varset DotOn3 FALSE
/return

Sub Event_DotResist4
    /varcalc DotResisted4 ${DotResisted4}+1
    /varset DotOn4 FALSE
/return

Sub Event_DotResist5
    /varcalc DotResisted5 ${DotResisted5}+1
    /varset DotOn5 FALSE
/return

Sub Event_DotResist6
    /varcalc DotResisted6 ${DotResisted6}+1
    /varset DotOn6 FALSE
/return

Sub Event_DotResist7
    /varcalc DotResisted7 ${DotResisted7}+1
    /varset DotOn7 FALSE
/return

Sub Event_DotResist8
    /varcalc DotResisted8 ${DotResisted8}+1
    /varset DotOn8 FALSE
/return

Sub Event_DotResist9
    /varcalc DotResisted9 ${DotResisted9}+1
    /varset DotOn9 FALSE
/return

Sub Event_DotResist10
    /varcalc DotResisted10 ${DotResisted10}+1
    /varset DotOn10 FALSE
/return

Sub Event_DotResist11
    /varcalc DotResisted11 ${DotResisted11}+1
    /varset DotOn11 FALSE
/return

Sub Event_DotResist12
    /varcalc DotResisted12 ${DotResisted12}+1
    /varset DotOn12 FALSE
/return

Sub Event_DotResist13
    /varcalc DotResisted13 ${DotResisted13}+1
    /varset DotOn13 FALSE
/return

Sub Event_DotResist14
    /varcalc DotResisted14 ${DotResisted14}+1
    /varset DotOn14 FALSE
/return

Sub Event_DotResist15
    /varcalc DotResisted15 ${DotResisted15}+1
    /varset DotOn15 FALSE
/return

Sub Event_DotOff1
    /varset DotOn1 FALSE
/return

Sub Event_DotOff2
    /varset DotOn2 FALSE
/return

Sub Event_DotOff3
    /varset DotOn3 FALSE
/return

Sub Event_DotOff4
    /varset DotOn4 FALSE
/return

Sub Event_DotOff5
    /varset DotOn5 FALSE
/return

Sub Event_DotOff6
    /varset DotOn6 FALSE
/return

Sub Event_DotOff7
    /varset DotOn7 FALSE
/return

Sub Event_DotOff8
    /varset DotOn8 FALSE
/return

Sub Event_DotOff9
    /varset DotOn9 FALSE
/return

Sub Event_DotOff10
    /varset DotOn10 FALSE
/return

Sub Event_DotOff11
    /varset DotOn11 FALSE
/return

Sub Event_DotOff12
    /varset DotOn12 FALSE
/return

Sub Event_DotOff13
    /varset DotOn13 FALSE
/return

Sub Event_DotOff14
    /varset DotOn14 FALSE
/return

Sub Event_DotOff15
    /varset DotOn15 FALSE
/return

|dot end

|dps start
Sub DPSLoad
	/if (${DPSLoaded}) /return
	/declare DPSLoaded int outer 1
	/declare FightStartTime float outer
	/declare FightTotalTime float outer
	/declare FightRemainingTime float outer
	/declare FightTimer timer outer
	/declare AnnounceTimeRemaining bool outer ${Ini[MyIni,DPS,AnnounceTimeRemaining,TRUE]}
	/declare AnnouncedTimer timer outer ${Ini[MyIni,DPS,AnnouncedTimer,10s]}
/return

Sub DPS
	/if (${Me.Hovering}) /return
  	/if (!${DPSLoaded}) /call DPSLoad
  	/if (!${TarID}||!${Spawn[id ${TarID}].ID}||${Spawn[id ${TarID}].PctHPs}>95) /return
  	/if (!${FightStartTime}) /varset FightStartTime ${EverQuest.Running}
  	/varcalc FightTotalTime (${EverQuest.Running}-${FightStartTime})/1000
  	/varcalc FightRemainingTime (100/((100-${Target.PctHPs})/(${FightTotalTime}+.0001))-${FightTotalTime})
  	/varset FightTimer ${Math.Calc[${FightRemainingTime}].Int}s
  	/if (${AnnounceTimeRemaining} && !${AnnouncedTimer} && ${FightRemainingTime}>1) {
		/echo ~ ${FightRemainingTime} Seconds remaining
		/varset AnnouncedTimer ${AnnouncedTimer.OriginalValue}
	}
/return
|dps end

|Endurance start
Sub EnduranceLoad
	/if (!${Defined[EnduranceLoaded]}) /declare EnduranceLoaded bool outer FALSE
	/if (${EnduranceLoaded}) /return
	/varset EnduranceLoaded TRUE
	/declare SitTimer timer outer 10s
	/declare SitAt int outer ${Ini[MyIni,Endurance,SitAt,0]}
	/declare SitToFull bool outer ${Ini[MyIni,Endurance,SitToFull,FALSE]}
	/declare EnduranceConditions string outer ${Ini[MyIni,Endurance,EnduranceConditions,123456]}
	/if (${NeedLoad} && !${SitAt}) {
		/echo Loading ini for Endurance section.
		/mmoini "MyIni" "Endurance" "SitAt" "25"
		/mmoini "MyIni" "Endurance" "SitToFull" "FALSE"
		/mmoini "MyIni" "Endurance" "EnduranceConditions"
	}
/return

Sub Endurance
	/if (${Me.Hovering}) /return
	/varset CurrentSub Endurance
	/if (!${Defined[EnduranceLoaded]}) /call EnduranceLoad
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return

	/if (${Me.PctEndurance}<${SitAt} && !${SitTimer} && !${sitTimer} && !${Me.Mount.ID} && ${Me.State.Equal[STAND]} && (${Me.CombatState.Equal[ACTIVE]}||${Me.CombatState.Equal[DEBUFFED]} && !${Debuff.Count}) && !${Me.Class.ShortName.NotEqual[BRD]}) {
		
		/varset SitTimer ${SitTimer.OriginalValue}
		/varset sitTimer ${Ini[MyIni,General,SitTimer]}
	}
  	:SitToFull
  	/if (${Me.CombatState.Equal[RESTING]} && ${SitToFull} && ${Me.PctEndurance}<95) /goto :SitToFull
/return
|endurance end

|fade start

Sub FadeLoad
	/varset CurrentSub Fade
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${FadeLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE

	/declare i int local 1
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/call SpellLoad "Fade" ${i} "|1|3|4|11|30|" "|${i}|FALSE|----|5|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|11|30|"
/return

Sub Fade
	/if (${Me.Hovering}) /return
	/varset CurrentSub Fade
	/if (!${FadeLoaded}) /call FadeLoad
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${FadeTotal}||${ImNotReady}) /return
	/declare i int local
	/for i 1 to ${FadeTotal}
		/if (!${Defined[FadeUseAtMyHP${i}]}) {
			/varset FadeUseAtMyHP${i} ${Ini[MyIni,Fade,FadeAtMyHps${i},1]}
		}
		/if (!${FadeUse${i}}) /continue
		/if (!${Ini[MyIni,Fade,FadeConditions${i}]}) /mmoini "MyIni" "${CurrentSub}" "FadeConditions${i}" "12345"
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset FadeConditions${i} ${Ini[MyIni,Fade,FadeConditions${i},123456]}
		/if (${Range.Between[0,${FadeUseAtMyHP${i}}:${Me.PctHPs}]} && ${FadeConditions${i}} && ${Me.AltAbilityReady[${FadeSpellName${i}}]}) {
			/if (${Plugin[MQ2Twist].Name.Length}) {
				/if (${Twisting}) /twist stop
			}
			/attack off
			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> FADING
			/call ClearTarget
			/call ClearAttack
			/alt act ${Me.AltAbility[${FadeSpellName${i}}].ID}
			/if (${OptionsCheck.Find[FeignDeath]}) /varset FDAggro TRUE
		}
	/next i
/return
|fade end

|feigndeath start
Sub FeignDeathLoad
	/varset CurrentSub FeignDeath
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/call SpellLoad "FeignDeath" 2 "|1|18|3|4|6|9|11|30|" "|2|10|FALSE|----|----|10s|40|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "18|3|4|6|9|11|30|"
	/if (!${Defined[${CurrentSub}StandAtMyHP]}) /declare ${CurrentSub}StandAtMyHP int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}StandAtMyHP,-1]}
	/if (${FeignDeathStandAtMyHP}==-1) 	/mmoini "MyIni" "${CurrentSub}" "${CurrentSub}StandAtMyHP" "50"

	/declare FDAggro bool outer FALSE
/return

Sub FeignDeath
	/if (${Me.Hovering}) /return
	/varset CurrentSub FeignDeath
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${Me.Moving}||${Me.Invis}||!${${CurrentSub}Total}||${NeedLoad}) /return
	/declare i int local
	/for i 1 to ${${CurrentSub}Total}
		/if (!${Defined[${CurrentSub}Use${i}]}) /declare ${CurrentSub}Use${i} int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}Use${i},123456]}
		/if (!${Defined[${CurrentSub}Recast${i}]}) /declare ${CurrentSub}Recast${i} int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}Recast${i},123456]}
		/if (!${${CurrentSub}Use${i}} || ${${CurrentSub}Use${i}} == 123456) /continue
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset FeignDeathConditions${i} ${Ini[MyIni,FeignDeath,FeignDeathConditions${i},123456]}
		/if (!${CastIsReady}) {
			/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
		}
		/if (${CastIsReady} && ${${CurrentSub}Use${i}} && ${Me.Standing} && (${Hate}>=${${CurrentSub}After${i}}||${Me.PctHPs}<=${${CurrentSub}UseAtMyHP${i}}) && ${FeignDeathConditions${i}}) {
			/if (${${CurrentSub}SpellGem${i}.NotEqual[disc]}) /call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} NULL NULL NULL
			/if (${FDSpellGem.Equal[disc]}) /disc ${${CurrentSub}SpellName${i}}
			/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} Feigning Death"
    		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Me.CleanName}
    		/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Me.CleanName}
			/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
			/varset Hate 0
			/varset FDAggro TRUE
		}
		/if (${Me.PctHPs}>=${${CurrentSub}StandAtMyHP} && ${Me.Feigning} && !${${CurrentSub}Recast} && ${FDAggro}) {
		/stand
		/varset FDAggro FALSE
		}
	/next i
	
	
/return
|feigndeath end

|fightbuff start
Sub FightBuffLoad
	/varset CurrentSub FightBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/declare i int local 3
		/if (${Select[${Me.Class.ShortName},NEC]}) /varset i 1
		/if (${Select[${Me.Class.ShortName},PAL,CLR]}) /varset i 5
		/call SpellLoad "FightBuff" ${i} "|1|3|4|5|6|17|16|30|" "|${i}|TRUE|----|----|----|FALSE|FALSE|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "3|4|5|6|17|16|30|"
	/noparse /declare FightBuffList string outer (${MMOBugs.FreeBuffs} && ${FightBuffTotal} && (${FightBuffUse1} && !${Me.Buff[${FightBuffSpellIcon1}].ID} && ${Spell${FightBuffSpellIcon1}].Stacks}) || (${FightBuffUse2}&&!${Me.Buff[${FightBuffSpellIcon2}].ID} && ${Spell${FightBuffSpellIcon2}].Stacks}) || (${FightBuffUse3} && !${Me.Buff[${FightBuffSpellIcon3}].ID} && ${Spell${FightBuffSpellIcon3}].Stacks}) || (${FightBuffUse4} && !${Me.Buff[${FightBuffSpellIcon4}].ID} && ${Spell${FightBuffSpellIcon4}].Stacks}) || (${FightBuffUse5}&&!${Me.Buff[${FightBuffSpellIcon5}].ID} && ${Spell${FightBuffSpellIcon5}].Stacks}) || (${FightBuffUse6}&&!${Me.Buff[${FightBuffSpellIcon6}].ID} && ${Spell${FightBuffSpellIcon6}].Stacks}) || (${FightBuffUse7}&&!${Me.Buff[${FightBuffSpellIcon7}].ID} && ${Spell${FightBuffSpellIcon7}].Stacks}) || (${FightBuffUse8}&&!${Me.Buff[${FightBuffSpellIcon8}].ID} && ${Spell${FightBuffSpellIcon8}].Stacks}) || (${FightBuffUse9}&&!${Me.Buff[${FightBuffSpellIcon9}].ID} && ${Spell${FightBuffSpellIcon9}].Stacks}) || (${FightBuffUse10}&&!${Me.Buff[${FightBuffSpellIcon10}].ID} && ${Spell${FightBuffSpellIcon10}].Stacks}))
/return

Sub FightBuff
	/if (${Me.Hovering}) /return
	/varset CurrentSub FightBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
  	/if (${ImNotReady}||!${${CurrentSub}Total}||${NeedLoad}) /return
	/declare i int local
	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset FightBuffConditions${i} ${Ini[MyIni,FightBuff,FightBuffConditions${i},123456]}
		/if (!${CastIsReady}) {
			/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
		}
		/if (${CastIsReady} && !${Me.Buff[${FightBuffSpellIcon${i}}].ID} && !${Me.Song[${FightBuffSpellIcon${i}}].ID} && ${Spell[${FightBuffSpellIcon${i}}].Stacks} && ${FightBuffUse${i}} && ${FightBuffConditions${i}}) {
			/if ((${ValidNamed}||${NamedOk}) && ${AggroOk}) {
				/call ${EchoSub} "${White} ${${CurrentSub}SpellName${i}}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
				/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
				/if (${ExitSubEarly}) /return
			}
		}
	/next i
/return
|fightbuff end

|follow start
Sub FollowLoad
	/varset CurrentSub Follow
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${FollowLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare FollowMethod string outer ${Ini[MyIni,Follow,FollowMethod]}
	/if (!${FollowMethod.Length}||${FollowMethod.Equal[NULL]}) /mmoini "MyIni" "Follow" "FollowMethod" "stick|30 healer"
	/declare DistanceToFollow int outer ${Ini[MyIni,Follow,DistanceToFollow,30]}
	/if (!${DistanceToFollow}) /mmoini "MyIni" "Follow" "DistanceToFollow"
	/declare FollowCommand string outer ${Ini[MyIni,Follow,FollowCommand]}
	/if (!${FollowCommand.Length}||${FollowCommand.Equal[NULL]}) /mmoini "MyIni" "Follow" "FollowCommand" "FollowCommand"
	/declare StopFollowCommand string outer ${Ini[MyIni,Follow,StopFollowCommand]}
	/if (!${StopFollowCommand.Length}||${StopFollowCommand.Equal[NULL]}) /mmoini "MyIni" "Follow" "StopFollowCommand" "StopFollowCommand"
	/declare MoveUpCommand string outer ${Ini[MyIni,Follow,MoveUpCommand]}
	/if (!${MoveUpCommand.Length}||${MoveUpCommand.Equal[NULL]}) /mmoini "MyIni" "Follow" "MoveUpCommand" "MoveUpCommand"
	/if (!${Defined[Following]}) /declare Following int outer
	/if (!${Defined[MoveID]}) /declare MoveID int outer
	/if (!${Defined[NameToFollow]}) /declare NameToFollow string outer
	/if (!${Defined[FollowingCheckTime]}) /declare FollowingCheckTime string outer ${Ini[MyIni,Follow,FollowingCheckTime,10s]}
	/squelch /moveto set trytojump on
	/squelch /moveto set stucklogic on
/return

Sub Follow
	/if (!${Defined[FollowLoaded]}) /call FollowLoad
	/if (!${Spawn[id ${MoveID}].ID}||!${Following}) /return
	/if (${Spawn[id ${MoveID}].Distance}>${DistanceToFollow}) {
		/if (${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]}) /delay 15s !${Me.Casting.ID}
		/if (${Navigation}) {
			/if (${FollowMethod.Find[nav]} && !${Navigation.Active}) /nav  name "${NameToFollow}"
		}
		/if (${FollowMethod.Find[stick]} && !${Stick.Distance}) /stick id ${MoveID} ${FollowMethod.Arg[2,|]}
		/if (${FollowMethod.Find[adv]}) {
			/if (${AdvPath.State}!=1) /afollow spawn ${MoveID}
		}
		/if (${FollowMethod.Find[keypress]} && !${Me.Moving}) /call MoveToLoc ${Spawn[id ${MoveID}].Y} ${Spawn[id ${MoveID}].X}
	}
/return

Sub FollowCheck
	/if (${Following}) {
		/if (!${Defined[followwait]}) /declare followwait timer outer
		/varset followwait ${FollowingCheckTime}
		
		:wait
		/if (!${Spawn[pc ${NameToFollow}].ID} && ${followwait}) {
			/doevents
			/goto :wait
		}
			
		/varset MoveID ${Spawn[pc ${NameToFollow}].ID}
		
		/echo Following ${NameToFollow} - ID: ${MoveID}
		/if (${Me.Casting.ID} && !${Me.Class.ShortName.Equal[BRD]}) /delay 5s !${Me.Casting.ID}
		/if (${Navigation}) {
			/if (${FollowMethod.Find[nav]} && !${Navigation.Active}) /nav spawn pc ${NameToFollow}
		}
		/if (${FollowMethod.Find[stick]} && !${Stick.Distance}) /stick id ${MoveID} ${FollowMethod.Arg[2,|]}
		/if (${FollowMethod.Find[adv]}) {
			/if (${AdvPath.State}!=1) /afollow spawn ${MoveID}
		}
		/if (${FollowMethod.Find[keypress]} && !${Me.Moving}) /call MoveToLoc ${Spawn[id ${MoveID}].Y} ${Spawn[id ${MoveID}].X}
		/call Follow
	}
/return

Sub Event_Follow(followname,int moveup)
	/if (!${Defined[FollowLoaded]}) /call FollowLoad
	/if (!${Spawn[pc ${followname}].ID}) /return

	/varset NameToFollow ${followname}
	/varset MoveID ${Spawn[pc ${followname}].ID}
	
	/call Debug 1 "Following ${NameToFollow} - ID: ${MoveID}"

	/if (!${moveup}) /varset Following 1
	
	/varset UseCamp FALSE
	/if (${Navigation}) {
		/if (${FollowMethod.Find[nav]} && !${Navigation.Active}) /nav spawn pc ${NameToFollow}
	}
	/if (${moveup}) {
		/moveto loc ${Spawn[id ${MoveID}].Y} ${Spawn[id ${MoveID}].X} ${Spawn[id ${MoveID}].Z} loose
		/return
	}

	/if (${FollowMethod.Find[stick]}) /stick id ${Spawn[pc ${followname}].ID} ${FollowMethod.Arg[2,|]}
	/if (${FollowMethod.Find[adv]}) /afollow spawn ${Spawn[pc ${followname}].ID}
	
	/call Follow
/return

Sub Event_StopFollow
	/varset Following 0
	/varset MoveID 0
	/varset NameToFollow
	/keypress back
	/if (${Stick.Distance}) /stick off
	/if (${FollowMethod.Find[adv]}) /afollow off
/return
|stop follow

|GroupFightBuff start
Sub GroupFightBuffLoad
	/varset CurrentSub GroupFightBuff
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (!${Defined[gmember]}) /declare gmember int outer
	/if (!${Defined[GroupFightBuffXTargets]}) /declare GroupFightBuffXTargets bool outer ${Ini[MyIni,GroupFightBuff,GroupFightBuffXTargets,FALSE]}
	/if (!${GroupFightBuffXTargets}) /mmoini "MyIni" "GroupFightBuff" "GroupFightBuffXTargets" "FALSE"
	/if (!${Defined[GroupFightBuffPets]}) /declare GroupFightBuffPets bool outer ${Ini[MyIni,GroupFightBuff,GroupFightBuffPets,FALSE]}
	/if (!${GroupFightBuffPets}) /mmoini "MyIni" "GroupFightBuff" "GroupFightBuffPets" "FALSE"
	/if (${NeedLoad} && !${tempsubtotal}) {
		/declare i int local 1
		/if (${Select[${Me.Class.ShortName},SHM,CLR,DRU]}) /varset i 3
		/call SpellLoad "GroupFightBuff" ${i} "|1|3|4|6|9|30|24|" "|${i}|TRUE|----|----|1m|TRUE|BER,BRD,BST,CLR,DRU,ENC,MAG,MNK,NEC,PAL,RNG,ROG,SHD,SHM,WAR,WIZ|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|9|30|24|"
/return

Sub GroupFightBuff
	/if (${Me.Hovering}) /return
	/varset CurrentSub GroupFightBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (!${Group}) /return
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/declare i int local
	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
		/for gmember 1 to ${Group}
			/if (!${Defined[${CurrentSub}IgnoreRecast${i}_${Group.Member[${gmember}].ID}]}) /declare ${CurrentSub}IgnoreRecast${i}_${Group.Member[${gmember}].ID} int outer 1
			/if (${${CurrentSub}Recast${i}_${Group.Member[${gmember}].ID}} && !${${CurrentSub}IgnoreRecast${i}_${Group.Member[${gmember}].ID}}||!${GroupFightBuffClasses.Find[${Group.Member[${gmember}].Class.ShortName}]}) /goto :pets
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
			/if (!${CastIsReady}) {
				/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
			}
			/if (${CastIsReady} && ${GroupFightBuffConditions${i}}) {
				/if (${Target.ID}!=${Group.Member[${gmember}].ID}) /squelch /tar id ${Group.Member[${gmember}].ID}
				/delay 1s ${Target.ID}==${Group.Member[${gmember}].ID}
				/call ${EchoSub} "${Green} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
				/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 5s CheckStuff NULL
				/delay 3s !${Me.Casting.ID}
				/if (${Select[${Macro.Return},CAST_SUCCESS,CAST_NOTHOLD]}) {
					/varset GroupFightBuffRecast${i}_${Target.ID} ${Ini[MyIni,GroupFightBuff,GroupFightBuffRecast${i}]}
					/if (${${CurrentSub}IgnoreRecast${i}}_${Target.ID}) /varset ${CurrentSub}IgnoreRecast${i}_${Target.ID} 0
					/if (${ExitSubEarly}) /return
				}
			}
			
			:pets
			/if (!${GroupFightBuffPets}) /break
			/if (${Group.Member[${gmember}].Pet.ID} && !${Defined[${CurrentSub}IgnoreRecast${i}_${Group.Member[${gmember}].Pet.ID}]}) /declare ${CurrentSub}IgnoreRecast${i}_${Group.Member[${gmember}].Pet.ID} int outer 1
			/if (${${CurrentSub}Recast${i}_${Group.Member[${gmember}].Pet.ID}} && !${${CurrentSub}IgnoreRecast${i}_${Group.Member[${gmember}].Pet.ID}}||!${GroupFightBuffClasses.Find[${Group.Member[${gmember}].Pet.Class.ShortName}]}) /goto :xtarget
			/varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
			/if (${CastIsReady} && ${GroupFightBuffConditions${i}}) {
				/if (${Target.ID}!=${Group.Member[${gmember}].Pet.ID}) /squelch /tar id ${Group.Member[${gmember}].ID}
				/delay 1s ${Target.ID}==${Group.Member[${gmember}].Pet.ID}
				/call ${EchoSub} "${Green} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
				/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 5s CheckStuff NULL
				/delay 3s !${Me.Casting.ID}
				/if (${Select[${Macro.Return},CAST_SUCCESS,CAST_NOTHOLD]}) {
					/varset GroupFightBuffRecast${i}_${Target.ID} ${Ini[MyIni,GroupFightBuff,GroupFightBuffRecast${i}]}
					/if (${${CurrentSub}IgnoreRecast${i}}_${Target.ID}) /varset ${CurrentSub}IgnoreRecast${i}_${Target.ID} 0
					/if (${ExitSubEarly}) /return
				}
			}

		/next gmember
		:next
		:xtarget
		
		|** Commenting out this dead code; looks like incomplete code for doing different types of group fight buffs
		 ** This code can likely be removed entirely, but leaving as placeholder in case this is a feature in need of finishing
		 ** /if (!${GroupFightBuffXTargets}) /continue
		 ** /for gmember 1 to ${XTarget.Max} 
			  | The code for this loop is missing ~Chatwiththisname~
		 ** /next gmember
        **|
		:skip
	/next i

	:exitmtb
/return

|GroupFightBuff end

|Heal start

|TODO: This sub does nothing?  Is it ever called?
Sub healload
/return

Sub HealSingleLoad
	/if (${Select[${Me.Class.ShortName},MAG]}) /return
	/varset CurrentSub HealSingle
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 3
	/if (${Select[${Me.Class.ShortName},PAL,RNG]}) /varset i 4
	/if (${Select[${Me.Class.ShortName},CLR]}) /varset i 8
	/if (${Select[${Me.Class.ShortName},NEC]}) /varset i 1
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/mmoini "MyIni" "${CurrentSub}" "HealPullerName" "${Group.Puller}"
		/mmoini "MyIni" "${CurrentSub}" "HealPullerDist" "50"
		/mmoini "MyIni" "Settings" "InterruptToHealAt" "50"
		/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM]}) /call SpellLoad "HealSingle" ${i} "|1|3|4|6|21|22|9|30|" "|${i}|TRUE|----|----|80|90|1s|TRUE|"
		/if (!${Select[${Me.Class.ShortName},CLR,DRU,SHM]}) /call SpellLoad "HealSingle" ${i} "|1|3|4|6|21|22|9|30|" "|${i}|TRUE|----|----|50|90|1s|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|9|30|"
	/if (!${Defined[healtemptarget]}) /declare healtemptarget int outer
	/if (!${Defined[HealPullerDist]}) /declare HealPullerDist int outer ${Ini[MyIni,${CurrentSub},HealPullerDist,50]}
	/if (!${Defined[HealPuller]}) /declare HealPuller string outer ${Ini[MyIni,${CurrentSub},HealPullerName,${Group.Puller}]}
	/if (!${Defined[InterruptToHealAt]}) /declare InterruptToHealAt int outer ${Ini[MyIni,Settings,InterruptToHealAt,1]}
	/if (!${Defined[gmember]}) /declare gmember int outer
/return

Sub HealPetLoad
	/varset CurrentSub HealPet
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 2
	/if (${Select[${Me.Class.ShortName},BST,MAG,NEC]}) /varset i 2
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
 		/call SpellLoad "HealPet" ${i} "|1|3|4|6|21|22|9|30|" "|${i}|TRUE|----|----|50|90|1s|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|9|30|"
	/if (!${Defined[healtemptarget]}) /declare healtemptarget int outer
	/if (!${Defined[gmember]}) /declare gmember int outer
/return

Sub HealGroupLoad
	/if (${Select[${Me.Class.ShortName},MAG]}) /return
	/varset CurrentSub HealGroup
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 0
	/if (${Select[${Me.Class.ShortName},PAL,DRU,SHM,CLR]}) /varset i 3
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "HealGroup" ${i} "|1|3|4|6|21|22|23|30|" "|${i}|TRUE|----|----|50|80|60|TRUE|"
		/mmoini "MyIni" "Settings" "InterruptToHealAt" "50"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|23|30|"
	/if (!${Defined[InterruptToHealAt]}) /declare InterruptToHealAt int outer ${Ini[MyIni,Settings,InterruptToHealAt,1]}
/return

Sub HealSelfLoad
	/if (${Select[${Me.Class.ShortName},MAG]}) /return
	/varset CurrentSub HealSelf
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 0
	/if (${Select[${Me.Class.ShortName},PAL]}) /varset i 2
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "HealSelf" ${i} "|1|3|4|6|21|22|30|" "|${i}|TRUE|----|----|30|90|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|30|"
	/if (!${Defined[InterruptToHealAt]}) /declare InterruptToHealAt int outer ${Ini[MyIni,Settings,InterruptToHealAt,1]}
/return

Sub HealBalanceLoad
	/if (${Select[${Me.Class.ShortName},MAG]}) /return
	/varset CurrentSub HealBalance
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 0
	/if (${Select[${Me.Class.ShortName},CLR]}) /varset i 2
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|21|22|30|" "|${i}|TRUE|----|----|30|70|TRUE|"
		/mmoini "MyIni" "Settings" "InterruptToHealAt" "50"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|30|"
	/if (!${Defined[InterruptToHealAt]}) /declare InterruptToHealAt int outer ${Ini[MyIni,Settings,InterruptToHealAt,1]}
/return

Sub HealSplashLoad
	/if (${Select[${Me.Class.ShortName},MAG]}) /return
	/varset CurrentSub HealSplash
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 0
	/if (${Select[${Me.Class.ShortName},PAL,CLR]}) /varset i 2
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|23|" "|${i}|TRUE|----|----|60|"
	}
	/call SpellLoad2 "${CurrentSub}" "3|4|6|23|"
/return

Sub Heal
	/if (${Me.Hovering}) /return
	/if (${MMOBugs.ZoneSecs} && ${MMOBugs.ZoneSecs}<20) /return
	/if (${Defined[InterruptToHealAt]} && ${Defined[LifetapTotal]}) {
		/if (${OptionsCheck.Find[Lifetap]} && ${LifetapTotal} && ${Me.PctHPs}<=${InterruptToHealAt}) /call Lifetap
	}
	/if (!${OptionsCheck.Find[Heal]}) /return
	
	/if (!${Defined[HealBalanceTotal]}) /declare HealBalanceTotal bool outer FALSE
	/if (${HealBalanceTotal}) /call HealBalance	

	/if (!${Defined[HealSelfTotal]}) /declare HealSelfTotal bool outer FALSE
	/if (${HealSelfTotal}) /call HealSelf
	
	/if (!${Defined[HealGroupTotal]}) /declare HealGroupTotal bool outer FALSE
	/if (${HealGroupTotal}) /call HealGroup
	
	/if (!${Defined[HealSingleTotal]}) /declare HealSingleTotal bool outer FALSE
	/if (${HealSingleTotal}) /call HealSingle
	
	/if (!${Defined[HealSplashTotal]}) /declare HealSplashTotal bool outer FALSE
	/if (${HealSplashTotal}) /call HealSplash
	
	/if (!${Defined[HealPetTotal]}) /declare HealPetTotal bool outer FALSE
	/if (${HealPetTotal}) /call HealPet
	
	
	/doevents
/return

Sub HealBalance
	/varset CurrentSub HealBalance
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${ImNotReady}||${NeedLoad}||${Select[${Me.Class.ShortName},MAG]}) /return
	/if (!${${CurrentSub}Total}) /return
	/declare g int local
	/declare i int local
 	/for i 1 to ${${CurrentSub}Total}
 		/if (!${${CurrentSub}Use${i}}) /continue
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) 			/varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
    	/for g 0 to ${Group}
			/if (!${CastIsReady}) {
				/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
			}
			/if (${${CurrentSub}Conditions${i}} && ${Group.Member[${g}].ID} && ${Range.Between[1,${${CurrentSub}UseAt${i}}:${Group.Member[${g}].PctHPs}]} && ${Group.Member[${g}].Type.NotEqual[corpse]} && ${Spawn[${Group.Member[${g}].ID}].Distance}<50 && ${CastIsReady}) {
				/delay 2s !${Me.Casting.ID}
								/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
				/if (${${CurrentSub}SpellGem${i}.NotEqual[item]}) {
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} NULL NULL NULL
					/delay 3
				}
				/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
					/keypress f10
					/face
					/delay 5
					/click left center
					/keypress f10
				}
				/if (${${CurrentSub}SpellGem${i}.Equal[item]} && ${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=${${CurrentSub}SpellName${i}}].ItemSlot} ${FindItem[=${${CurrentSub}SpellName${i}}].ItemSlot2}
				/if (${${CurrentSub}SpellGem${i}.Equal[item]} && !${Me.HaveExpansion[Veil of Alaris]}) /casting "${${CurrentSub}SpellName${i}}"|item		
			}
		/next g
	:skip
 	/next i
/return

Sub HealGroup
	/if (${Me.Hovering}) /return
	/varset CurrentSub HealGroup
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${ImNotReady}||${NeedLoad}||${Select[${Me.Class.ShortName},MAG]}) /return
	/if (!${${CurrentSub}Total}) /return
	/if (!${Defined[grpavg]}) /declare grpavg int outer
	/if (!${Defined[currheal]}) /declare currheal int outer
	/declare grpttl int local
	/declare grpcnt int local
	/declare i int local
	/declare g int local
   	
	/for g 0 to ${Group}
		/if (${Group.Member[${g}].Type.Equal[pc]}||${Group.Member[${g}].Type.Equal[mercenary]}) {
			/varcalc grpcnt ${grpcnt}+1
			/if (${Group.Member[${g}].PctHPs}>=0) /varcalc grpttl ${grpttl}+${Group.Member[${g}].PctHPs}
			/varset grpavg ${Math.Calc[${grpttl}/${grpcnt}]}
		}
	/next g
    
	/for g 0 to ${Group}
		/for i 1 to ${${CurrentSub}Total}
			/if (!${${CurrentSub}Use${i}}) /continue
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) 		/varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
			/if (${${CurrentSub}Conditions${i}} && ${Group.Member[${g}].ID} && (${Range.Between[1,${${CurrentSub}UseAt${i}}:${Group.Member[${g}].PctHPs}]}||${grpavg}<=${${CurrentSub}AvgHP${i}}) && ${Group.Member[${g}].Type.NotEqual[corpse]} && ${Spawn[id ${Group.Member[${g}].ID}].Distance}<50) {
				/if (!${CastIsReady}) {
					/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
				}
				/if (${CastIsReady}) {
					/delay 3s !${Me.Casting.ID}
					/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 3s CheckGroupHP NULL
					/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
						/keypress f10
						/face
						/delay 5
						/click left center
						/keypress f10
					}
				}
			}
		/next i
   	/next g
/return

Sub HealSelf
	/if (${Me.Hovering}) /return
	/varset CurrentSub HealSelf
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}||${ImNotReady}||${NeedLoad}||${Select[${Me.Class.ShortName},MAG]}||!${${CurrentSub}Total}) /return
	/declare i int local
	/if (!${Defined[healtemptarget]}) /declare healtemptarget int outer
	/varset healtemptarget 0
	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) 		/varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
		/if (!${CastIsReady}) {
			/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
		}
		/if (${${CurrentSub}Conditions${i}} && ${Range.Between[1,${${CurrentSub}UseAt${i}}:${Me.PctHPs}]} && ${CastIsReady}) {
			/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[pc]}||${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[single]}) {
				/varset healtemptarget ${Target.ID}
				/squelch /tar id ${Me.ID}
				/delay 1s ${Target.ID}==${Me.ID}
			}
			/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    		/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
			/call Debug 3 "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 3s CheckMyHP <~~Passed to /call cast in HealSelf
			/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 3s CheckMyHP NULL
			/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
				/keypress f10
				/face
				/delay 5
				/click left center
				/keypress f10
			}
		}
	:skip
	/next i
	/if (${healtemptarget} && ${Spawn[${healtemptarget}].Type.Equal[npc]}) /squelch /tar id ${healtemptarget}
/return

Sub HealSingle
	/if (${Me.Hovering}) /return
	/varset CurrentSub HealSingle
	/if (!${Defined[${CurrentSub}Loaded]}||${Select[${Me.Class.ShortName},MAG]}) /call ${CurrentSub}Load
	/if (${ImNotReady}||${NeedLoad}) /return
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${${CurrentSub}Total}) /return
	/varset healtemptarget 0
	/if (!${Defined[currheal]}) /declare currheal int outer

	/declare i int local
    /for gmember 0 to 5
		/for i 1 to ${${CurrentSub}Total}
			/if (!${${CurrentSub}Use${i}}) /continue
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
			/if (${${CurrentSub}Conditions${i}} && (${Range.Between[1,${${CurrentSub}UseAt${i}}:${Group.Member[${gmember}].PctHPs}]} && ${Spawn[id ${Group.Member[${gmember}].ID}].Distance}<${Spell[${${CurrentSub}SpellName${i}}].MyRange} && ${gmember} && (${Group.Member[${gmember}].ID}!=${Spawn[${HealPuller}].ID}||${Spawn[id ${Group.Member[${gmember}].ID}].Distance}<=${HealPullerDist}) && ${Group.Member[${gmember}].Type.NotEqual[corpse]} && !${HealSingleRecast${i}}||!${gmember} && ${Range.Between[1,${${CurrentSub}UseAt${i}}:${Me.PctHPs}]} && !${HealSingleRecast${i}})) {
				/if (!${CastIsReady}) {
					/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
				}
				/if (${CastIsReady}) {
					/varset healtemptarget ${Target.ID}
					/varset currheal ${i}
					/if (!${gmember}) /squelch /tar id ${Me.ID}
					/if (${gmember}) /squelch /tar id ${Group.Member[${gmember}].ID}
					/delay 1s ${Target.ID}==${Group.Member[${gmember}].ID}
					/delay 3s !${Me.Casting.ID}
					/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Debug 3 "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 3s CheckSingleHP <~~Passed to /call cast in HealSingle
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 3s CheckSingleHP NULL
					/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
						/keypress f10
						/face
						/delay 5
						/click left center
						/keypress f10
					}
					/delay 7s !${Me.Casting.ID}
					/if (${Select[${Macro.Return},CAST_SUCCESS,CAST_NOTHOLD]}) {
						/if (${gmember}!=0) {
							/if (!${Defined[HealSingleRecast${i}${Group.Member[${gmember}].ID}]}) /declare HealSingleRecast${i}${Group.Member[${gmember}].ID} timer outer
							/varset HealSingleRecast${i}${Group.Member[${gmember}].ID} ${Ini[MyIni,HealSingle,HealSingleRecast${i}]}
							/if (${debug}==3) /mqlog ${Me.Class} -  2645 /varset ${CurrentSub}Recast${i}${Group.Member[${gmember}].ID} ${${CurrentSub}Recast${i}.OriginalValue}
							/if (${debug}==3 && ${i}==1) /echo Debugging HealSingle Routine to mq2\logs\ThisMac.log   To end, type: /varset debug 0
						}
						/if (${gmember}==0) {
							/if (!${Defined[HealSingleRecast${i}${Me.ID}]}) /declare HealSingleRecast${i}${Me.ID} timer outer
							/varset HealSingleRecast${i}${Me.ID} ${Ini[MyIni,HealSingle,HealSingleRecast${i}]}
						}
				
					}
				}
			}
		:skip
		/next i
   	/next gmember
	/if (${healtemptarget}&&${Spawn[${healtemptarget}].Type.Equal[npc]}) /squelch /tar id ${healtemptarget}
/return

Sub HealPet
	/if (${Me.Hovering}) /return
	/varset CurrentSub HealPet
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${ImNotReady}||${NeedLoad}) /return
	/if (!${${CurrentSub}Total}) /return
	/varset healtemptarget 0
	/if (!${Defined[currheal]}) /declare currheal int outer
	/declare i int local
    /for gmember 0 to ${If[${Select[${Me.Class.ShortName},MAG,NEC,BST,SHD]},0,5]}
		/for i 1 to ${${CurrentSub}Total}
			/if (!${${CurrentSub}Use${i}}) /continue
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset HealPetConditions${i} ${Ini[MyIni,HealPet,HealPetConditions${i},123456]}
			/if (${HealPetConditions${i}} && (${Range.Between[1,${${CurrentSub}UseAt${i}}:${Group.Member[${gmember}].Pet.PctHPs}]} && (${Spawn[id ${Group.Member[${gmember}].ID}].Pet.Distance}<${Spell[${${CurrentSub}SpellName${i}}].MyRange}||${Spawn[id ${Group.Member[${gmember}].ID}].Pet.Distance}<${Spell[${${CurrentSub}SpellName${i}}].AERange} && ${Spell[${${CurrentSub}SpellName${i}}].AERange}))||${gmember}==0 && ${Range.Between[1,${${CurrentSub}UseAt${i}}:${Me.Pet.PctHPs}]}) {
				/if (${gmember} && ${HealPetRecast${i}${Group.Member[${gmember}].Pet.ID}}||!${gmember} && ${HealPetRecast${i}${Me.Pet.ID}}) /continue
				/if (!${CastIsReady}) {
					/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
				}
				/if (${CastIsReady}) {
					/varset healtemptarget ${Target.ID}
					/varset currheal ${i}
					/if (!${gmember}) /squelch /tar id ${Me.Pet.ID}
					/if (${gmember}) /squelch /tar id ${Group.Member[${gmember}].Pet.ID}
					/delay 1s ${Target.ID}==${Group.Member[${gmember}].Pet.ID}
					/delay 3s !${Me.Casting.ID}
					/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 8s NULL NULL
					/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
						/keypress f10
						/face
						/delay 5
						/click left center
						/keypress f10
					}
					/if (${Select[${Macro.Return},CAST_SUCCESS,CAST_NOTHOLD]}) {
						/if (${gmember}!=0) {
							/if (!${Defined[HealPetRecast${i}${Group.Member[${gmember}].Pet.ID}]}) /declare HealPetRecast${i}${Group.Member[${gmember}].Pet.ID} timer outer
							/varset HealPetRecast${i}${Group.Member[${gmember}].Pet.ID} ${Ini[MyIni,HealPet,HealPetRecast${i}]}
						}
						/if (${gmember}==0) {
							/if (!${Defined[HealPetRecast${i}${Me.Pet.ID}]}) /declare HealPetRecast${i}${Me.Pet.ID} timer outer
							/varset HealPetRecast${i}${Me.Pet.ID} ${Ini[MyIni,HealPet,HealPetRecast${i}]}
						}
					}
				}
			}
		:skip
		/next i
	/next gmember
	/if (${healtemptarget}&&${Spawn[${healtemptarget}].Type.Equal[npc]}) /squelch /tar id ${healtemptarget}
/return

Sub CheckGroupHP
	/declare i int local
	/declare stop int local
    /for i 0 to ${Group}
		/if (${Group.Member[${i}].ID} && ${Group.Member[${i}].PctHPs}<90  && ${Group.Member[${i}].Type.NotEqual[corpse]}) {
			/varset stop 1
		}
	/next i
	/if (!${stop}) /call Interrupt
/return

Sub CheckSingleHP
	/if (${Target.PctHPs}>=${${CurrentSub}StopAt${currheal}}) /call Interrupt
/return

Sub CheckMyHP
	/if (${Me.PctHPs}>90) /call Interrupt
/return

|TODO: HealSplash does nothing?
Sub HealSplash
	/varset CurrentSub HealSplash
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
/return

|splash clr start
#event ClrSplash "#*#splashc#*#"
Sub Event_ClrSplash
	/if (!${Defined[ClrSplash]}) /declare ClrSplash string outer
	/if (!${Defined[ClrSplashGem]}) /declare ClrSplashGem int outer
	/declare i int local
	/for i 1 to 12
		/if (${Me.Gem[${i}].Name.Find[splash]}) {
			/varset ClrSplash ${Me.Gem[${i}]}
			/varset ClrSplashGem ${i}
		}
	/next i

	:splashwait
	/if (${Me.Casting.ID}) /goto :splashwait
	/if (${ClrSplashGem} && ${Me.SpellReady[${ClrSplash}]}) {
		/cast ${ClrSplashGem}
		/call ${EchoSub} "${Teal} ${ClrSplash} --> ${White} Everyone"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${ClrSplash} --> Everyone
		/keypress F10
    	/delay 5
		/click left center
		/keypress F10
	}
/return
|splash clr end

|Splash pal start

#event PalSplash "#*#splashp#*#"
Sub Event_PalSplash
	/if (!${Defined[PalSplash]}) /declare PalSplash string outer
	/if (!${Defined[PalSplashGem]}) /declare PalSplashGem int outer
	/declare i int local
	/for i 1 to 12
		/if (${Me.Gem[${i}].Name.Find[splash]}) {
			/varset PalSplash ${Me.Gem[${i}]}
			/varset PalSplashGem ${i}
		}
	/next i

	:splashwait
	/if (${Me.Casting.ID}) /goto :splashwait
	/if (${PalSplashGem} && ${Me.SpellReady[${PalSplash}]}) {
		/cast ${PalSplashGem}
		/call ${EchoSub} "${Teal} ${PalSplash} --> ${White} Everyone"
    	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${PalSplash} --> Everyone
		/keypress F10
    	/delay 5
		/click left center
		/keypress F10
	}
/return
|splash pal end
|heal end

#event ImHit     "#1# punches YOU for #*#"
#event ImHit     "#1# crushes YOU for #*#"
#event ImHit     "#1# kicks YOU for #*#"
#event ImHit     "#1# pierces YOU for #*#"
#event ImHit     "#1# slashes YOU for #*#"
#event ImHit     "#1# hits YOU for #*#"
#event ImHit     "#1# mauls YOU for #*#"
#event ImHit     "#1# bashes YOU for #*#"
#event ImHit     "#*# YOU, but #*#"

Sub ImHitLoad
	/varset CurrentSub ImHit
	/if (!${Defined[ImHitLoaded]}) /declare ImHitLoaded bool outer FALSE
	/if (${ImHitLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 3
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|9|11|30|" "|${i}|FALSE|----|1s|30|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|9|11|30|"
/return

||Total|TotalIfNamed|Use|SpellName|SpellIcon|SpellGem|UseAtMobPctHP|StopAtMobPctHP|Recast|Value|UseAtMyHP
Sub Event_ImHit(line, string TargetName)
	/if (${Me.Hovering}||${Me.Feigning}) /return
	/varset CurrentSubHold ${CurrentSub}
	/varset CurrentSub ImHit
	/if (!${Defined[ImHitLoaded]}) /call ImHitLoad
	/declare i int local
	/if (!${ImHitTotal}) /return
	/if (!${Defined[tempsbid]}) /declare tempsbid int outer
	/varset tempsbid 0
	/if (${AmIPuller}) /return
 	/for i 1 to ${ImHitTotal}
 		/if (!${${CurrentSub}Use${i}}) /continue
		/if (${OptionsCheck.Find[|FeignDeath|]}) /call FeignDeath
  		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset ImHitConditions${i} ${Ini[MyIni,ImHit,ImHitConditions${i},123456]}
		/if (!${Defined[TargetName]}) /declare TargetName string outer NULL
   		/if (${Me.PctHPs}<=${ImHitUseAtMyHP${i}} && (${Me.AltAbilityReady[${ImHitSpellName${i}}]}||${Me.SpellReady[${ImHitSpellName${i}}]}||${FindItem[${ImHitSpellName${i}}].InvSlot} && !${FindItem[${ImHitSpellName${i}}].Timer}||${Me.CombatAbilityReady[${ImHitSpellName${i}}]}) && (${Me.TargetOfTarget.ID}==${Me.ID}||${Spell[${ImHitSpellName${i}}].TargetType.NotEqual[Target of Target]}) && ${ImHitUse${i}} && ${ImHitConditions${i}}) {
			/if ((${Spell[${ImHitSpellName${i}}].TargetType.Equal[Single]} && ${Spell[${ImHitSpellName${i}}].SpellType.Equal[detrimental]}||${Spell[${ImHitSpellName${i}}].TargetType.Equal[Target of Target]}) && ${Target.CleanName.NotEqual[${TargetName}]}) /squelch /tar ${TargetName} npc
			/if (${Select[${Spell[${ImHitSpellName${i}}].TargetType},single]} ${Spell[${ImHitSpellName${i}}].SpellType.Equal[beneficial]} && ${Target.ID}!=${Me.ID}) {
				/varset tempsbid ${Target.ID}
				/squelch /tar id ${Me.ID}
			}

			/call ${EchoSub} "${Yellow} ${ImHitSpellName${i}} --> ${White} ${Target}"
    		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${ImHitSpellName${i}} --> ${Target.CleanName}
    		/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${ImHitSpellName${i}} --> ${Target.CleanName}
			/if (${ImHitSpellName${i}.Equal[Beam of Slumber]}) {
				/varset BeamTimer ${BeamTimer.OriginalValue}
				/face
			}
			/if (${Me.AltAbilityReady[${ImHitSpellName${i}}]}) /alt act ${Me.AltAbility[${ImHitSpellName${i}}].ID}
			/if (${Me.SpellReady[${ImHitSpellName${i}}]}) /call Cast "${ImHitSpellName${i}}" gem${Me.Gem[${ImHitSpellName${i}}]} NULL NULL NULL
			/if (${Me.CombatAbilityReady[${ImHitSpellName${i}}]}) /disc ${ImHitSpellName${i}}
			/if (${Me.AbilityReady[${ImHitSpellName${i}}]}) /doability "${ImHitSpellName${i}}"
			/if (${FindItem[${ImHitSpellName${i}}].InvSlot} && !${FindItem[${ImHitSpellName${i}}].Timer} && ${Me.HaveExpansion[Veil of Alaris]})  /useitem ${FindItem[=${ImHitSpellName${i}}].ItemSlot} ${FindItem[=${ImHitSpellName${i}}].ItemSlot2}
			/if (${FindItem[${ImHitSpellName${i}}].InvSlot} && !${FindItem[${ImHitSpellName${i}}].Timer} && !${Me.HaveExpansion[Veil of Alaris]})  /casting "${ImHitSpellName${i}}"|item
		}
	:skip
	/next i
	
	/if (${tempsbid}&&${Spawn[${tempsbid}].Type.Equal[npc]}) /squelch /tar id ${tempsbid}
	/if (${AssistType}==5 && (!${Target.ID}||!${Target.Type.Equal[npc]} && !${Target.Master.Type.Equal[npc]}) && ${Me.XTarget[1].ID}) /squelch /tar ${Me.XTarget[1]}
	/varset CurrentSub ${CurrentSubHold}
	:skipitall
/return

|imhit end


|jolt start
Sub JoltLoad
	/varset CurrentSub Jolt
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 1
	/if (${Select[${Me.Class.ShortName},WIZ]}) /varset i 4
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|18|3|4|6|7|8|9|10|17|31|" "|${i}|10|FALSE|----|----|96|5|18s|10|FALSE|85|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|18|4|6|7|8|9|10|17|31|"
/return

Sub Jolt
	/if (${Me.Hovering}) /return
	/varset CurrentSub Jolt
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${ImNotReady}||${NeedLoad}) /return
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${${CurrentSub}Total}) /return
 	/declare i int local
 	/declare x int local
 	/declare jolt int local
 	/for i 1 to ${XTarget.Max}
 		/if (${Me.XTarget[${i}].PctAggro}>${jolt} && ${Me.XTarget[${i}].Distance}<40) /varset jolt ${Me.XTarget[${i}].PctAggro}
 	/next i
 	/if (${Target.ID} && ${Target.PctAggro}>${jolt}) /varset jolt ${Target.PctAggro}
 	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
			/if (${Hate}>=${${CurrentSub}After${i}}||${Me.PctAggro}>${JoltAtAggroPct${i}}||${jolt}>${JoltAtAggroPct${i}}) {
				/if (!${CastIsReady}) {
					/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
				}
				/if (${CastIsReady} && ${ShouldCastOnMob} && ${ValidEnemy}) {
					/if (${Spell[${${CurrentSub}SpellName${i}}].Slot[1].Find[Feign Death]})  {
						/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} -- ${White} Feigning Aggro"
						/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
						/if (${${CurrentSub}SpellGem${i}.Equal[disc]})  /disc ${${CurrentSub}SpellName${i}}
						/if (${${CurrentSub}SpellGem${i}.NotEqual[disc]})  /call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} NULL NULL NULL
						/if (${Select[${Me.Class.ShortName},SHD,NEC,MNK,BST]}) /delay 2s
						/if (${Me.PctHPs}>40 && ${Me.Feigning}) /stand on
						/goto :joltannounced
					}
					/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
					/if (${${CurrentSub}SpellGem${i}.NotEqual[disc]})  /call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} NULL NULL NULL
					/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/if (${${CurrentSub}SpellGem${i}.Equal[disc]})  /disc ${${CurrentSub}SpellName${i}}
					
					:joltannounced
					/if (${CastCounts}) {
						/varset Hate ${Math.Calc[${Hate}-${${CurrentSub}Value${i}}]}
						/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
					}	
				}
			}
		}
	:skip
	/next i
/return
|jolt end

|lifetap start
Sub LifetapLoad
	/varset CurrentSub Lifetap
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/if (!${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}Total" "0"
	/if (!${Defined[${CurrentSub}Total]}) /declare ${CurrentSub}Total int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal}) {
		/if (${Me.Class.ShortName.Equal[SHD]})	/call SpellLoad "${CurrentSub}" 5 "|1|2|3|4|6|11|30|" "|4|4|FALSE|----|----|70|TRUE|"
		/if (${Me.Class.ShortName.Equal[NEC]})	/call SpellLoad "${CurrentSub}" 2 "|1|2|3|4|6|11|30|" "|2|2|TRUE|----|----|70|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "3|4|6|11|30|"
	/if (!${Defined[InterruptToLifetapAt]}) /declare InterruptToLifetapAt int outer ${Ini[MyIni,Lifetap,InterruptToLifetapAt,-1]}
	/if (${InterruptToLifetapAt}==-1) /mmoini "MyIni" "Lifetap" "InterruptToLifetapAt" "30"
	/if (!${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}Conditions" "TRUE"
	/if (!${Defined[${CurrentSub}Conditions]}) /declare ${CurrentSub}Conditions bool outer ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions]}
	/declare i int local 0
	/for i 1 to ${tempsubtotal}
		/if (!${Defined[${CurrentSub}SpellName${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}SpellName${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}SpellName${i}" "12345"
			/declare ${CurrentSub}SpellName${i} string outer ${Ini[MyIni,${CurrentSub},${CurrentSub}SpellName${i},12345]}
		}
		/if (!${Defined[${CurrentSub}SpellGem${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}SpellGem${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}SpellGem${i}" "12345"
			/declare ${CurrentSub}SpellGem${i} string outer ${Ini[MyIni,${CurrentSub},${CurrentSub}SpellGem${i},12345]}
		}
		/if (!${Defined[${CurrentSub}IgnoreRecast${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}IgnoreRecast${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}IgnoreRecast${i}" "TRUE"
			/declare ${CurrentSub}IgnoreRecast${i} bool outer ${Ini[MyIni,${CurrentSub},${CurrentSub}IgnoreRecast${i},FALSE]}
		}
		/if (!${Defined[${CurrentSub}Recast${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}Recast${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}Recast${i}" "TRUE"
			/declare ${CurrentSub}Recast${i} bool outer ${Ini[MyIni,${CurrentSub},${CurrentSub}Recast${i},FALSE]}
		}
		/if (!${Defined[${CurrentSub}StopAtMobPctHP${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}StopAtMobPctHP${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}StopAtMobPctHP${i}" "21"
			/declare ${CurrentSub}StopAtMobPctHP${i} int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}StopAtMobPctHP${i},21]}
		}
		/if (!${Defined[${CurrentSub}UseAtMobPctHP${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}UseAtMobPctHP${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}UseAtMobPctHP${i}" "${AssistAt}"
			/declare ${CurrentSub}UseAtMobPctHP${i} int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}UseAtMobPctHP${i},75]}
		}
		/if (!${Defined[${CurrentSub}Use${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}Use${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}Use${i}" "FALSE"
			/declare ${CurrentSub}Use${i} bool outer ${Ini[MyIni,${CurrentSub},${CurrentSub}Use${i},FALSE]}
		}
		/if (!${Defined[${CurrentSub}MaxTries${i}]}) {
			/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}MaxTries${i}]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}MaxTries${i}" "TRUE"
			/declare ${CurrentSub}MaxTries${i} int outer ${Ini[MyIni,${CurrentSub},${CurrentSub}MaxTries${i},FALSE]}
		}
		/if (!${Defined[${CurrentSub}Resisted${i}]}) {
			/declare ${CurrentSub}Resisted${i} int outer 0
		}
		/if (!${Defined[${CurrentSub}On${i}]}) /declare ${CurrentSub}On${i} bool outer FALSE
	/next i
	
/return

Sub Lifetap
	/if (${Me.Hovering}) /return
	/varset CurrentSub Lifetap
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
    /if (${ImNotReady}||${NeedLoad}||${Target.PctHPs}>${AssistAt}) /return
    /if (!${${CurrentSub}Total}) /return
 	/declare i int local
 	/for i 1 to ${${CurrentSub}Total}
 		/if (!${${CurrentSub}Use${i}}) /continue
    	/if (${ValidEnemy}) {
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
			/if (!${CastIsReady}) {
					/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
				}
			/if (${ValidSpell} && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady} && ${Me.PctHPs}<=${${CurrentSub}UseAtMyHP${i}} && ${${CurrentSub}Conditions${i}}) {
				/if (${ResistCheck}) {
					/call ${EchoSub} "${Green} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" "${${CurrentSub}SpellGem${i}}" 3s "${CurrentSub}" 3
					/if (${CastCounts}) {
						/varcalc Hate ${Hate}+1
					}
    			}
 			}
		}
	:skip
 	/next i
/return
|lifetap end

|maintankbuff start
Sub MainTankBuffLoad
	/varset CurrentSub MainTankBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int 0
	/if (${Select[${Me.Class.ShortName},DRU,SHM]}) /varset i 5
	/if (${Select[${Me.Class.ShortName},CLR]}) /varset i 7
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/declare DesignatedTank string outer ${Ini[MyIni,MainTankBuff,DesignatedTank,NULL]}
	/if (${DesignatedTank.Equal[NULL]}) /mmoini "MyIni" "MainTankBuff" "DesignatedTank" "NULL"
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|21|22|17|9|30|" "|${i}|TRUE|----|----|100|5|FALSE|2m|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|17|9|30|"
/return

Sub MainTankBuff
	/if (${Me.Hovering}) /return
	/varset CurrentSub MainTankBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${Group.MainTank.ID}||${Group.MainTank.Spawn.Dead}||!${${CurrentSub}Total}||${NeedLoad}||${Group.MainTank.Distance}>75) /return
	/declare i int local
	/if (${Group.Member[${DesignatedTank}].Pet.ID}) /declare DTHPs int local ${Group.Member[${DesignatedTank}].Pet.PctHPs}
	/if (!${Group.Member[${DesignatedTank}].Pet.ID}) /declare DTHPs int local ${Spawn[${DesignatedTank}].PctHPs}
	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
		/if (!${Defined[${CurrentSub}IgnoreRecast${i}]}) /declare ${CurrentSub}IgnoreRecast${i} int outer 1
		|/echo 	/if (!${${CurrentSub}Use${i}}||${${CurrentSub}Recast${i}} && !${${CurrentSub}IgnoreRecast${i}}||${Me.AltAbility[${${CurrentSub}SpellName${i}}]} && !${Me.AltAbilityReady[${${CurrentSub}SpellName${i}}]}) /continue
		/if (!${${CurrentSub}Use${i}}||${${CurrentSub}Recast${i}} && !${${CurrentSub}IgnoreRecast${i}}||${Me.AltAbility[${${CurrentSub}SpellName${i}}]} && !${Me.AltAbilityReady[${${CurrentSub}SpellName${i}}]}) /continue
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset ${CurrentSub}Conditions${i} ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions${i},123456]}
		/if (${DesignatedTank.Equal[NULL]}||!${SpawnCount[${DesignatedTank}]}) /goto :maintank
	
		|Designated Tank
		/if (!${CastIsReady}) {
					/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
				}
		/if (${Range.Between[${${CurrentSub}StopAt${i}},${${CurrentSub}UseAt${i}}:${DTHPs}]} && (${Spawn[${TarID}].Name.Find[#]}||${Spawn[${TarID}].Named}||!${${CurrentSub}NamedOnly${i}}) && ${CastIsReady} && ${MainTankBuffConditions${i}}) {
			/if (${Group.Member[${DesignatedTank}].Pet.ID}) {
				/squelch /tar id ${Group.Member[${DesignatedTank}].Pet.ID}
				/delay 1s ${Group.Member[${DesignatedTank}].Pet.ID}
				/goto :castmt
			}
			
			/if (!${Group.Member[${DesignatedTank}].Pet.ID}) {
				/squelch /tar id ${Spawn[${DesignatedTank} pc].ID}
				/delay 1s ${Target.ID}==${Spawn[${DesignatedTank} pc].ID}
				/goto :castmt
			}
		}
		:maintank
		|Group.MainTank
		/if (${Range.Between[${${CurrentSub}StopAt${i}},${${CurrentSub}UseAt${i}}:${Group.MainTank.PctHPs}]} && (${Spawn[${TarID}].Name.Find[#]}||${Spawn[${TarID}].Named}||!${${CurrentSub}NamedOnly${i}}) && ${CastIsReady} && ${MainTankBuffConditions${i}}) {
			/if (${Target.ID}!=${Group.MainTank.ID}) {
				/if (${SpawnCount[pc ${Group.MainTank}]}) /squelch /tar ${Group.MainTank} pc
				/if (${SpawnCount[mercenary ${Group.MainTank}]}) /squelch /tar ${Group.MainTank} mercenary
				/if (!${SpawnCount[pc ${Group.MainTank}]} && !${SpawnCount[mercenary ${Group.MainTank}]}) /squelch /tar ${Group.MainTank}
			}
			/delay 1s ${Target.ID}==${Group.MainTank.ID}
			/goto :castmt
		}
		/continue
		:castmt
		/call ${EchoSub} "${Green} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
	   	/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
	   	/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
		/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
		/delay 3s !${Me.Casting.ID}
		/if (${Select[${Macro.Return},CAST_SUCCESS,CAST_NOTHOLD]}||${${CurrentSub}SpellName${i}.Find[ Retort]}) {
			/varset MainTankBuffRecast${i} ${Ini[MyIni,MainTankBuff,MainTankBuffRecast${i}]}
			/if (${${CurrentSub}IgnoreRecast${i}}) /varset ${CurrentSub}IgnoreRecast${i} 0
			/if (${ExitSubEarly}) /goto :exitmtb
		}
	:next
	:skip
	/next i
	:exitmtb
/return
|maintank end

|TODO: What?
Sub ModRodLoad
	/call ModRod
/return

Sub ModRod
	/if (${Me.Hovering}) /return
	|update alert
	/if (!${Defined[ModRodList]}) /declare ModRodList string outer |Summoned: Giant Modulation Shard|Summoned: Large Modulation Shard|Summoned: Medium Modulation Shard|Summoned: Small Modulation Shard|Rod of Arcane Transvergence|Rod of Spectral Transvergence|Rod of Ethereal Transvergence|Rod of Prime Transvergence|Wand of Elemental Transvergence|Rod of Mystical Transvergence|Summoned: Modulating Rod|Wand of Phantasmal Modulation|
	/declare i int local

	/for i 1 to ${Math.Calc[${ModRodList.Count[|]}-1]}
		/if (${FindItem[${ModRodList.Arg[${i},|]}].ItemSlot} && !${FindItem[${ModRodList.Arg[${i},|]}].Timer} && ${Me.CurrentHPs}>${Math.Abs[${Spell[${FindItem[${ModRodList.Arg[${i},|]}].Spell.ID}].Base[1]}]} && ${Math.Calc[${Me.MaxMana}-${Me.CurrentMana}]}>=${Spell[${FindItem[${ModRodList.Arg[${i},|]}].Spell.ID}].Base[2]}) {
			/if (${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=${ModRodList.Arg[${i},|]}].ItemSlot} ${FindItem[=${ModRodList.Arg[${i},|]}].ItemSlot2}
			/if (!${Me.HaveExpansion[Veil of Alaris]}) /casting "${ModRodList.Arg[${i},|]}"|item
			/call ${EchoSub} "${Green} ${ModRodList.Arg[${i},|]} -- ${White} ${Spell[${FindItem[${ModRodList.Arg[${i},|]}].Spell.ID}].Base[1]} HP Loss for ${Spell[${FindItem[${ModRodList.Arg[${i},|]}].Spell.ID}].Base[2]} Mana Gain"
		}
	/next i
/return

// ******* MANA *********
Sub Mana
	/if (${Me.Hovering}) /return
	/varset CurrentSub Mana
	/if (!${Bool[${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions]}]}) /mmoini "MyIni" "${CurrentSub}" "${CurrentSub}Conditions" "123456"
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${Me.Invis} && !${AutoInvis} && !${AutoBreakInvis}) /return
	/if (!${Defined[ManaLoaded]}) /call ManaLoad
	/if (${SpawnCount[pccorpse ${Me.CleanName}]}||${NeedLoad}) /return
	/declare i int

	/if (${Me.PctMana} < 10 && ${Me.PctHPs} > 50) {
		/if (${Me.Class.CanCast}) /call ModRod
	}
	
	/if (${Me.Class.ShortName.Equal[SHM]}) {
		/if (${Me.AltAbilityReady[Cannibalization]} && ${Me.CurrentHPs}>${Math.Abs[${Spell[${Me.AltAbility[Cannibalization].Spell.ID}].Base[1]}]} && ((${Math.Calc[${Me.MaxMana}-${Me.CurrentMana}]}>${Spell[${Me.AltAbility[Cannibalization].Spell.ID}].Base[2]}||${Me.PctMana}<=${MyManaLessThan}) && (${Me.PctMana}<=${DontUnlessMyManaLessThan}||!${DontUnlessMyManaLessThan}))) {
			/call ${EchoSub} "${Orange} Cannibalization -- ${White} ${Spell[${Me.AltAbility[Cannibalization].Spell.ID}].Base[1]} HP Loss for ${Spell[${Me.AltAbility[Cannibalization].Spell.ID}].Base[2]} Mana Gain"
			/alt act ${Me.AltAbility[Cannibalization].ID}
		}
		
		/if (!${Me.GemTimer[${${CurrentSub}Boost${Me.Class.ShortName}}]} && (${Me.CurrentHPs}>${Math.Abs[${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[1]}]}||${Me.CurrentHPs}>${MyHPMoreThan}) && (${Math.Calc[${Me.MaxMana}-${Me.CurrentMana}]}>=${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[2]}||${Me.PctMana}<${MyManaLessThan}) && ${Me.SpellReady[${${CurrentSub}Boost${Me.Class.ShortName}}]} && (${Me.PctMana}<=${DontUnlessMyManaLessThan}||!${DontUnlessMyManaLessThan})) {
			/call ${EchoSub} "${Orange}${${CurrentSub}Boost${Me.Class.ShortName}} -- ${White} ${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[1]} HP Loss for ${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[2]} Mana Gain"
			/call Cast "${${CurrentSub}Boost${Me.Class.ShortName}}" "${${CurrentSub}BoostGem${Me.Class.ShortName}}" 0 CheckStuff NULL
			/delay 5s !${Me.Casting.ID}
		}
	}
	
	/if (${Me.Class.ShortName.Equal[WIZ]} && (${Me.PctMana}<=25||${Me.CombatState.NotEqual[COMBAT]}) && !${Me.Casting.ID}) {
		/if (${Me.AltAbility[Harvest of Druzzil]} && (${Me.AltAbilityReady[Harvest of Druzzil]} && ${Me.PctMana}<=${MyManaLessThan}) && (${Me.PctMana}<=${DontUnlessMyManaLessThan}||!${DontUnlessMyManaLessThan})) {
			/call ${EchoSub} "${Orange} Harvest of Druzzil -- ${White} Mana Gain"
			/alt act ${Me.AltAbility[Harvest of Druzzil].ID}
			/delay 5s !${Me.Casting.ID}
		}	
	
		/if ((${Math.Calc[${Me.MaxMana}-${Me.CurrentMana}]}>=${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[1]}||${Me.PctMana}<${MyManaLessThan}) && ${Me.SpellReady[${${CurrentSub}Boost${Me.Class.ShortName}}]} && (${Me.PctMana}<=${DontUnlessMyManaLessThan}||!${DontUnlessMyManaLessThan})) {
			/call ${EchoSub} "${Orange}${${CurrentSub}Boost${Me.Class.ShortName}} -- ${White} ${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[1]} Mana Gain"
			/call Cast "${${CurrentSub}Boost${Me.Class.ShortName}}" "${${CurrentSub}BoostGem${Me.Class.ShortName}}" NULL NULL NULL
			/delay 5s !${Me.Casting.ID}
		}
	}

	/if (${Me.Class.ShortName.Equal[ENC]} && (${Me.PctMana}<=25||${Me.CombatState.NotEqual[COMBAT]}) && !${Me.Casting.ID}) {
		/if (${Me.AltAbility[Mana Draw]} && ${Me.AltAbilityReady[Mana Draw]} && ${Me.PctMana}<=5) {
			/call ${EchoSub} "${Orange} Mana Draw -- ${White} ${Spell[${Me.AltAbility[Mana Draw].Spell.ID}].Base[1]} Instant Mana Gain - ${Spell[${Me.AltAbility[Mana Draw].Spell.ID}].Base[7]} per tick for ${Spell[${Me.AltAbility[Mana Draw].Spell.ID}].Duration} ticks (${Math.Calc[${Spell[${Me.AltAbility[Mana Draw].Spell.ID}].Base[7]}*${Spell[${Me.AltAbility[Mana Draw].Spell.ID}].Duration}].Int} total)"
			/alt act ${Me.AltAbility[Mana Draw].ID}
			/delay 5s !${Me.Casting.ID}
		}	
	
		/if (${Me.AltAbility[Gather Mana]} && !${Me.AltAbility[Mana Draw]} && ${Me.AltAbilityReady[Gather Mana]} && ${Me.PctMana}<=5) {
			/call ${EchoSub} "${Orange} Gather Mana -- ${White} ${Spell[${Me.AltAbility[Gather Mana].Spell.ID}].Base[1]} Instant Mana Gain"
			/alt act ${Me.AltAbility[Gather Mana].ID}
			/delay 5s !${Me.Casting.ID}
		}	

		/if (${Me.PctMana}<${MyManaLessThan} && ${Me.AltAbilityReady[Fundament: Second Spire of Enchantment]} && ${Spell[Second Spire of Enchantment].Stacks}) {
			/call ${EchoSub} "${Orange} Fundament: Second Spire of Enchantment -- ${White} ${Me.AltAbility[Fundament: Second Spire of Enchantment].Spell.Base[9]} Mana Gain per tick for ${Me.AltAbility[Fundament: Second Spire of Enchantment].Spell.Duration} ticks (${Math.Calc[${Me.AltAbility[Fundament: Second Spire of Enchantment].Spell.Duration}*${Me.AltAbility[Fundament: Second Spire of Enchantment].Spell.Base[9]}].Int} total)"
			/if (${Target.ID}) /squelch /tar clear
			/alt act ${Me.AltAbility[Fundament: Second Spire of Enchantment].ID}
			/delay 5s !${Me.Casting.ID}
		}
	
		/for i 0 to 5
			/if (!${Select[${Group.Member[${i}].Class.ShortName},BRD,WAR,MNK,ROG,BER,SHM,NEC]} && ${Me.AltAbilityReady[Fundament: Second Spire of Enchantment]} && !${Me.Song[Fundament: Second Spire of Enchantment].ID} && !${Me.Buff[Fundament: Second Spire of Enchantment].ID} && ${Group.Member[${i}].PctMana}<=${TheirManaLessThan} && ${Group.Member[${i}].PctMana}>0 && !${SpawnCount[${Group.Member[${i}]} corpse]}) {
				/squelch /tar ${Group.Member[${i}]}
				/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
				/alt act ${Me.AltAbility[Fundament: Second Spire of Enchantment].ID}
				/call ${EchoSub} "${Orange} Fundament: Second Spire of Enchantment --> ${White} ${Target.CleanName}"
				/delay 2
				/squelch /tar clear
			}
		/next i
	
		/if (${Me.PctMana}>95 && ${Me.AltAbilityReady[Sanguine Mind Crystal]} && !${FindItemCount[Sanguine Mind Crystal]}) {
			/alt act ${Me.AltAbility[Sanguine Mind Crystal].ID}
			/call ${EchoSub} "${Teal} Sanguine Mind Crystal --> ${White} ${Me.CleanName}"
		}
	
		/if (${Me.PctMana}>95 && ${Me.AltAbilityReady[Azure Mind Crystal]} && !${FindItemCount[Azure Mind Crystal]}) {
			/alt act ${Me.AltAbility[Azure Mind Crystal].ID}
			/call ${EchoSub} "${Orange} Azure Mind Crystal --> ${White} ${Me.CleanName}"
		}
	
		/if (${Me.PctMana}<=20 && ${FindItemCount[Azure Mind Crystal]}) {
			/if (${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=Azure Mind Crystal].ItemSlot} ${FindItem[=Azure Mind Crystal].ItemSlot2}
		 	/if (!${Me.HaveExpansion[Veil of Alaris]}) /casting "Azure Mind Crystal"|item
			/call ${EchoSub} "${Orange} Azure Mind Crystal --> ${White} ${Math.Calc[${FindItem[Azure Mind Crystal].Spell.Base[1]} - 5 + ${Me.Level}*5].Int} mana gain"
		}
		
		/if (${Me.PctHPs}<=50 && ${FindItemCount[Sanguine Mind Crystal]}) {
			/if (${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=Sanguine Mind Crystal].ItemSlot} ${FindItem[=Sanguine Mind Crystal].ItemSlot2}
		 	/if (!${Me.HaveExpansion[Veil of Alaris]}) /casting "Sanguine Mind Crystal"|item
			/call ${EchoSub} "${Teal} Sanguine Mind Crystal --> ${White} [${FindItem[Sanguine Mind Crystal].Spell.Base[1]} hp gain"
		}
	
		/if (${Select[${Cursor.Name},Azure Mind Crystal,Sanguine Mind Crystal]}) /autoinv
	}

	/if (${Me.Class.ShortName.Equal[MAG]} && (${Me.PctMana}<=25||${Me.CombatState.NotEqual[COMBAT]}) && !${Me.Casting.ID}) {
		/if (${Me.PctMana}<20 && ${Me.AltAbilityReady[Mana Reserve]}) {
			/call ${EchoSub} "${Orange} Mana Reserve -- ${White} 12,000 Mana Gain"
			/alt act 2065
		}
	
		/if ((${Math.Calc[${Me.MaxMana}-${Me.CurrentMana}]}>=${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[1]}||${Me.PctMana}<${MyManaLessThan}) && ${Me.SpellReady[${${CurrentSub}Boost${Me.Class.ShortName}}]}) {
			/call ${EchoSub} "${Orange}${${CurrentSub}Boost${Me.Class.ShortName}} -- ${White} ${Spell[${${CurrentSub}Boost${Me.Class.ShortName}}].Base[1]} Mana Gain"
			/call Cast "${${CurrentSub}Boost${Me.Class.ShortName}}" "${${CurrentSub}BoostGem${Me.Class.ShortName}}" NULL NULL NULL
			/delay 5s !${Me.Casting.ID}
		}
		
		/if (${Me.AltAbility[Summon Modulation Shard].Rank} && ${Me.AltAbilityReady[Summon Modulation Shard]}) {
			/if ( ${Me.AltAbility[Summon Modulation Shard].Rank} == 4 && !${FindItem[Summoned: Giant Modulation Shard].ItemSlot} ) {
				/call Debug 3 "Summoning Giant Shard"
				/call Cast "Summon Modulation Shard" "alt" NULL NULL NULL
				/delay 50 !${Me.Casting.ID}
				/delay 5 ${Cursor.ID}
				/autoinv
			} else /if ( ${Me.AltAbility[Summon Modulation Shard].Rank} == 3 && !${FindItem[Summoned: Large Modulation Shard].ItemSlot} ) {
				/call Debug 3 "Summoning Large Shard"
				/call Cast "Summon Modulation Shard" "alt" NULL NULL NULL
				/delay 50 !${Me.Casting.ID}
				/delay 5 ${Cursor.ID}
				/autoinv
			} else /if ( ${Me.AltAbility[Summon Modulation Shard].Rank} == 2 && !${FindItem[Summoned: Medium Modulation Shard].ItemSlot} ) {
				/call Debug 3 "Summoning Medium Shard"
				/call Cast "Summon Modulation Shard" "alt" NULL NULL NULL
				/delay 50 !${Me.Casting.ID}
				/delay 5 ${Cursor.ID}
				/autoinv
			} else /if ( ${Me.AltAbility[Summon Modulation Shard].Rank} == 1 && !${FindItem[Summoned: Small Modulation Shard].ItemSlot} ) {
				/call Debug 3 "Summoning Small Shard"
				/call Cast "Summon Modulation Shard" "alt" NULL NULL NULL
				/delay 50 !${Me.Casting.ID}
				/delay 5 ${Cursor.ID}
				/autoinv
			}
		}
	}

	/if (${Me.Class.ShortName.Equal[NEC]}) {
		/if (!${Me.Song[Death Blossom].ID} && ${Me.AltAbility[Death Bloom]} && ${Me.AltAbilityReady[Death Bloom]} && ${Me.PctHPs}>=${MyHPMoreThan} && ${Me.PctMana}<=${MyManaLessThan} && (${Me.PctMana}<=${DontUnlessMyManaLessThan}||!${DontUnlessMyManaLessThan})) {
			/call ${EchoSub} "${Orange} Death Bloom -- ${White} 28000 HP Loss over time for 16800 Mana Gain"
			/alt act ${Me.AltAbility[Death Bloom].ID}
			/delay 5
			/delay 4s !${Me.Casting.ID}
		}
		
		/if ((${Me.CombatState.Equal[ACTIVE]}||${Me.CombatState.Equal[RESTING]}) && !${Me.Song[Death Blossom].ID} && ${Me.AltAbilityReady[Death Blossom]} && ${Me.PctHPs}>=${MyHPMoreThan} && ${Me.PctMana}<=${MyManaLessThan} && (${Me.PctMana}<=${DontUnlessMyManaLessThan}||!${DontUnlessMyManaLessThan})) {
			/call ${EchoSub} "${Orange} Death Blossom -- ${White} 3700 HP Loss over time for 2400 Mana Gain per tick"
			/alt act ${Me.AltAbility[Death Blossom].ID}
			/delay 5
			/delay 4s !${Me.Casting.ID}
		}
	
		|**
		/for i 0 to 5
			/if ((${Me.CombatState.Equal[ACTIVE]}||${Me.CombatState.Equal[RESTING]}) && !${Select[${Group.Member[${i}].Class.ShortName},BRD,WAR,MNK,ROG,BER,NEC]} && ${Me.AltAbilityReady[Death Blossom]} && !${Me.Song[Death Bloom].ID} && !${Me.Song[Death Blossom].ID} && ${Group.Member[${i}].PctMana}<=${TheirManaLessThan} && ${Group.Member[${i}].PctMana}>0 && !${SpawnCount[${Group.Member[${i}]} corpse]}) {
				/alt act ${Me.AltAbility[Death Blossom].ID}
				/call ${EchoSub} "${Orange} Death Blossom --> ${White} 3700 HP for 2300 mana per tick to group"
				/delay 5
				/delay 4s !${Me.Casting.ID}
			}	
		/next i
		**|
	}

	/if (${Me.Class.ShortName.Equal[BST]}) {
		/if (${Me.PctMana}<${MyManaLessThan} && ${Me.AltAbilityReady[Paragon of Spirit]} && ${Spell[Paragon of Spirit].Stacks} && !${Me.Song[Paragon of Spirit].ID} && !${Me.Song[Focused Paragon of Spirits].ID}) {
			/call ${EchoSub} "${Orange} Paragon of Spirit -- ${White} ${Me.AltAbility[Paragon of Spirit].Spell.Base[9]} HP Gain and ${Me.AltAbility[Paragon of Spirit].Spell.Base[10]} Mana Gain per tick for ${Me.AltAbility[Paragon of Spirit].Spell.Duration} ticks (${Math.Calc[${Me.AltAbility[Paragon of Spirit].Spell.Duration}*${Me.AltAbility[Paragon of Spirit].Spell.Base[9]}].Int} hp total - ${Math.Calc[${Me.AltAbility[Paragon of Spirit].Spell.Duration}*${Me.AltAbility[Paragon of Spirit].Spell.Base[10]}].Int} mana total)"
			/if (${Target.Type.NotEqual[npc]} && ${Target.ID}!=${Me.ID} && ${Target.ID}!=${Me.Pet.ID}) /squelch /tar clear
			/alt act ${Me.AltAbility[Paragon of Spirit].ID}
			/delay 5s !${Me.Casting.ID}
		}
		/for i 0 to 5
			/if (!${Select[${Group.Member[${i}].Class.ShortName},BRD,WAR,MNK,ROG,BER,SHM,NEC]} && ${Me.AltAbilityReady[Focused Paragon of Spirits]} && !${Me.Song[Paragon of Spirit].ID} && !${Me.Buff[Paragon of Spirit].ID} && ${Group.Member[${i}].PctMana}<=${TheirManaLessThan} && ${Group.Member[${i}].PctMana}>0 && !${SpawnCount[${Group.Member[${i}]} corpse]}) {
				/squelch /tar ${Group.Member[${i}]}
				/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
				/alt act ${Me.AltAbility[Focused Paragon of Spirits].ID}
				/call ${EchoSub} "${Orange} Focused Paragon of Spirits --> ${White} ${Target.CleanName}"
				/delay 2
				/squelch /tar clear
			}	
		/next i
	}
	
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/if (${Me.AltAbilityReady[Veturika's Perseverance]} && ${Me.PctMana}<=${MyManaLessThan} && !${SpawnCount[${Me.CleanName} pccorpse]}) {
			/alt act ${Me.AltAbility[Veturika's Perseverance].ID}
			/call ${EchoSub} "${Orange} Veturika's Perseverance --> ${White} Me"
			/delay 3
		}
		
		/for i 0 to 5
			/if (!${Select[${Group.Member[${i}].Class.ShortName},BRD,WAR,MNK,ROG,BER,SHM]} && ${Me.AltAbilityReady[Quiet Miracle]} && (${Group.Member[${i}].PctMana}<=${TheirManaLessThan} && ${i}>0||${i}==0 && ${Me.PctMana}<=${MyManaLessThan} && !${Me.Buff[Shroud of the Miracle].ID}) && ${Group.Member[${i}].PctMana}>0 && !${SpawnCount[${Group.Member[${i}]} corpse]}) {
				/squelch /tar ${Group.Member[${i}]}
				/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
				/alt act ${Me.AltAbility[Quiet Miracle].ID}
				/call ${EchoSub} "${Orange} Quiet Miracle --> ${White} ${Target.CleanName}"
				/delay 2
				/squelch /tar clear
			}	
		/next i

	}
	
	/if (${Me.PctMana}<${MedAt} && !${MedTimer} && !${Me.Mount.ID} && ${Me.State.Equal[STAND]} && (${Me.CombatState.Equal[ACTIVE]} && !${sitTimer}||${Me.CombatState.Equal[DEBUFFED]} && !${Debuff.Count} && !${sitTimer}|| !${sitTimer} && ${Me.CombatState.NotEqual[COMBAT]} && ${MedEvenIfNotInOOCRegen})) {
		/if (${Plugin[MQ2Twist].Name.Length}) {
			/if (${Twist.Twisting}) /twist stop
		}
  		
		/varset sitTimer ${Ini[MyIni,General,SitTimer]}
		/varset MedTimer ${MedTimer.OriginalValue}
		/delay 5
    }

    :MedToFull
	/if (${Me.CombatState.Equal[RESTING]} && ${MedToFull} && ${Me.PctMana}<95) /goto :MedToFull
/return

Sub ManaLoad
	/varset CurrentSub Mana
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${ManaLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local
	/declare ManaConditions string outer ${Ini[MyIni,Mana,ManaConditions]}
	/if (${ManaConditions.Equal[NULL]}) /mmoini "MyIni" "Mana" "ManaConditions"
	/declare MedTimer timer outer ${Ini[MyIni,Mana,MedTimer,10s]}
	/declare MedAt int outer ${Ini[MyIni,Mana,MedAt,0]}
	/declare MedToFull bool outer ${Ini[MyIni,Mana,MedToFull,FALSE]}
	/declare MedEvenIfNotInOOCRegen bool outer ${Ini[MyIni,Mana,MedEvenIfNotInOOCRegen,FALSE]}
	/declare MyManaLessThan int outer
	/declare MyHPMoreThan int outer
	/declare DontUnlessMyManaLessThan int outer
	/declare TheirManaLessThan int outer
	/if (${NeedLoad} && !${MedAt}) {
		/echo Loading ini for Mana section.
		/mmoini "MyIni" "Mana" "MedAt" "75"
		/mmoini "MyIni" "Mana" "MedToFull" "FALSE"
		/mmoini "MyIni" "Mana" "MedEvenIfNotInOOCRegen" "FALSE"
		/mmoini "MyIni" "Mana" "MedTimer" "10s"
	}
	
	/if (!${Defined[${CurrentSub}Boost${Me.Class.ShortName}]}) {
		/declare numEffects int local 0
		/declare effect int local

		/for i 1 to ${MyGemTotal}
			/varcalc numEffects ${Spell[${Me.Gem[${i}]}].NumEffects}

			|Attrib 15 = Mana
			/for effect 1 to ${numEffects}
			  |/echo Checking effect ${effect}
				/if (${Me.Gem[${i}].Attrib[${effect}]}==15 && ((${Me.Class.ShortName.Equal[SHM]} && ${Me.Gem[${i}].Base[${effect}]}>0) || ${Me.Gem[${i}].Base[${effect}]}>150)) {
					/if (!${Defined[${CurrentSub}Boost${Me.Class.ShortName}]}) /declare ${CurrentSub}Boost${Me.Class.ShortName} string outer ${Me.Gem[${i}]}
					/if (!${Defined[${CurrentSub}BoostGem${Me.Class.ShortName}]}) /declare ${CurrentSub}BoostGem${Me.Class.ShortName} string outer gem${Me.Gem[${${CurrentSub}Boost${Me.Class.ShortName}}]}
				}
			/next effect
		/next i
		/if (!${Defined[${CurrentSub}Boost${Me.Class.ShortName}]}) /declare ${CurrentSub}Boost${Me.Class.ShortName} bool outer FALSE
		/if (!${Defined[${CurrentSub}BoostGem${Me.Class.ShortName}]}) /declare ${CurrentSub}BoostGem${Me.Class.ShortName} bool outer FALSE
	}

	/if (${Me.Class.ShortName.Equal[SHM]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,Canni_IfManaBelow,123456]}
		/varset DontUnlessMyManaLessThan ${Ini[MyIni,Mana,DontCanni_UnlessManaBelow,123456]}
		/varset MyHPMoreThan ${Ini[MyIni,Mana,Canni_IfMyHPAbove,123456]}

		/if (${NeedLoad}) {
			/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "Canni_IfManaBelow" "70"
			/if (${DontUnlessMyManaLessThan}==123456) /mmoini "MyIni" "Mana" "DontCanni_UnlessManaBelow" "99"
			/if (${MyHPMoreThan}==123456) /mmoini "MyIni" "Mana" "Canni_IfMyHPAbove" "70"
		}
	}
	
	/if (${Me.Class.ShortName.Equal[NEC]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,DeathBloom_IfManaBelow,123456]}
		/varset DontUnlessMyManaLessThan ${Ini[MyIni,Mana,DontDeathBloom_UnlessManaBelow,123456]}
		/varset MyHPMoreThan ${Ini[MyIni,Mana,DeathBloom_IfMyHPAbove,123456]}
		|/varset TheirManaLessThan ${Ini[MyIni,Mana,DeathBlossom_IfManaBelow,123456]}
		|/if (${TheirManaLessThan}==123456) /mmoini "MyIni" "Mana" "DeathBlossom_IfManaBelow" "25"
		/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "DeathBloom_IfManaBelow" "70"
		/if (${MyHPMoreThan}==123456) /mmoini "MyIni" "Mana" "DeathBloom_IfMyHPAbove" "70"
		/if (${DontUnlessMyManaLessThan}==123456) /mmoini "MyIni" "Mana" "DontDeathBloom_UnlessManaBelow" "99"
	}

	/if (${Select[${Me.Class.ShortName},MAG,WIZ]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,Harvest_IfManaBelow,123456]}
		/varset DontUnlessMyManaLessThan ${Ini[MyIni,Mana,DontHarvest_UnlessIfManaBelow,123456]}
		/if (${NeedLoad}) {
			/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "Harvest_IfManaBelow" "70"
			/if (${DontUnlessMyManaLessThan}==123456) /mmoini "MyIni" "Mana" "DontHarvest_UnlessManaBelow" "70"
		}
	}
	
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,QuietMiracle_IfManaBelow,123456]}
		/varset TheirManaLessThan ${Ini[MyIni,Mana,QuietMiracle_Others_IfManaBelow,123456]}
		/if (${NeedLoad}) {
			/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "QuietMiracle_IfManaBelow" "5"
			/if (${TheirManaLessThan}==123456) /mmoini "MyIni" "Mana" "QuietMiracle_Others_IfManaBelow" "5"
		}
	}

	/if (${Me.Class.ShortName.Equal[BST]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,Paragon_IfManaBelow,123456]}
		/varset TheirManaLessThan ${Ini[MyIni,Mana,FocusedParagon_Others_IfManaBelow,123456]}
		/if (${NeedLoad}) {
			/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "Paragon_IfManaBelow" "65"
			/if (${TheirManaLessThan}==123456) /mmoini "MyIni" "Mana" "FocusedParagon_Others_IfManaBelow" "5"
		}
	}
	
	/if (${Select[${Me.Class.ShortName},SHD]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,ThoughtLeech_IfManaBelow,123456]}
		/if (${NeedLoad}) {
			/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "ThoughtLeech_IfManaBelow" "10"
		}
	}
	
	/if (${Me.Class.ShortName.Equal[ENC]}) {
		/varset MyManaLessThan ${Ini[MyIni,Mana,SecondSpire_IfManaBelow,123456]}
		/varset TheirManaLessThan ${Ini[MyIni,Mana,SecondSpire_Others_IfManaBelow,123456]}
		/if (${NeedLoad}) {
			/if (${MyManaLessThan}==123456) /mmoini "MyIni" "Mana" "SecondSpire_IfManaBelow" "65"
			/if (${TheirManaLessThan}==123456) /mmoini "MyIni" "Mana" "SecondSpire_Others_IfManaBelow" "5"
		}
	}
/return

|merc start
Sub MercLoad
	/if (!${Defined[MercLoaded]}) /declare MercLoaded bool outer FALSE
	/if (${MercLoaded}) /return
	/varset MercLoaded TRUE
	/declare MercAssistID int outer
	/declare mercstancecurrent string outer
	/declare merclist string outer WAR|WIZ|CLR|ROG|
	/declare MercName string outer ${Ini[MyIni,Merc,MercName]}
	/declare MercAssistAt int outer ${Ini[MyIni,Merc,MercAssistAt]}
	/if (!${MercAssistAt}) /mmoini "MyIni" "Merc" "MercAssistAt" "100"
	/declare i int local
	/for i 1 to 4
		/declare ${merclist.Arg[${i},|]}_MercStanceNormal string outer ${Ini[MyIni,Merc,${merclist.Arg[${i},|]}_MercStanceNormal]}
		/if (${${merclist.Arg[${i},|]}_MercStanceNormal}==NULL) /mmoini "MyIni" "Merc" "${merclist.Arg[${i},|]}_MercStanceNormal"
		/declare ${merclist.Arg[${i},|]}_MercStanceNamed string outer ${Ini[MyIni,Merc,${merclist.Arg[${i},|]}_MercStanceNamed]}
		/if (${${merclist.Arg[${i},|]}_MercStanceNamed}==NULL) /mmoini "MyIni" "Merc" "${merclist.Arg[${i},|]}_MercStanceNamed"
		/declare ${merclist.Arg[${i},|]}_MercStanceOOC string outer ${Ini[MyIni,Merc,${merclist.Arg[${i},|]}_MercStanceOOC]}
		/if (${${merclist.Arg[${i},|]}_MercStanceOOC}==NULL) /mmoini "MyIni" "Merc" "${merclist.Arg[${i},|]}_MercStanceOOC"
	/next i
	/deletevar merclist
/return

Sub Merc
	/if (${Me.Hovering}) /return
	/if (!${Defined[MercLoaded]}) /call MercLoad
	/if (${Group.Member[1].Owner.ID}==${Me.ID}) /varset MercName ${Group.Member[1].Name}
	/if (${Mercenary.State.Equal[ACTIVE]} && (${Target.Type.Equal[npc]}||${Spawn[${Target.Master.ID}].Type.Equal[npc]}) && ${Target.PctHPs}<=${MercAssistAt} && ${MercAssistID}!=${Target.ID}) {
		/mercassist
		/varset MercAssistID ${Target.ID}
	}
	/if (${Defined[MercStanceOOC]}) {
		/if (${MercStanceOOC.NotEqual[Null]} && ${Mercenary.State.Equal[ACTIVE]} && ${Select[${Me.CombatState},RESTING,ACTIVE]} && !${AddCount} && ${Mercenary.Stance.NotEqual[${${Me.Mercenary.Class.ShortName}_MercStanceOOC}]} && ${${Me.Mercenary.Class.ShortName}_MercStanceOOC.Length}) {
			/stance ${${Me.Mercenary.Class.ShortName}_MercStanceOOC}
			/return
		}
	}
	/if (${Bool[${Me.Mercenary.Class.ShortName}]}) {
		/if (${Mercenary.State.Equal[ACTIVE]} && (${Target.Named}||${Target.Name.Find[#]}) && ${AddCount} && ${${Me.Mercenary.Class.ShortName}_MercStanceNamed.NotEqual[NULL]} && ${Mercenary.Stance.NotEqual[${${Me.Mercenary.Class.ShortName}_MercStanceNamed}]}) {
			/stance ${MercStanceNamed}
			/return
		}

		/if (${Mercenary.State.Equal[ACTIVE]} && !${Target.Named} && !${Target.Name.Find[#]} && ${AddCount} && ${${Me.Mercenary.Class.ShortName}_MercStanceNormal.NotEqual[NULL]} && ${Mercenary.Stance.NotEqual[${${Me.Mercenary.Class.ShortName}_MercStanceNormal}]}) {
			/stance ${MercStanceNormal}
			/return
		}
	}
	/if (${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Text.Equal[Revive]} && !${Group.Member[1].ID} && ${Group.Member[1].Name.Equal[${MercName}]}) {
		/nomodkey /notify MMGW_ManageWnd MMGW_SuspendButton leftmouseup
	}
/return
|merc end

|mez start
Sub MezLoad
	/call Debug 3 "In Sub MezLoad"
	/varset CurrentSub Mez
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
  	/if (!${Defined[mezcnt]})  /declare mezcnt int outer
  	/if (!${Defined[aemezcnt]}) /declare aemezcnt int outer
  	/if (!${Defined[PBAEMezcnt]}) /declare PBAEMezcnt int outer
  	/if (!${Defined[notmezcnt]}) /declare notmezcnt int outer
	/if (!${Defined[BeamTimer]}) /declare BeamTimer timer outer 5s
	/declare MezList string outer |
	/declare MezMaxNPCLevel int outer
	/declare AEMezMaxNPCLevel int outer
	/declare PBAEMezMaxNPCLevel int outer
	/declare FinalMezMaxNPCLevel int outer
	/declare MezBuffer timer outer
	/if (!${Defined[BeamUsed]}) /declare BeamUsed int outer 0
	/declare IgnoreImmuneLists bool outer ${Ini[MyIni,Mez,IgnoreImmuneLists,FALSE]}
	/if (!${IgnoreImmuneLists}) /mmoini "MyIni" "Mez" "IgnoreImmuneLists" "FALSE"
	/declare DontMezConColor string outer ${Ini[MyIni,Mez,DontMezConColor,|GREY|GREEN|]}
	/declare b int local
	/declare x int local
	/declare i int local 0
	/declare numEffects int local
	/if (${Select[${Me.Class.ShortName},NEC]}) /varset i 2
	/if (${Select[${Me.Class.ShortName},BRD]}) /varset i 4
	/if (${Select[${Me.Class.ShortName},ENC]}) /varset i 6
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/mmoini "MyIni" "Mez" "DontMezConColor" "|GREY|GREEN|"
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|30|" "|${i}|TRUE|----|----|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "|3|4|6|30|"
	/declare ${CurrentSub}MaxNPCLevel${x} int outer 0
	/if (${${CurrentSub}Total}) {
		/for x 1 to ${${CurrentSub}Total}
			/if (!${Defined[${CurrentSub}SpellName${x}]}) /declare ${CurrentSub}SpellName${x} ${Ini[MyIni,${CurrentSub},${CurrentSub}SpellName${i},12345]}
			/varcalc numEffects ${Spell[${${CurrentSub}SpellName${x}}].NumEffects}
			/for b 1 to ${numEffects}
				/if (${Spell[${${CurrentSub}SpellName${x}}].Subcategory.Equal[Enthrall]}) {
					/if (${Spell[${${CurrentSub}SpellName${x}}].Max[${b}]}>${MezMaxNPCLevel}) /varset MezMaxNPCLevel ${Spell[${${CurrentSub}SpellName${x}}].Max[${b}]}
				}
			/next b
		/next x
	}

	/varset CurrentSub AEMez
	/if (${NeedLoad} && !${Defined[${CurrentSub}Total]} && ${Select[${Me.Class.ShortName},ENC]}) {
		/mmoini "MyIni" "Mez" "DontMezConColor" "|GREY|GREEN|"
		/call SpellLoad "${CurrentSub}" 1 "|1|3|4|6|30|" "|1|TRUE|----|----|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "3|4|6|30|"
	/declare ${CurrentSub}MaxNPCLevel${x} int outer 0
	
	/if (${${CurrentSub}Total}) {
		/for x 1 to ${${CurrentSub}Total}
			/varcalc numEffects ${Spell[${${CurrentSub}SpellName${x}}].NumEffects}
			/for b 1 to ${numEffects}
				/if (${Spell[${${CurrentSub}SpellName${x}}].Subcategory.Equal[Enthrall]}) {
					/if (${Spell[${${CurrentSub}SpellName${x}}].Max[${b}]}>${${CurrentSub}MaxNPCLevel}) /varset ${CurrentSub}MaxNPCLevel ${Spell[${${CurrentSub}SpellName${x}}].Max[${b}]}
				}
			/next b
		/next x
	}
	/varset CurrentSub PBAEMez
	/if (${NeedLoad} && !${Defined[${CurrentSub}Total]} && ${Select[${Me.Class.ShortName},ENC,BRD]}) {
		/mmoini "MyIni" "Mez" "DontMezConColor" "|GREY|GREEN|"
		/call SpellLoad "${CurrentSub}" 1 "|1|3|4|6|30|" "|1|TRUE|----|----|TRUE|"
	}
	/call SpellLoad2 "${CurrentSub}" "3|4|6|30|"
	/declare ${CurrentSub}MaxNPCLevel${x} int outer 0
	/if (${${CurrentSub}Total}) {
		/for x 1 to ${${CurrentSub}Total}
			/varcalc numEffects ${Spell[${${CurrentSub}SpellName${x}}].NumEffects}
			/for b 1 to ${numEffects}
				/if (${Spell[${${CurrentSub}SpellName${x}}].Subcategory.Equal[Enthrall]}) {
					/if (${Spell[${${CurrentSub}SpellName${x}}].Max[${b}]}>${PBAEMezMaxNPCLevel}) /varset PBAEMezMaxNPCLevel ${Spell[${${CurrentSub}SpellName${x}}].Max[${b}]}				
				}
			/next b
		/next x
	}
	/varset FinalMezMaxNPCLevel ${MezMaxNPCLevel}
	/if (${AEMezMaxNPCLevel}>${FinalMezMaxNPCLevel}) /varset FinalMezMaxNPCLevel ${AEMezMaxNPCLevel}
	/if (${PBAEMezMaxNPCLevel}>${FinalMezMaxNPCLevel}) /varset FinalMezMaxNPCLevel ${PBAEMezMaxNPCLevel}

	/call Debug 2 "MezMaxNPCLevel = ${MezMaxNPCLevel} | AEMezMaxNPCLevel: ${AEMezMaxNPCLevel} | PBAEMezMaxNPCLevel: ${PBAEMezMaxNPCLevel}"
	/call Debug 3 "Leaving Sub MezLoad"
/return

Sub MezClear(int MezMobID)
	/if (${Defined[MezTimer${MezMobID}]}) /deletevar ${MezTimer${MezMobID}}
/return

Sub Mez
	/call Debug 3 "In Sub Mez"
	/if (${Me.Hovering}) {
		/call Debug 3 "Leaving Sub Mez - In Hover State"
		/return
	}
	/varset CurrentSub Mez
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
  	/if ((!${MezUse1} && !${AEMezUse1} && !${PBAEMezUse1}) || ${NeedLoad} || (${Me.Invis} && !${AutoBreakInvis})) {
	  	/call Debug 3 "Leaving Sub Mez - Mez Options not configured properly or can't break invis."
		/return
	}
  	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if ((!${Me.Gem[${PBAEMezSpellName1}]}||${Me.GemTimer[${PBAEMezSpellName1}]})) {
			/call Debug 3 "Leaving Sub Mez - Bard with no PBAEMez spell, unsupported combination"
			/return
		}
	}

	/declare m int local
  	/declare i int local
  	/declare x int local

  	/varset TarID ${Me.XTarget[1].ID}
	/if (!${Defined[MezTimer${TarID}]}) /Declare MezTimer${TarID} timer outer 0
  	/if (${TarID} && ${MezTimer${TarID}}) /varset MezTimer${TarID} 0
  	/varset mezcnt 0
  	/varset aemezcnt 0
  	/varset PBAEMezcnt 0
  	/varset notmezcnt 0

  	/for m 1 to ${MezList.Count[|]}
		/if (${MezList.Length}>1 && ${MezList.Arg[${m},|].NotEqual[|]} && (!${Spawn[id ${MezList.Arg[${m},|]}].ID}||!${AddList.Find[${MezList.Arg[${m},|]}]})) /varset MezList ${MezList.Replace[${MezList.Arg[${m},|]},]}
		/if (${MezList.Find[||]}) /varset MezList ${MezList.Replace[||,|]}
  	/next m
	
	/call Debug 3 "MezList: ${MezList}"
	/call Debug 3 "AddList: ${AddList}"

  	/for m 1 to ${AddList.Count[|]}
		/if (!${MezList.Find[${AddList.Arg[${m},|]}]} && (${IgnoreImmuneLists}||!${MezImmuneList.Find[${Spawn[id ${AddList.Arg[${m},|]}].CleanName}]}) && ${AddList.Arg[${m},|]}!=${TarID} && !${DontMezConColor.Find[${Spawn[id ${AddList.Arg[${m},|]}].ConColor}]} && !${Spawn[id ${AddList.Arg[${m},|]}].CleanName.Find[_pet]} && ${Spawn[id ${AddList.Arg[${m},|]}].ID} && ${Spawn[id ${AddList.Arg[${m},|]}].Level}<=${FinalMezMaxNPCLevel}) {
			/if (${Defined[MezTimer${AddList.Arg[${m},|]}]}) /varset MezTimer${AddList.Arg[${m},|]} 0
			/varset MezList ${MezList}${AddList.Arg[${m},|]}|
		}
  	/next m
  
	/call Debug 3 "MezList after AddList Loop: ${MezList}"

  	/for m 1 to ${MezList.Count[|]}
		/if (${Spawn[id ${MezList.Arg[${m},|]}].Distance}<100 && ${Spawn[id ${MezList.Arg[${m},|]}].Level}<=${MezMaxNPCLevel} && !${Defined[MezTimer${MezList.Arg[${m},|]}]}) /varcalc mezcnt ${mezcnt}+1
		/if (${Spawn[id ${MezList.Arg[${m},|]}].Distance}<100 && ${Spawn[id ${MezList.Arg[${m},|]}].Level}<=${AEMezMaxNPCLevel} && !${Defined[MezTimer${MezList.Arg[${m},|]}]}) /varcalc aemezcnt ${aemezcnt}+1
		/if (${Spawn[id ${MezList.Arg[${m},|]}].Distance}<35 && ${Spawn[id ${MezList.Arg[${m},|]}].Level}<=${PBAEMezMaxNPCLevel} && !${Defined[MezTimer${MezList.Arg[${m},|]}]}) /varcalc PBAEMezcnt ${PBAEMezcnt}+1
  	/next m

	/call Debug 3 "mezcnt: ${mezcnt} | aemezcnt: ${aemezcnt} | PBAEMezcnt: ${PBAEMezcnt}"

	| Note: PBAEMezzing is currently only supported on bards.  Loop will run but take no action when not a bard.
	/varset CurrentSub PBAEMez
	/for i 1 to ${PBAEMezTotal}
 		/if ((${PBAEMezcnt}>2||${PBAEMezcnt}>0 && ${AddCount}>1 && ${SpawnCount[npc radius 35]}>1 && ${Me.Class.ShortName.Equal[BRD]}) && (${Me.SpellReady[${PBAEMezSpellName${i}}]}||${Me.AltAbilityReady[${PBAEMezSpellName${i}}]}||${Me.Class.ShortName.Equal[BRD]} && ${Me.Gem[${PBAEMezSpellName${i}}]} && !${Me.GemTimer[${PBAEMezSpellName${i}}]}) && ${Me.CurrentMana}>${Spell[${PBAEMezSpellName${i}}].Mana} && ${PBAEMezUse${i}}) {
			/if (!${Me.Class.ShortName.Equal[BRD]}) /call MezAdd "${PBAEMezSpellName${i}}" "${PBAEMezSpellGem${i}}" ${Target.ID} 
			/if (${Me.Class.ShortName.Equal[BRD]}) {
				/if (${Plugin[MQ2Twist].Name.Length}) {
					/if (${Twist.Twisting}) {
						/varset twisting TRUE
						/squelch /twist stop
					}
				}
			
				/delay !${Me.Casting.ID}
				/squelch /twist once ${Me.Gem[${PBAEMezSpellName${i}}]}
				/call ${EchoSub} "${DarkYellow} ${PBAEMezSpellName${i}}"
				/varset BeamUsed 1
				/varset BeamTimer ${BeamTimer.OriginalValue}
				/doevents
				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${PBAEMezSpellName${i}}
				/delay 38
				/twist
				/return
			}	
		}
	/next i
	
	/if (${Plugin[MQ2Twist].Name.Length}) {
		/if (${twisting} && !${Twist.Twisting}) {
			/squelch /twist start
			/varset twisting FALSE
		}
	}

	/varset CurrentSub AEMez
   	/for m 1 to ${MezList.Count[|]}
		/for i 1 to ${AEMezTotal}
  			/if (${aemezcnt}>2 && (${Me.SpellReady[${AEMezSpellName${i}}]}||${Me.AltAbilityReady[${AEMezSpellName${i}}]}) && ${Me.CurrentMana}>${Spell[${AEMezSpellName${i}}].Mana} && !${Defined[MezTimer${MezList.Arg[${m},|]}]} && ${MezList.Arg[${m},|]}>0 && ${Spawn[id ${MezList.Arg[${m},|]}].ID} && ${AEMezUse${i}}) {
			  	/call Debug 3 "Trying to AE Mez using ${AEMezSpellName${i}} on ${MezList.Arg[${m},|]}"
				/squelch /tar id ${MezList.Arg[${m},|]}
				/call MezAdd "${AEMezSpellName${i}}" "${AEMezSpellGem${i}}" ${Target.ID}
			}
		/next i
   	/next m

	:refreshmez
	|** Broken Code **|
	|/if (${Spawn[${MezMobID}].Type.Equal[corpse]}) {
	|	/call Debug 3 "Leaving Sub Mez - MezMobID (${MezMobID}) is a corpse - not even sure you should see this because it looks like dead code."
	|	/return
	|}
	/varset CurrentSub Mez
	/doevents
	/for i 1 to ${MezTotal}
 		/if (${mezcnt} && (${Me.SpellReady[${MezSpellName${i}}]} && ${Me.CurrentMana}>${Spell[${MezSpellName${i}}].Mana}||${Me.AltAbilityReady[${MezSpellName${i}}]}) && ${MezUse${i}}) {
			/for m 1 to ${MezList.Count[|]}
				/if (${MezTimer${MezList.Arg[${m},|]}}>6) /continue
				/if ((!${Defined[MezTimer${MezList.Arg[${m},|]}]}||${Defined[MezTimer${MezList.Arg[${m},|]}]} && !${MezTimer${MezList.Arg[${m},|]}}) && ${MezList.Arg[${m},|]}!=${TarID} && ${MezList.Arg[${m},|]}>0 && ${Spawn[id ${MezList.Arg[${m},|]}].ID} && ${Spawn[id ${MezList.Arg[${m},|]}].Distance}<=${AttackRange}) {
					/squelch /tar id ${MezList.Arg[${m},|]}
					/delay 1s ${Target.ID}==${MezList.Arg[${m},|]}
					/call MezAdd "${MezSpellName${i}}" "${MezSpellGem${i}}" ${MezList.Arg[${m},|]}
					/if (${mezcnt}) /goto :refreshmez
				}
			/next m
		}
	/next i

 	/if (!${mezcnt} && ${TarID} && ${Spawn[${TarID}].Type.Equal[npc]}) /squelch /tar id ${TarID}
	/call Debug 3 "Leaving Sub Mez"
/return

Sub MezAdd(string MezSpell,string GemName,int MezID)
	/if (!${MezID}||!${Target.LineOfSight}||!${Target.ID}) /return
	/varset BeamUsed 0
	/squelch /tar id ${MezID}
	/delay 1s ${Target.ID}
	/if (${MezSpell.Equal[Beam of Slumber]}) /face
	/call ${EchoSub} "${Purple} ${MezSpell} --> ${White} ${Target}"
    /if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${MezSpell} --> ${Target.CleanName}
    /if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}  && ${AnnounceEvents.Find[TRY]}) /docommand /${AnnounceChannel} ${MezSpell} --> ${Target.CleanName}
	/if (${Spell[${MezSpell}].AERange.Int}) {
		/varset BeamTimer ${BeamTimer.OriginalValue}
		/varset BeamUsed 1
	}
    /call Cast "${MezSpell}" "${GemName}" NULL NULL NULL
	/varset MezBuffer 2s
	/if (${Spell[${MezSpell}].AERange.Int}) {
		/varset BeamTimer ${BeamTimer.OriginalValue}
		/varset BeamUsed 1
	}
	/delay 2
	/delay 3s !${Me.Casting.ID}
	/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
		/if (!${Defined[MezTimer${MezID}]}) /declare MezTimer${MezID} timer outer ${Spell[${MezSpell}].Duration}s
		/varset MezTimer${MezID} ${Spell[${MezSpell}].Duration.TotalSeconds}s
		/if (${MezSpell.Equal[Nightmare Stasis]}) /varset MezTimer${MezID} 3m
		/varcalc mezcnt ${mezcnt}-1
		/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${MezSpell} --> ${Target.CleanName} MEZZED						
	}
	/if (!${Spell[${MezSpell}].AERange.Int} && (${Macro.Return.Equal[CAST_IMMUNE]}||${Macro.Return.Equal[CAST_NOTHOLD]}))  {
		/if (!${Defined[MezTimer${MezID}]}) /declare  MezTimer${MezID} timer outer 9999999
		/varset MezTimer${MezID} 9999999
		/varcalc mezcnt ${mezcnt}-1
	}
	/if (${Macro.Return.Equal[CAST_RESIST]})  {
		/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${MezSpell} --> ${Target.CleanName} RESIST						
	}
	/doevents
/return
|mez end

|nuke start
Sub GoMLoad
	/varset CurrentSub GoM
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${GoMLoaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 1
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" 1 "|1|2|3|4|5|6|" "|0|0|TRUE|----|----|----|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|5|6|"
/return

Sub NukeLoad
	/if (!${Defined[GoMLoaded]}) /call GoMLoad
	/varset CurrentSub Nuke
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 1
	/varset CurrentSub Nuke
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/varset i 3
		/if (${Select[${Me.Class.ShortName},SHD,DRU,NEC,BST,ENC]}) /varset i 5
		/if (${Select[${Me.Class.ShortName},CLR,PAL,RNG,MAG]}) /varset i 10
		/if (${Select[${Me.Class.ShortName},WIZ]}) /varset i 20
		/call SpellLoad "${CurrentSub}" ${i} "|1|2|3|4|6|7|8|9|30|" "|${i}|${i}|TRUE|----|----|96|1|1s|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|7|8|9|30|"
/return

Sub Nuke
	/if (${Me.Hovering}) /return
	/varset CurrentSub Nuke
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (!${${CurrentSub}Total}||${NeedLoad}) /return
	/if (${ImNotReady}||${Target.Distance}>${AttackRange}) /return
	/if (!${${CurrentSub}Conditions}) /return
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/varset CurrentSub Nuke
 	/declare i int local
 	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}) /continue
 		/if (${ValidSpellType} && ${ValidEnemy}) {
			/if (!${Defined[GoMUse${i}]}) /declare GoMUse${i} bool outer FALSE
			/if (${GoMTotal}) {
				/if (${GoMUse${i}}) {
					/if (${GoMCheck}) {
						/call ${EchoSub} "${Gray} ${GoMSpellName${i}} --> ${White} ${Target}"
						/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${GoMSpellName${i}} --> ${Target.CleanName}
						/call Cast "${GoMSpellName${i}}" ${GoMSpellGem${i}} 0 CheckStuff NULL
						/delay 3s !${Me.Casting.ID}
						/if (${CastCounts}) {
							/varcalc Hate ${Hate}+1	
						}
					}
				}
			}
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset NukeConditions${i} ${Ini[MyIni,Nuke,NukeConditions${i},123456]}
			
			/if (!${Defined[${CurrentSub}IgnoreRecast${i}]}) /Declare ${CurrentSub}IgnoreRecast${i} bool outer FALSE
			/if (!${Defined[${CurrentSub}On${i}]}) /Declare ${CurrentSub}On${i} bool outer FALSE
			/if (!${Defined[${CurrentSub}MaxTries${i}]}) /Declare ${CurrentSub}MaxTries${i} int outer 0
			/if (!${Defined[${CurrentSub}Resisted${i}]}) /Declare ${CurrentSub}Resisted${i} bool outer FALSE
			/if (!${CastIsReady}) {
				/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
			}
    		/if (${ValidSpellType} && ${ValidSpell} && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady} && ${NukeConditions${i}}) {
				/if (${ResistCheck}) {
					/call ${EchoSub} "${Red} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/if (!${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
						/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
					} else {
						/cast ${Me.Gem[${${CurrentSub}SpellName${i}}]}
						/keypress f10
						/face
						/delay 5
						/click left center
						/keypress f10
					}
					/if (${CastCounts}) {
						/varcalc Hate ${Hate}+1
						/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
						/if (${ExitSubEarly}) /goto :exitnuke
					}
    			}
 			}
		}
	:skip
 	/next i
 	:exitnuke
/return
|nuke end

|pet start
Sub PetLoad
	/varset CurrentSub Pet
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${PetLoaded}) /return
	/varset PetLoaded TRUE
	/if (!${Defined[TarID]}) /declare TarID int outer
	/declare PetGHOLD bool outer ${Ini[MyIni,Pet,PetGHOLD,TRUE]}
	/if (${PetGHOLD}) /mmoini "MyIni" "Pet" "PetGHOLD" "TRUE"
	/if (${Me.Pet.ID} && ${Me.AltAbility[Pet Discipline]} && ${PetGHOLD}) /pet ghold on
	/declare UsePetFocusAA bool outer ${Ini[MyIni,Pet,UsePetFocusAA]}
	/declare UsePet bool outer ${Ini[MyIni,Pet,UsePet,FALSE]}
	/declare PetReagent string outer ${Ini[MyIni,Pet,PetReagent]}
	/if (!${Defined[PetGearDefaultAlias]}) /declare PetGearDefaultAlias string outer ${Ini[MyIni,Pet,PetGearDefaultAlias,NULL]}
	/if (${PetGearDefaultAlias.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetGearDefaultAlias"
	/declare ShrinkPet bool outer ${Ini[MyIni,Pet,ShrinkPet,FALSE]}
	/declare ShrinkPetIfHeightAbove float outer ${Ini[MyIni,Pet,ShrinkPetIfHeightAbove,1.5]}
	/declare ShrinkPetSpell string outer ${Ini[MyIni,Pet,ShrinkPetSpell]}
	/declare ShrinkPetSpellGem string outer ${Ini[MyIni,Pet,ShrinkPetSpellGem]}
	/declare PetAttacking bool outer FALSE
	/declare PetAttackAt int outer ${Ini[MyIni,Pet,PetAttackAt]}
	/declare PetSpellGem string outer ${Ini[MyIni,Pet,PetSpellGem]}
	/declare PetSpell string outer ${Ini[MyIni,Pet,PetSpell]}
	/declare PetFocusItem string outer ${Ini[MyIni,Pet,PetFocusItem,NULL]}
	/if (${Me.Book[${PetSpell} Rk. III]}) /varset PetSpell ${PetSpell} Rk. III
	/if (${Me.Book[${PetSpell} Rk. II]}) /varset PetSpell ${PetSpell} Rk. II
	/if (${UsePet} && !${Me.Book[${PetSpell}]}) {
		/varset ErrorFound
		/cechob \ar PetSpell=${PetSpell} is wrong, you do not have this spell
		/mqlog ${Me.Class} -  PetSpell=${PetSpell} is wrong, you do not have this spell
	}
	/declare DoPetHeals bool outer ${Ini[MyIni,Pet,DoPetHeals,FALSE]}
	/declare PetHealAt int outer ${Ini[MyIni,Pet,PetHealAt]}
	/declare PetHealSpell string outer ${Ini[MyIni,Pet,PetHealSpell]}
	/if (${Me.Book[${PetHealSpell} Rk. III]}) /varset PetHealSpell ${PetHealSpell} Rk. III
	/if (${Me.Book[${PetHealSpell} Rk. II]}) /varset PetHealSpell ${PetHealSpell} Rk. II
	/declare PetHealSpellGem string outer ${Ini[MyIni,Pet,PetHealSpellGem]}
	/declare UseAAPetHeal bool outer ${Ini[MyIni,Pet,UseAAPetHeal,FALSE]}
	/declare PetAAHealAt int outer ${Ini[MyIni,Pet,PetAAHealAt]}
	/declare PetGHold bool outer ${Ini[MyIni,Pet.PetGHold,TRUE]}
	/if (${PetGHold}) /mmoini "MyIni" "Pet" "PetGHold" "TRUE"
	/declare PetBuffRecheck timer outer ${Ini[MyIni,Pet,PetBuffRecheck,10s]}
	/declare DoPetBuffs bool outer ${Ini[MyIni,Pet,DoPetBuffs,FALSE]}
	/declare PetBuffTotal int outer ${Ini[MyIni,Pet,PetBuffTotal,0]}
	/declare pb int local
	
	/if (${PetBuffTotal}) {
		/for pb 1 to ${PetBuffTotal}
			/declare PetBuffName${pb} string outer ${Ini[MyIni,Pet,PetBuffName${pb}]}
  			/declare PetBuffSpell${pb} string outer ${Ini[MyIni,Pet,PetBuffSpell${pb}]}
			/if (${Me.Book[${PetBuffSpell${pb}} Rk. III]} && !${Me.AltAbility[${PetBuffSpell${pb}}]}) /varset PetBuffSpell${pb} ${PetBuffSpell${pb}} Rk. III
  			/if (${Me.Book[${PetBuffSpell${pb}} Rk. II]} && !${Me.AltAbility[${PetBuffSpell${pb}}]}) /varset PetBuffSpell${pb} ${PetBuffSpell${pb}} Rk. II
  			/declare PetBuffGem${pb} string outer ${Ini[MyIni,Pet,PetBuffGem${pb}]}
  			/declare PetBuffRecast${pb} timer outer ${Ini[MyIni,Pet,PetBuffRecast${pb}]}
			/if (!${Spell[${PetBuffName${pb}}].ID}) {
				/if (!${ErrorFound}) {
					/cechob \ar Error(s) found in MyIni
					/varset ErrorFound TRUE
				}
				/cechob \ar [Pet] PetBuffName${pb}=${PetBuffName${pb}} -- Not a valid spell name
				/mqlog ${Me.Class} -  [Pet] PetBuffName${pb}=${PetBuffName${pb}} -- Not a valid spell name
			}
			/if (!${Me.Book[${PetBuffSpell${pb}}]} && !${Me.AltAbility[${PetBuffSpell${pb}}]} && !${FindItem[${PetBuffSpell${pb}}].ItemSlot}||${PetBuffSpell${pb}.Length}<3) {
				/if (!${ErrorFound}) {
					/echo Error(s) found in MyIni
					/varset ErrorFound TRUE
				}
				/echo [Pet] PetBuffSpell${pb}=${PetBuffSpell${pb}} -- You dont have this spell/AA/Item
				/mqlog ${Me.Class} -  [Pet] PetBuffSpell${pb}=${PetBuffSpell${pb}} -- You dont have this spell/AA/Item
			}
			/if (${PetBuffGem${pb}.Find[gem]} && !${Me.Book[${PetBuffSpell${pb}}]}||${PetBuffGem${pb}.Find[alt]} && !${Me.AltAbility[${PetBuffSpell${pb}}]}||${PetBuffGem${pb}.Find[disc]} && !${Me.CombatAbility[${PetBuffSpell${pb}}]} && !${Me.CombatAbility[${PetBuffGem${pb}}]}||${PetBuffGem${pb}.Find[item]} && !${FindItem[${PetBuffSpell${pb}}].ItemSlot}||${PetBuffGem${pb}.Length}<3) {
				/if (!${ErrorFound}) {
					/echo Error(s) found in MyIni
					/varset ErrorFound TRUE
				}
				/echo [Pet] PetBuffGem${pb}=${PetBuffGem${pb}} -- This gem is wrong format for PetBuffGem${pb}=${PetBuffGem${pb}}
				/mqlog ${Me.Class} -  [Pet] PetBuffGem${pb}=${PetBuffGem${pb}} -- This gem is wrong format for PetBuffGem${pb}=${PetBuffGem${pb}}
			}
		/next pb
	}

	/if (${NeedLoad} && !${PetAAHealAt}) {
		/echo Loading Ini for Pet Section
		/declare a int local

		/mmoini "MyIni" "Pet" "UsePet" "FALSE"
		/mmoini "MyIni" "Pet" "PetSpell"
		/mmoini "MyIni" "Pet" "PetSpellGem" "gem1"
		/if (${Select[${Me.Class.ShortName},NEC,SHD]}) {
			/for a ${Me.FirstBook} to ${Me.LastBook}
				/if (${Spell[${Me.Book[${a}]}].Level}>=${Math.Calc[${Me.Level}-4]} && ${Spell[${Me.Book[${a}]}].Slot[1].Find[Summon Skeleton pet:]}) {
					/mmoini "MyIni" "Pet" "PetSpell" "${Me.Book[${a}]}"
					/break
				}
			/next a
		}
		/if (${Select[${Me.Class.ShortName},MAG,ENC,SHM]}) {
			/for a ${Me.FirstBook} to ${Me.LastBook}
				/if (${Spell[${Me.Book[${a}]}].Level}>=${Math.Calc[${Me.Level}-4]} && ${Spell[${Me.Book[${a}]}].Slot[1].Find[Summon pet:]}) {
					/mmoini "MyIni" "Pet" "PetSpell" "${Me.Book[${a}]}"
					/break
				}
			/next a
		}
		/if (${Select[${Me.Class.ShortName},BST]}) {
			/for a ${Me.FirstBook} to ${Me.LastBook}
				/if (${Spell[${Me.Book[${a}]}].Level}>=${Math.Calc[${Me.Level}-4]} && ${Spell[${Me.Book[${a}]}].Slot[1].Find[Summon warder:]}) {
					/mmoini "MyIni" "Pet" "PetSpell" "${Me.Book[${a}]}"
					/break
				}
			/next a
		}

		:skip

		/mmoini "MyIni" "Pet" "PetFoucusItem"
		/mmoini "MyIni" "Pet" "UsePetFocusAA" "TRUE"
		/mmoini "MyIni" "Pet" "PetAttackAt" "97"
		/mmoini "MyIni" "Pet" "ShrinkPet" "FALSE"
		/mmoini "MyIni" "Pet" "ShrinkPetIfHeightAbove" "1.5"
		/mmoini "MyIni" "Pet" "ShrinkPetSpell"
		/mmoini "MyIni" "Pet" "ShrinkPetSpellGem"
		/if (${FindItem[Curious Companion Compactor].ItemSlot}) {
			/mmoini "MyIni" "Pet" "ShrinkPetSpell" "Curious Companion Compactor"
			/mmoini "MyIni" "Pet" "ShrinkPetSpellGem" "item"
			/mmoini "MyIni" "Pet" "ShrinkPet" "TRUE"
		}
		/if (${InvSlot[leftear].Item.Spell.ID}==3583) {
			/mmoini "MyIni" "Pet" "ShrinkPetSpell" "${InvSlot[leftear].Item}"
			/mmoini "MyIni" "Pet" "ShrinkPetSpellGem" "item"
			/mmoini "MyIni" "Pet" "ShrinkPet" "TRUE"
		}
		/if (${InvSlot[rightear].Item.Spell.ID}==3583) {
			/mmoini "MyIni" "Pet" "ShrinkPetSpell" "${InvSlot[rightear].Item}"
			/mmoini "MyIni" "Pet" "ShrinkPetSpellGem" "item"
			/mmoini "MyIni" "Pet" "ShrinkPet" "TRUE"
		}
		/if (${Me.AltAbility[Diminutive Companion]}) {
			/mmoini "MyIni" "Pet" "ShrinkPetSpell" "Diminutive Companion"
			/mmoini "MyIni" "Pet" "ShrinkPetSpellGem" "alt"
			/mmoini "MyIni" "Pet" "ShrinkPet" "TRUE"
		}
		/mmoini "MyIni" "Pet" "DoPetHeals" "FALSE"
		/mmoini "MyIni" "Pet" "PetHealAt" "50"
		/mmoini "MyIni" "Pet" "PetHealSpell"
		/mmoini "MyIni" "Pet" "PetHealSpellGem"
		/mmoini "MyIni" "Pet" "UseAAPetHeal" "TRUE"
		/mmoini "MyIni" "Pet" "PetAAHealAt" "5"
		/mmoini "MyIni" "Pet" "DoPetBuffs" "FALSE"
		/mmoini "MyIni" "Pet" "PetBuffRecheck" "10s"
		/mmoini "MyIni" "Pet" "PetBuffTotal" "0"
		/for pb 1 to 6
			/mmoini "MyIni" "Pet" "PetBuffName${pb}"
			/mmoini "MyIni" "Pet" "PetBuffSpell${pb}"
			/mmoini "MyIni" "Pet" "PetBuffGem${pb}"
			/mmoini "MyIni" "Pet" "PetBuffRecast${pb}" "1s"	
		/next pb
		/declare i int local 1
		/declare p int local 1
		/for i 1 to ${AAPetBuff.Count[|]}
			/if (${Me.AltAbility[${AAPetBuff.Arg[${i},|]}]}) {
				/mmoini "MyIni" "Pet" "PetBuffName${p}" "${AAPetBuff.Arg[${i},|]}"
				/mmoini "MyIni" "Pet" "PetBuffSpell${p}" "${AAPetBuff.Arg[${i},|]}"
				/mmoini "MyIni" "Pet" "PetBuffGem${p}" "alt"
				/mmoini "MyIni" "Pet" "PetBuffRecast${pb}" "1s"
				/varcalc p ${p}+1
			}
			/if (${FindItem[${AAPetBuff.Arg[${i},|]}].ItemSlot}) {
				/mmoini "MyIni" "Pet" "PetBuffName${p}" "${AAPetBuff.Arg[${i},|]}"
				/mmoini "MyIni" "Pet" "PetBuffSpell${p}" "${AAPetBuff.Arg[${i},|]}"
				/mmoini "MyIni" "Pet" "PetBuffGem${p}" "item"
				/mmoini "MyIni" "Pet" "PetBuffRecast${pb}" "1s"
				/varcalc p ${p}+1
			}
		/next i
	}
	/if (!${Defined[PetGearDefaultAlias]}) /declare PetGearDefaultAlias string outer ${Ini[MyIni,Pet,PetGearDefaultAlias,NULL]}
	/if (${PetGearDefaultAlias.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetGearDefaultAlias"
/return

Sub PetAttack
	/if (${Me.Hovering}) /return
  	/if (${Me.Invis}||${Me.Feigning}) /return
  	/if (${Me.Pet.ID} && ${PetGHold} && !${Me.Pet.GHold} && ${Me.AltAbility[Pet Discipline]} && ${PetGHOLD}) /pet ghold on
  	/if (${Me.Pet.ID} && !${PetAttacking} && ${Target.ID}==${TarID} && ${Target.PctHPs}<${PetAttackAt} && ${Target.Distance}<=100) {
    	/pet attack
   		/if (${UsePetFocusAA} && ${Me.AltAbility[Pet Discipline].Rank}>=3) /pet focus on
		/if (${Me.AltAbility[Pet Discipline].Rank}>=4) /pet swarm
   		/varset PetAttacking TRUE
    }
/return

Sub PetBuffs
	/if (${Me.Hovering}) /return
	/if (${Me.Pet.ID} && ${PetGHold} && !${Me.Pet.GHold} && ${Me.AltAbility[Pet Discipline]} && ${PetGHOLD}) /pet ghold on
	/varset CurrentSub PetBuffs
	/if (!${Defined[PetLoaded]}) /call PetLoad
  	/if (${MMOBugs.ZoneSecs} && ${MMOBugs.ZoneSecs}<20||!${UsePet}) /return
  	/if (${Me.Pet.ID} && ${Me.Pet.Name.Find[familiar]}) /pet get lost 
  	/if (${Me.Invis} && !${AutoBreakInvis} && !${AutoInvis}|| ${Me.Moving} || ${PetBuffRecheck}||${Me.Feigning}) /return
  	/if (!${Me.Pet.ID} && ${UsePet} && (${Spell[${PetSpell}].ReagentID[1]}>0 && ${FindItemCount[${Spell[${PetSpell}].ReagentID[1]}]}>=${Spell[${PetSpell}].ReagentCount[1]}||${Spell[${PetSpell}].ReagentID[1]}<0||${Spell[${PetSpell}].ReagentID[1]}==NULL) && ${Me.CurrentMana}>${Spell[${PetSpell}].Mana}) {
  		/if (${Me.AltAbility[Suspended Minion]}) /alt activate 176
        /delay 1s
		
		:petcasting
		/if (${Me.Casting.ID}) /goto :petcasting
		/delay 5

  		/if (!${Me.Pet.ID}) {
			/delay 3s ${Me.Pet.ID}
			/if (${Me.Pet.ID}) /goto :petmade

			/declare OriginalEar string local NULL
			/declare OriginalInvSlot string local NULL
			/if ( ${FindItem[=${PetFocusItem}].Name.Equal[${PetFocusItem}]} && !${InvSlot[leftear].Item.Name.Equal[${PetFocusItem}]} && !${InvSlot[rightear].Item.Name.Equal[${PetFocusItem}]}) {
				/echo Attempting to equip focus item ${PetFocusItem} before casting pet
				/varset OriginalInvSlot ${FindItem[=${PetFocusItem}].InvSlot.ID}
				/itemnotify ${FindItem[=${PetFocusItem}].InvSlot} leftmouseup
				/delay 2s ${Cursor.ID}
				/itemnotify leftear leftmouseup
				/delay 2s ${InvSlot[leftear].Item.Name.Equal[${PetFocusItem}]}
				/varset OriginalEar ${Cursor.Name}
				/autoinv
      			/call Cast "${PetSpell}" ${PetSpellGem} 15s CheckStuff NULL
				/itemnotify ${FindItem[=${OriginalEar}].InvSlot} leftmouseup
				/delay 2s ${Cursor.ID}
				/itemnotify leftear leftmouseup
				/delay 2s ${InvSlot[leftear].Item.Name.Equal[${OriginalEar}]}
				/itemnotify ${OriginalInvSlot} leftmouseup
				/autoinv
				/delay 2s !${Cursor.ID}
			} else {
				/echo Casting pet without explicitly equipping focus item
				/echo PetFocusItem is ${PetFocusItem}
				/call Cast "${PetSpell}" ${PetSpellGem} 15s CheckStuff NULL
			}
      	}
			
		:petmade
        /if (${Me.Pet.ID} && ${Me.AltAbility[Pet Discipline]} && ${PetGHOLD}) /pet ghold on
		/if (${Me.Pet.ID} && !${Spawn[id ${Me.Pet.ID}].Holding} && ${PetGearDefaultAlias.NotEqual[NULL]}) /echo PetGear ${PetGearDefaultAlias}
   	}
   
   	/if (${DoPetBuffs} && ${Me.Pet.ID} && !${PetBuffRecheck} && ${Me.Pet.Distance}<100) {
		/declare p int local
		/for p 1 to ${PetBuffTotal}
			/if (!${Me.PetBuff[${PetBuffName${p}}]} && ${PetBuffTotal}>=${p} && !${PetBuffRecast${p}} && ${Spell[${PetBuffName${p}}].StacksPet}) {		
				/if (${PetBuffGem${p}.Equal[alt]} && ${Me.AltAbilityReady[${PetBuffSpell${p}}]}) {
					/if (${Spell[${PetBuffSpell${p}}].TargetType.Equal[single]}) /squelch /tar id ${Me.Pet.ID}
					/call Cast "${PetBuffSpell${p}}" ${PetBuffGem${p}} 10s NULL NULL
					/call ${EchoSub} "${Pink} ${PetBuffSpell${p}} --> ${White} ${Me.Pet.CleanName}"
					/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${PetBuffSpell${p}} --> ${Me.Pet.CleanName}
				}
				/if (${PetBuffGem${p}.Find[gem]}) {
					/if (${Spell[${PetBuffSpell${p}}].TargetType.Equal[single]}) /squelch /tar id ${Me.Pet.ID}
					/Casting "${PetBuffSpell${p}}" ${PetBuffGem${p}} -maxtries|5
					/call ${EchoSub} "${Pink} ${PetBuffSpell${p}} --> ${White} ${Me.Pet.CleanName}"
					/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${PetBuffSpell${p}} --> ${Me.Pet.CleanName}
				}
				/if (${PetBuffGem${p}.Equal[item]} && ${Cast.Ready[${PetBuffSpell${p}}]} && ${Me.HaveExpansion[Veil of Alaris]}) {
					/useitem ${FindItem[=${PetBuffSpell${p}}].ItemSlot} ${FindItem[=${PetBuffSpell${p}}].ItemSlot2}
				} else {
					/casting "${PetBuffSpell${p}}"|item
				}
				/delay 3
				/delay 10s !${Me.Casting.ID}
				/if (${Macro.Return.Equal[CAST_SUCCESS]}||${Macro.Return.Equal[CAST_NOTHOLD]}) {
					/if (!${Defined[PetBuffRecast${p}]}) /declare PetBuffRecast${p} timer outer ${Ini[MyIni,Pet,PetBuffRecast${p},10]}
					/varset PetBuffRecast${p} ${Ini[MyIni,Pet,PetBuffRecast${p},10]}
				}
			}
		/next p
	}

  	/if (${ShrinkPet} && ${Me.Pet.ID} && (${Me.Pet.Height}>${ShrinkPetIfHeightAbove})) {
		/if (${Target.ID}!=${Me.Pet.ID}) /squelch /target id ${Me.Pet.ID}
		/delay 3s ${Target.ID}==${Me.Pet.ID}
		/if (${ShrinkPetSpellGem.Equal[item]} && ${Me.HaveExpansion[Veil of Alaris]}) /useitem ${FindItem[=${ShrinkPetSpell}].ItemSlot} ${FindItem[=${ShrinkPetSpell}].ItemSlot2}
		/if (${ShrinkPetSpellGem.Equal[item]} && !${Me.HaveExpansion[Veil of Alaris]})	/casting "${ShrinkPetSpell}"|item
		/if (${ShrinkPetSpellGem.NotEqual[item]})   /call Cast "${ShrinkPetSpell}" ${ShrinkPetSpellGem} 3s NULL NULL
		/if (${ShrinkPetSpellGem.Equal[item]}) {
			/delay 1s
			/delay 10s !${Me.Casting.ID}
		}
			
		/if (${Spawn[${TarID}].ID}) {
			/if (${Target.ID}!=${Spawn[${TarID}].ID}) /call CheckTarget${AssistType}
		} 
		/delay 1
		/if (${Target.ID}==${Me.Pet.ID}) /squelch /target clear
	}
   	/if (!${Defined[PetBuffRecheck]}) /declare PetBuffRecheck timer outer ${Ini[MyIni,Pet,PetBuffRecheck,10s]}
   	/if (!${PetBuffRecheck}) /varset PetBuffRecheck ${PetBuffRecheck.OriginalValue}
   	/if (${Target.ID}==${Me.Pet.ID} && !${Me.Casting.ID}) /squelch /tar clear
/return
|pet end

|petgear start
#event PetGear "#*#PetGear #0#"

Sub Event_PetGear(string PetItemsString)
	/if (!${Me.Pet.ID}) /return
	/if (!${Defined[PetItems]}) /declare PetItems string outer
	/varset PetItems ${PetItemsString}
	/declare x string local
	/declare i int local
	/if (${Cursor.ID}) /autoinv
	/if (${PetItems.Find[|]}) {
		/if (${PetItems.Arg[1,|].Equal[add]}) {
			/varset x ${PetItems.Arg[3,|]}
			/varset x ${x.Right[-57]}
			/varset x ${x.Left[-1]}
			/mmoini "MyIni" "Pet" "${PetItems.Arg[2,|]}" "${x}"
			/if (!${Defined[${PetItems.Arg[2,|]}]}) /declare ${PetItems.Arg[2,|]} string outer 
			/varset ${PetItems.Arg[2,|]} ${Ini[MyIni,Pet,${PetItems.Arg[2,|]}]}
			/echo ${x} added to [Pet] with alias: ${PetItems.Arg[2,|]}
		}
		/if (${PetItems.Arg[1,|].NotEqual[add]}) {
			/for i 1 to ${Math.Calc[${PetItems.Count[|]}+1]}
				/if (!${Defined[petgear${i}]}) /declare petgear${i} string outer
				/varset petgear${i} ${Ini[MyIni,Pet,${PetItems.Arg[${i},|]}]}
				/if (!${petgear${i}.Length}) {
					/echo ${petgear${i}} not a valid option, ignoring request.
					/break
				}
				/if (${Me.Class.ShortName.Equal[MAG]} && !${FindItem[${petgear${i}}].ItemSlot}) {
					/call SummonPetGear ${Me.ID}
					/if (${FindItem[${petgear1}].ItemSlot} && ${Me.Pet.ID}!=${MyPetID}) {
						/petgear ${PetItems}
						/varset MyPetID ${Me.Pet.ID}
					}
					/doevents PetGear
				}
				/if (${FindItem[${petgear${i}}].ItemSlot}) {
					/squelch /tar id ${Me.Pet.ID}
					:movewait
					|/if (${Spawn[id ${Me.Pet.ID}].Distance}>20) /moveto loc ${Spawn[id ${Me.Pet.ID}].Y} ${Spawn[id ${Me.Pet.ID}].X}
					/if (${Spawn[id ${Me.Pet.ID}].Distance}>20 && !${Me.Pet.Moving}) /pet back
					/if (${Spawn[id ${Me.Pet.ID}].Distance}>20) /goto :movewait
					/itemnotify ${FindItem[=${petgear${i}}].InvSlot} leftmouseup
			        |/if (!${Window[GiveWnd].Open}) {
					/delay 2s ${Cursor.ID}
	
					:OpenGiveWindow
					/if (!${Cursor.ID}) /continue
					/echo ${Cursor.Name} --> ${Target.CleanName}
					/nomodkey /click left target
					/nomodkey /click left target
					/delay 3s ${Window[GiveWnd].Open}   	  
					|/if (!${Window[GiveWnd].Open}) /goto :OpenGiveWindow
					|	}
				}
			:skipi
			/next i
			
			/if (${Window[GiveWnd].Open}) /notify GiveWnd GVW_Give_Button leftmouseup   
		}
	}

	:skipPet
/return

#event PetGearRequest "#*#PetGearRequest #1#"

Sub Event_PetGearRequest(line, int PetGearRequestID)
	/if (!${Defined[PetGearSpellName]}) /declare PetGearSpellName string outer ${Ini[MyIni,Pet,PetGearSpellName,NULL]}
	/if (!${Defined[PetMaskSpellName]}) /declare PetMaskSpellName string outer ${Ini[MyIni,Pet,PetMaskSpellName,NULL]}
	/if (${Spawn[id ${PetGearRequestID}].ID} && ${Spawn[id ${PetGearRequestID}].Distance}<=${Spell[${PetGearSpellName}].Range}) /call SummonPetGear ${PetGearRequestID}
/return

Sub SummonPetGear(int PetGearID)
	/declare tempinvid int local
	/if (!${Defined[MyPetID]}) /declare MyPetID int outer
	/if (!${Defined[PetGearSpellName]}) /declare PetGearSpellName string outer ${Ini[MyIni,Pet,PetGearSpellName,NULL]}
	/if (!${Defined[PetMaskSpellName]}) /declare PetMaskSpellName string outer ${Ini[MyIni,Pet,PetMaskSpellName,NULL]}
	/if (!${Defined[PetArmorSpellName]}) /declare PetArmorSpellName string outer ${Ini[MyIni,Pet,PetArmorSpellName,NULL]}
	/if (!${Defined[PetGearSpellGem]}) /declare PetGearSpellGem string outer ${Ini[MyIni,Pet,PetGearSpellGem,NULL]}
	/if (!${Defined[PetGearDefaultInvSlotForBag]}) /declare PetGearDefaultInvSlotForBag int outer ${Ini[MyIni,Pet,PetGearDefaultInvSlotForBag,10]}
	/if (${PetGearSpellDefaultInvSlotForBag}==10) /mmoini "MyIni" "Pet" "PetGearDefaultInvSlotForBag" "10"
	/if (!${Defined[PetGearDefaultAlias]}) /declare PetGearDefaultAlias string outer ${Ini[MyIni,Pet,PetGearDefaultAlias,NULL]}
	/if (${PetGearSpellDefaultAlias.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetGearDefaultAlias"
	/if (${PetGearSpellName.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetGearSpellName"
	/if (${PetMaskSpellName.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetMaskSpellName"
	/if (${PetArmorSpellName.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetArmorSpellName"
	/if (${PetGearSpellGem.Equal[NULL]}) /mmoini "MyIni" "Pet" "PetGearSpellGem"
	/if (!${Defined[PetGearBagName]}) /declare PetGearBagName string outer
	/if (${PetGearSpellName.Equal[NULL]}) /return

	:clearcursor
	/if (${Cursor.ID}) /autoinv
	/if (${FindItem[Pouch of Quellious].ItemSlot} && ${PetGearID}==${Me.ID}) {
		/useitem ${FindItem[=Pouch of Quellious].ItemSlot} ${FindItem[=Pouch of Quellious].ItemSlot2}
		/delay 5s ${Cursor.Name.Equal[Pouch of Quellious]}
		/if (${Cursor.Name.Equal[Pouch of Quellious]}) /destroy
	}
	/if (${Cursor.ID}) {
		/echo Cursor not clear yet
		/goto :clearcursor
	}
	/tar id ${PetGearID}
	/delay 1s ${Target.ID}==${PetGearID}
	/if (${PetMaskSpellName.NotEqual[NULL]} && (${Me.ID}!=${Target.ID}||${Me.Level}<84)) /call Cast "${PetMaskSpellName}" "${PetGearSpellGem}" 30s NULL NULL
	/if (${Cursor.ID}) /autoinv
	/if (${PetArmorSpellName.NotEqual[NULL]} && ${Target.ID}!=${Me.ID}) /call Cast "${PetArmorSpellName}" "${PetGearSpellGem}" 30s NULL NULL
	/if (${Cursor.ID}) /autoinv
	/call Cast "${PetGearSpellName}" "${PetGearSpellGem}" 30s NULL NULL
	/if (${PetGearID}!=${Me.ID}) {
		/delay 10s !${Me.Casting.ID}
		/echo ${PetGearSpellName} --> ${Target.CleanName}
		/return
	}
	/if (${PetGearSpellName.NotEqual[NULL]}) {
		/delay 2s ${Me.Casting.ID}
		/delay 10s !${Me.Casting.ID}
		/delay 10s ${Cursor.ID}
		/varset PetGearBagName ${Cursor.Name}
		/itemnotify pack${PetGearDefaultInvSlotForBag} leftmouseup
		/delay 2s
		/if (${Cursor.ID}) /autoinv
		/delay 2
		/itemnotify ${FindItem[${PetGearBagName}].InvSlot} rightmouseup
		/delay 4s
		/varset PetGearBagName ${Cursor.Name}
		/itemnotify pack${PetGearDefaultInvSlotForBag} leftmouseup	
		|/if (${Cursor.ID}) /autoinventory
		|/if (${Cursor.Name.Equal[${PetGearBagName}]} && ${PetGearBagName.Length}) /destroy
	}
	/if (${PetGearSpellName.Equal[NULL]}) /echo PetGearSpellName is not defined in MyIni [Pet] section, cannot summon
/return
|petgear end

|Request start
Sub RequestLoad
	/varset CurrentSub Request
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare RequestConditions string outer ${Ini[MyIni,Request,RequestConditions]}
	/if (${RequestConditions.Equal[NULL]}) /mmoini "MyIni" "Request" "RequestConditions"
	/declare RequestTotal int outer ${Ini[MyIni,Request,RequestTotal]}
	/if (!${RequestTotal}) /mmoini "MyIni" "Request" "RequestTotal" "0"
	/declare i int local 3
	/if (${NeedLoad} && !${RequestTotal}) {
		/for i 1 to ${i}
			/mmoini "MyIni" "Request" "RequestUse${i}" "FALSE"	
			/mmoini "MyIni" "Request" "RequestCommand${i}"
			/mmoini "MyIni" "Request" "RequestConditions${i}"
			/mmoini "MyIni" "Request" "RequestTimer${i}" "30s" 
		/next i
	}
	
	/if (${RequestTotal}) {
		/for i 1 to ${RequestTotal}
			/declare RequestUse${i} bool outer ${Ini[MyIni,Request,RequestUse${i}]}
			/declare RequestCommand${i} string outer ${Ini[MyIni,Request,RequestCommand${i}]}
			/declare RequestConditions${i} string outer ${Ini[MyIni,Request,RequestConditions${i}]}
			/declare RequestTimer${i} string outer ${Ini[MyIni,Request,RequestTimer${i},30s]}
			/declare RequestDelay${i} timer outer
		/next i
	}
/return

Sub Request
	/if (${Me.Hovering}) /return
	/if (!${Defined[RequestLoaded]}) /call RequestLoad
	/varset CurrentSub Request
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${${CurrentSub}Conditions}||!${RequestTotal}) /return
	/declare i int local
	/for i 1 to ${RequestTotal}
		/varset RequestConditions${i} ${Ini[MyIni,Request,RequestConditions${i}]}
		/if (!${RequestDelay${i}} && ${RequestUse${i}} && ${RequestConditions${i}}) {
			/docommand ${RequestCommand${i}}
			/varset RequestDelay${i} ${RequestTimer${i}}
		}
	/next i
/return

|Request end

|rez start

#event RezLater	"You were unable to restore the corpse to life, but you may have success with a later attempt."
Sub RezLoad
	/varset CurrentSub Rez
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 2
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/mmoini "MyIni" "Rez" "GrabCorpse" "TRUE"
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|28|25|30|" "|${i}|TRUE|----|----|TRUE|----|TRUE|"
		/mmoini "MyIni" "Rez" "RezTrustedTotal" "0"
		/for i 1 to 5
			/mmoini "MyIni" "Rez" "RezTrusted${i}"
		/next i	
	}
	/declare GrabCorpse bool outer ${Ini[MyIni,Rez,GrabCorpse,TRUE]}
	/declare RezTrustedTotal int outer ${Ini[MyIni,Rez,RezTrustedTotal]}
	/declare RezTrustedList string outer |
	/for i 1 to ${RezTrustedTotal}
		/declare RezTrusted${i} string outer ${Ini[MyIni,Rez,RezTrusted${i}]}
		/varset RezTrustedList ${RezTrustedList}${RezTrusted${i}}|
	/next i
	/call SpellLoad2 "${CurrentSub}" "3|4|6|28|25|30|"
	/if (!${Defined[RezRaidTimer]}) {
		/declare RezRaidTimer string outer ${Ini[MyIni,Rez,RezRaidTimer,5m]}
		/if (${RezRaidTimer.Equal[5m]}) /mmoini "MyIni" "Rez" "RezRaidTimer" "5m"
	}
	/if (!${Defined[RezGroupTimer]}) {
		/declare RezGroupTimer string outer ${Ini[MyIni,Rez,RezGroupTimer,1m]}
		/if (${RezGroupTimer.Equal[1m]}) /mmoini "MyIni" "Rez" "RezGroupTimer" "1m"
	}
/return

Sub Rez
	/if (${Me.Hovering}) /return
	/if (!${Defined[RezLoaded]}) /call RezLoad
	/varset CurrentSub Rez
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${NeedLoad}||!${RezTotal}||!${Spawn[pccorpse radius 200].ID}) /return
	/declare t int local
	/declare x int local
	/if (${SpawnCount[pccorpse ${Me.CleanName}]} && ${Spawn[pccorpse ${Me.CleanName}].Distance}<100 && ${Me.Class.ShortName.Equal[CLR]}) /call RezNow ${Spawn[pccorpse ${Me.CleanName}].ID}
	/for x 1 to ${SpawnCount[radius 200]} 
		/if (!${Defined[${Spawn[pccorpse ${NearestSpawn[${x}]}].ID}RezTimer]}) /declare ${Spawn[pccorpse ${NearestSpawn[${x}]}].ID}RezTimer timer outer 0
		/if (${RezTrustedTotal} && ${Spawn[pccorpse ${NearestSpawn[${x}]}].ID} && !${${Spawn[pccorpse ${NearestSpawn[${x}]}].ID}RezTimer}) {
			/for t 1 to ${RezTrustedTotal} 
				/if (${RezTrusted${t}.Equal[${Spawn[pccorpse ${NearestSpawn[${x}]}].CleanName.Arg[1,']}]}) /call RezNow ${Spawn[pccorpse ${NearestSpawn[${x}]}].ID}
			/next t
		}  
		/if (!${${Spawn[pccorpse ${NearestSpawn[${x}]}].ID}RezTimer} && ${NearestSpawn[${x}].Type.Equal[corpse]} && (${Raid.Member[${NearestSpawn[${x}].CleanName.Arg[1,']}].Name.Length}||${Group.Member[${NearestSpawn[${x}].CleanName.Arg[1,']}].Name.Length})) /call RezNow ${NearestSpawn[${x}].ID}
	/next x
/return

Sub RezNow(int RezID)
	/if (${Spawn[id ${RezID}].Type.NotEqual[corpse]}||!${RezTotal}) /return
	/varset CurrentSub Rez
	/declare i int local
	/for i 1 to ${RezTotal}
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset RezConditions${i} ${Ini[MyIni,Rez,RezConditions${i},123456]}
		/if (!${RezConditions${i}}) /continue
		/if (${RezUse${i}} && ((!${Me.GemTimer[${RezSpellName${i}}]} && ${Me.Gem[${RezSpellName${i}}]}||${Me.AltAbilityReady[${RezSpellName${i}}]}||${Me.Book[${RezSpellName${i}}]} && ${ForceMemRez}) || (${FindItemCount[${RezSpellName${i}}]})) && ${RezSpellName${i}.NotEqual[Divine Resurrection]} && (${RezDuringCombat${i}}||!${Me.CombatState.Equal[COMBAT]})) {
			/squelch /tar id ${RezID}
			/delay 1s ${Target.ID}
			/if (${GrabCorpse}) /corpse
			/if (${Target.Type.NotEqual[corpse]}) /return
			/call ${EchoSub} "${Orange} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    		/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    		/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
			/call Cast "${RezSpellName${i}}" "${RezSpellGem${i}}" NULL NULL NULL
			/delay 3
			/delay 10s !${Me.Casting.ID}
			/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
				/if (!${Defined[${Target.ID}RezTimer]}) /declare ${Target.ID}RezTimer timer outer
				/if (${Raid.Members}) /varset ${Target.ID}RezTimer ${RezRaidTimer}
				/if (!${Raid.Members}) /varset ${Target.ID}RezTimer ${RezGroupTimer}
			}
		}
		/doevents
	/next i
/return

#event Trusted "#*#Toggle Trusted #1#"
Sub Event_Trusted(line, trustedname)
	/if (!${Defined[RezLoaded]}) /call RezLoad
	/if (${Me.Name.Equal[${trustedname}]}) {
		/echo ERROR: CANNOT DIV/0
		/goto :trusteddone
	}
	/declare i int local
	/declare x int local
	/if (!${RezTrustedTotal}) {
		/varset RezTrustedTotal 1
		/mmoini "MyIni" "Rez" "RezTrustedTotal" "${RezTrustedTotal}"
		/varset x 1
	}
	
	/for i 1 to ${RezTrustedTotal}
		/if (${RezTrusted${i}.Equal[${trustedname}]}) {
			/mmoini "MyIni" "Rez" "RezTrusted${i}"
			/varset RezTrusted${i} ${Ini[MyIni,Rez,RezTrusted${i}]}
			/echo Removing ${trustedname} from list
			/goto :trusteddone
		}
	/next i
	
	/for i 1 to ${RezTrustedTotal}
		/if (!${RezTrusted${i}.Length}) {
			/mmoini "MyIni" "Rez" "RezTrusted${i}" "${trustedname}"
			/echo Adding ${trustedname} to list
			/varset RezTrusted${i} ${Ini[MyIni,Rez,RezTrusted${i}]}
			/goto :trusteddone
		}
	/next i
	
	/if (!${x}) /varcalc RezTrustedTotal ${RezTrustedTotal}+1
	/mmoini "MyIni" "Rez" "RezTrustedTotal" "${RezTrustedTotal}"
	/echo Adding ${trustedname} to list
	/varset RezTrustedTotal ${Ini[MyIni,Rez,RezTrustedTotal]}
	/mmoini "MyIni" "Rez" "RezTrusted${RezTrustedTotal}" "${trustedname}"
	/if (!${Defined[RezTrusted${RezTrustedTotal}]}) /declare RezTrusted${RezTrustedTotal} string outer
	/varset RezTrusted${RezTrustedTotal} ${Ini[MyIni,Rez,RezTrusted${RezTrustedTotal}]}

	:trusteddone
/return

Sub Event_RezLater
	/if (!${Defined[${Target.ID}RezTimer]}) /declare ${Target.ID}RezTimer timer outer 1m
	/if (!${Defined[RezRaidTimer]}) {
		/declare RezRaidTimer string outer ${Ini[MyIni,Rez,RezRaidTimer,5m]}
		/if (${RezRaidTimer.Equal[5m]}) /mmoini "MyIni" "Rez" "RezRaidTimer" "5m"
	}
	/if (!${Defined[RezGroupTimer]}) {
		/declare RezGroupTimer string outer ${Ini[MyIni,Rez,RezGroupTimer,1m]}
		/if (${RezGroupimer.Equal[1m]}) /mmoini "MyIni" "Rez" "RezGroupTimer" "1m"
	}
	/if (${Raid.Members}) /varset ${Target.DisplayName}RezTimer ${RezRaidTimer}
	/if (!${Raid.Members}) /varset ${Target.ID}RezTimer ${RezGroupTimer}
/return

|rez end

|root start
Sub RootLoad
	/varset CurrentSub Root
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare i int local 1
	/if (${Select[${Me.Class.ShortName},CLR,PAL,NEC,WIZ]}) /varset i 2
	/if (${Select[${Me.Class.ShortName},SHM,ENC,RNG,DRU]}) /varset i 3
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/mmoini "MyIni" "${CurrentSub}" "DontRootConColor" "|GREY|GREEN|"
		/mmoini "MyIni" "${CurrentSub}" "RootPrimaryTarget" "FALSE"
		/mmoini "MyIni" "${CurrentSub}" "RootAdds" "TRUE"
		/mmoini "MyIni" "${CurrentSub}" "FaceNPCToRoot" "FALSE"
		/call SpellLoad "${CurrentSub}" ${i} "|1|2|3|4|6|7|8|9|13|30|" "|${i}|${i}|TRUE|----|----|96|1|2m|2|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|7|8|9|13|30|"
	/if (!${Defined[DontRootConColor]}) /declare DontRootConColor string outer ${Ini[MyIni,${CurrentSub},DontRootConColor,|GREY|GREEN|]}
	/if (!${Defined[RootPrimaryTarget]}) /declare RootPrimaryTarget bool outer ${Ini[MyIni,${CurrentSub},RootPrimaryTarget,FALSE]}
	/if (!${Defined[RootAdds]}) /declare RootAdds bool outer ${Ini[MyIni,${CurrentSub},RootAdds,FALSE]}
	/if (!${Defined[FaceNPCToRoot]}) /declare FaceNPCToRoot bool outer ${Ini[MyIni,${CurrentSub},FaceNPCToRoot,FALSE]}
	/for i 1 to ${RootTotal}
		/if (!${Defined[RootRecast${i}]}) /declare RootRecast${i} timer outer RootRecast${i} 0
		/if (!${Defined[Root${i}]}) {
			/declare Root${i}
		}
	/next i
/return

Sub RootClear(int RootMobID)
	/declare i int local
	/for i 1 to ${RootTotal}
		/if (${Defined[Root${i}${RootMobID}]}) /deletevar Root${i}${RootMobID}
		/if (${Defined[Root${i}${RootMobID}Resist]}) {
			/deletevar ${Root${i}${RootMobID}Resist}
		}

	/next i
/return

Sub Root
	/if (${Me.Hovering}) /return
	/varset CurrentSub Root
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (!${${CurrentSub}Total}||${NeedLoad}) /return
	/declare i int local
	/declare a int local
	/for i 1 to ${RootTotal}
		/if (!${Defined[Root${i}${TarID}]}) /declare Root${i}${TarID} int outer ${Target.ID} |** What kind of variable is this supposed to be?**|
		/if (!${Root${i}${TarID}} && ${TarID} && ${RootPrimaryTarget} && !${SnareImmuneList.Find[${Spawn[${TarID}].CleanName}]} && (${Spawn[id ${TarID}].Distance}<=${AttackRange}||${UseArchery})) /call RootAdd ${TarID}
	/next i
    /if (!${RootAdds}) /return
	/for a 1 to ${AddList.Count[|]}
		/for i 1 to ${RootTotal}
			/if (!${Defined[Root${i}${AddList.Arg[${a},|]}]} && ${TarID} && ${Spawn[id ${AddList.Arg[${a},|]}].ID} && !${SnareImmuneList.Find[${Spawn[id ${AddList.Arg[${a},|]}].CleanName}]} && ${AddList.Arg[${a},|]}!=${TarID}  && (${Spawn[id ${AddList.Arg[${a},|]}].Distance}<=${AttackRange}||${UseArchery})) /call RootAdd ${AddList.Arg[${a},|]}
		/next i
	/next a

/return

Sub RootAdd(int RootID)
	/varset CurrentSub Root
	/declare i int local
	/for i 1 to ${RootTotal}
		/if (!${${CurrentSub}Use${i}}) /continue
		/if (!${Defined[Root${i}${RootID}Resist]} && ${Spawn[id ${RootID}].ID}) /declare Root${i}${RootID}Resist int outer
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset RootConditions${i} ${Ini[MyIni,Root,RootConditions${i},123456]}
		/if (!${CastIsReady}) {
			/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
		}
		/if (!${Defined[${CurrentSub}IgnoreRecast${i}]}) /declare ${CurrentSub}IgnoreRecast${i} bool outer FALSE
		/if (!${Defined[${CurrentSub}On${i}]}) /declare ${CurrentSub}On${i} bool outer FALSE
		/if (!${Defined[${CurrentSub}Resisted${i}]}) /declare ${CurrentSub}Resisted${i} bool outer FALSE
		/if (${ValidSpell} && ${CanCastOnMob} && ((${Target.PctHPs}>=${${CurrentSub}StopAtMobPctHP${i}} && ${Target.PctHPs}<=${${CurrentSub}UseAtMobPctHP${i}}||!${Defined[${CurrentSub}UseAtMobPctHP${i}]}) && !${${CurrentSub}On${i}} && (!${${CurrentSub}MaxTries${i}}||${${CurrentSub}MaxTries${i}}>${${CurrentSub}Resisted${i}})) && ${CastIsReady} && ${RootConditions${i}}) {
			/if ((!${Defined[Root${i}${RootID}]}||${Defined[Root${i}${RootID}]} && !${Root${i}${RootID}}) && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady} && !${DontRootConColor.Find[|${Spawn[${RootID}].ConColor}|]}) {
				/if (${Target.ID} && ${Target.ID}!=${RootID} && ${Spawn[id ${RootID}].ID}) /squelch /tar id ${RootID}
				/delay 1s ${Target.ID}==${RootID}
				/if (!${Target.ID}) /return
				/if ((${Target.Type.Equal[Corpse]}) && ${Target.ID}||${Root${i}${RootID}}) /continue
				/if (${FaceNPCToRoot}) /face
				/call ${EchoSub} "${DarkYellow} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}  && ${AnnounceEvents.Find[TRY]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
				/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
				/if (${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[Free Target]}) {
					/keypress f10
					/face
					/delay 5
					/click left center
					/keypress f10
				}
				/delay 2
				/delay 3s !${Me.Casting.ID}
				/if (${Macro.Return.Equal[CAST_SUCCESS]}||${Macro.Return.Equal[CAST_NOTHOLD]}) {
					/if (!${Defined[Root${i}${RootID}]}) /declare Root${i}${RootID} timer outer ${Ini[MyIni,Root,RootRecast${i}]}
					/varset Root${i}${RootID} ${Ini[MyIni,Root,RootRecast${i}]}
					/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${Macro.Return.Equal[CAST_SUCCESS]} && ${AnnounceEvents.Find[CAST_SUCCESS]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} SUCCESS
				}
				/if (${Macro.Return.Equal[CAST_IMMUNE]})  {
					/declare Root${i}${RootID} timer outer 9999999
				}
				/if (${Macro.Return.Equal[CAST_RESIST]})  {
					/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_RESIST]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} RESIST
					/varcalc Root${i}${RootID}Resist ${Root${i}${RootID}Resist}+1
					/if (${Root${i}${RootID}Resist}>${RootMaxTries${i}}) /declare Root${i}${RootID} timer outer 9999999
				}
			}
		}
	:skip
	:nextRoot
	/next i
/return
|root end

|selfbuff start
Sub SelfBuffLoad
	/varset CurrentSub SelfBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 1
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/varset i 3
		/if (${Select[${Me.Class.ShortName},NEC,MAG,BRD]}) /varset i 5
		/if (${Select[${Me.Class.ShortName},SHM,BST,PAL,CLR,SHD,RNG]}) /varset i 8
		/if (${Select[${Me.Class.ShortName},ENC]}) /varset i 10
		/if (${Select[${Me.Class.ShortName},WIZ]}) /varset i 16
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|5|6|30|" "|0|TRUE|----|----|----|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|5|6|30|"
	/if (!${Defined[tempsbid]}) /declare tempsbid int outer
	/noparse /declare SelfBuffList string outer (${MMOBugs.FreeBuffs} && ${SelfBuffTotal} && (${SelfBuffUse1} && !${Me.Buff[${SelfBuffSpellIcon1}].ID} && ${Spell${SelfBuffSpellIcon1}].Stacks}) || (${SelfBuffUse2}&&!${Me.Buff[${SelfBuffSpellIcon2}].ID} && ${Spell${SelfBuffSpellIcon2}].Stacks}) || (${SelfBuffUse3} && !${Me.Buff[${SelfBuffSpellIcon3}].ID} && ${Spell${SelfBuffSpellIcon3}].Stacks}) || (${SelfBuffUse4} && !${Me.Buff[${SelfBuffSpellIcon4}].ID} && ${Spell${SelfBuffSpellIcon4}].Stacks}) || (${SelfBuffUse5}&&!${Me.Buff[${SelfBuffSpellIcon5}].ID} && ${Spell${SelfBuffSpellIcon5}].Stacks}) || (${SelfBuffUse6}&&!${Me.Buff[${SelfBuffSpellIcon6}].ID} && ${Spell${SelfBuffSpellIcon6}].Stacks}) || (${SelfBuffUse7}&&!${Me.Buff[${SelfBuffSpellIcon7}].ID} && ${Spell${SelfBuffSpellIcon7}].Stacks}) || (${SelfBuffUse8}&&!${Me.Buff[${SelfBuffSpellIcon8}].ID} && ${Spell${SelfBuffSpellIcon8}].Stacks}) || (${SelfBuffUse9}&&!${Me.Buff[${SelfBuffSpellIcon9}].ID} && ${Spell${SelfBuffSpellIcon9}].Stacks}) || (${SelfBuffUse10}&&!${Me.Buff[${SelfBuffSpellIcon10}].ID} && ${Spell${SelfBuffSpellIcon10}].Stacks}))
/return

Sub SelfBuff
	/if (${Me.Hovering}) /return
	/varset CurrentSub SelfBuff
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
  	/if (${ImNotReady}||!${${CurrentSub}Total}||${NeedLoad}||!${MMOBugs.FreeBuffs}) /return
	/varset tempsbid 0
	/declare i int local
	/for i 1 to ${${CurrentSub}Total}
		/if (!${${CurrentSub}Use${i}}||${Me.Casting.ID}) /continue
		/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset SelfBuffConditions${i} ${Ini[MyIni,SelfBuff,SelfBuffConditions${i},123456]}
		/if (${SpellStacks} && ${SelfBuffUse${i}} && (!${Me.AltAbility[${SelfBuffSpellName${i}}]}||${Me.AltAbilityReady[${SelfBuffSpellName${i}}]}||${FindItem[${SelfBuffSpellName${i}}].ItemSlot} && !${FindItem[${SelfBuffSpellName${i}}].Timer}) && ${SelfBuffConditions${i}}) {
			/if ((${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[pc]}||${Spell[${${CurrentSub}SpellName${i}}].TargetType.Equal[single]}) && ${Target.ID}!=${Me.ID}) {
				/varset tempsbid ${Target.ID}
				/squelch /tar id ${Me.ID}
				/delay 1s ${Target.ID}==${Me.ID}
			}
			/call ${EchoSub} "${White} ${${CurrentSub}SpellName${i}}"
			/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}}
			/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
			/if (${Me.Class.ShortName.Equal[BRD]}) /casting "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}}
			/if (${Me.Class.ShortName.NotEqual[BRD]}) /call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
		}
	
		:selfbuffwait
		/delay 1
		/if (${Me.Casting.ID}) /goto :selfbuffwait
	:skip
	/next i
	
	/if (${tempsbid}&&${Spawn[${tempsbid}].Type.Equal[npc]}) /squelch /tar id ${tempsbid}
/return
|selfbuff end

|setroles start
Sub SetRolesLoad
	/varset CurrentSub SetRolesLoad
	/echo ${Red} LoadingSetRoles
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare SetRoles bool outer ${Ini[MyIni,Roles,SetRoles]}
	/if (!${SetRoles}) /return

	/declare GroupLeader string outer ${Ini[MyIni,Roles,GroupLeader]}
	/declare GroupMainTank string outer ${Ini[MyIni,Roles,GroupMainTank]}
	/declare GroupMainAssist string outer ${Ini[MyIni,Roles,GroupMainAssist]}
	/declare GroupPuller string outer ${Ini[MyIni,Roles,GroupPuller]}
	/declare GroupXTarget1 string outer ${Ini[MyIni,Roles,GroupXTarget1]}
	/declare RaidXTarget1 string outer ${Ini[MyIni,Roles,RaidXTarget1]}
	/declare RaidCheck int outer
	/declare GroupCheck int outer
	/if (${Spawn[group mercenary ${GroupMainTank}].ID}) /varset GroupMainTank ${Spawn[group mercenary ${GroupMainTank}]}
	/if (${Spawn[group mercenary ${GroupMainAssist}].ID}) /varset GroupMainAssist ${Spawn[group mercenary ${GroupMainAssist}]}
	/if (${NeedLoad} && !${SetRoles}) {
		/mmoini "MyIni" "Roles" "SetRoles" "FALSE"
		/mmoini "MyIni" "Roles" "GroupLeader" ${Group.Leader}
		/mmoini "MyIni" "Roles" "GroupMainTank" ${Group.MainTank}
		/mmoini "MyIni" "Roles" "GroupMainAssist" ${Group.MainAssist}
		/mmoini "MyIni" "Roles" "GroupPuller" ${Group.Puller}
		/mmoini "MyIni" "Roles" "GroupXTarget1" "Group Assist Target"
		/mmoini "MyIni" "Roles" "RaidXTarget1" "Raid Assist 1 Target"
		/echo Loading Roles Info to MyIni
	}

/return

Sub SetRoles
	/varset CurrentSub SetRoles
	/if (!${Defined[${CurrentSub}Loaded]}) /call SetRolesLoad
	/if (!${SetRoles}) /return
	/if (!${Raid.Members} && !${Me.XTarget[1].TargetType.Equal[${GroupXTarget1}]} && ${Group.MainTank.ID}!=${Me.ID} && !${GroupCheck}) {
		/xtarget set 1 ${GroupXTarget1.Replace[ ,]}
		/varset GroupCheck 1
		/xtarget set 1 ${GroupXTarget1.Replace[ ,]}
	}
	/if (${Raid.Members} && !${Me.XTarget[1].TargetType.Equal[${RaidXTarget1}]} && !${RaidCheck}) {
		/xtarget set 1 ${RaidXTarget1.Replace[ ,]}
		/varset RaidCheck 1
		/xtarget set 1 ${RaidXTarget1.Replace[ ,]}
	}
	|/if (!${Raid.Members} && !${Me.XTarget[1].TargetType.Equal[Auto Hater]} && ${Group.MainTank.ID}==${Me.ID}) /setrole 1 "Auto Hater"
	/if (!${Raid.Members} && !${Me.XTarget[1].TargetType.Equal[Auto Hater]} && ${Group.MainTank.ID}==${Me.ID}) /xtarget set 1 AutoHater
	/if (${Group.Leader.ID}!=${Me.ID}) /return
	/if (${Spawn[group ${GroupMainAssist}].ID} && ${Group.MainAssist.ID}!=${Spawn[group ${GroupMainAssist}].ID}) /grouproles set "${GroupMainAssist}" 2
	/if (${Spawn[group ${GroupMainTank}].ID} && ${Group.MainTank.ID}!=${Spawn[group ${GroupMainTank}].ID}) /grouproles set "${GroupMainTank}" 1
	/if (${Spawn[group ${GroupPuller}].ID} && ${Group.Puller.ID}!=${Spawn[group ${GroupPuller}].ID}) /grouproles set "${GroupPuller}" 3
	/if (${Spawn[group ${GroupLeader}].ID} && ${Group.Leader.ID}!=${Spawn[group ${GroupLeader}].ID}) /makeleader ${GroupLeader}
/return

|setroles end

|snare start
#event SnareImmune     		"#*#is immune to changes in its#*#"
#event Snareon			"#*#damage by your |${Snare}|#*#"
#event Snareon			"#*#engulfed by darkness#*#"
#event Snareon			"#*#engulfed in an embracing darkness#*#"
#event Snareon			"#*#is shackled to the ground#*#"
#event Snareon         		"#*#has been ensnared#*#"
#event Snareon         		"#*#movements slow as their feet are covered in tangling weeds#*#"
#event Snareon         		"#*#has been entangled#*#"
#event Snareon         		"#*#has been entrapped in living earth#*#"
#event Snareon			"#*##covered in coruscating black shadows#*#"
|#event SnareResist     		"#*#Your target resisted the |${Snare}|#*#"
|#event SnareWornOff    		"Your |${Snare}| spell has worn off#*#"

Sub SnareLoad
	/varset CurrentSub Snare
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 1
	/if (${Select[${Me.Class.ShortName},WIZ]}) /varset i 3
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|7|13|" "|${i}|FALSE|----|----|15|2|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|7|13|"
	/declare Snared bool outer FALSE
	/declare SnareCounter int outer 0
/return

Sub Snare
	/if (${Me.Hovering}) /return
	/varset CurrentSub Snare
	/if (!${Defined[SnareLoaded]}) /call SnareLoad
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
  	/if (${ImNotReady}||(${SnareImmuneList.Find[${Target.CleanName}]} && ${Spell[${SnareSpellName1}].ResistType.NotEqual[Unresistable]})||${Snared}||!${SnareTotal}) /return
 	/declare i int local
 	/for i 1 to ${${CurrentSub}Total}
 		/if (!${${CurrentSub}Use${i}}) /continue
    	/if (${ValidEnemy}) {
			/if (!${CastIsReady}) {
				/memspell ${${CurrentSub}SpellGem${i}.Right[1]} "${${CurrentSub}SpellName${i}}"
			}
      		/if (${ValidSpell} && ${CanCastOnMob} && ${ShouldCastOnMob} && ${CastIsReady}) {
				/if (${ResistCheck}) {
					/call ${EchoSub} "${Green} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[TRY]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} NULL NULL NULL
					/delay 3s !${Me.Casting.ID}
					/if (${CastCounts}) {
						/varset Snared TRUE
						/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} SUCCESS						
					}
					/if (${Macro.Return.Equal[CAST_IMMUNE]}) {
						/varset Snared TRUE
						/goto :SnareImmune
					}		
					/if (${Macro.Return.Equal[CAST_RESIST]}) {
						/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[${Macro.Return}]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName} RESIST						
						/call Event_SnareResist
					}
				}
 			}
		}
	:skip
 	/next i

	:SnareImmune
	/doevents
/return

Sub Event_SnareImmune
	/if (!${Defined[SnareLoaded]}) /call SnareLoad
	/varset Snared TRUE
	|/echo snareimmunemob ${Target.CleanName}
/return

Sub Event_Snareon
	/if (!${Defined[SnareLoaded]}) /call SnareLoad
	/varset Snared TRUE
	|/if (${SnareTotal} && ${Target.ID}) /echo ${Target.CleanName} has been snared!
/return

Sub Event_SnareResist
	/if (!${Defined[SnareLoaded]}) /call SnareLoad
	/if (${SnareCounter}>=${SnareMaxTries1}) {
		/varset Snared TRUE
		/if (${SnareTotal}) /echo Snare resisted ${SnareMaxTries1} times, giving up!
		/varset SnareCounter 0
		/return
	}
	/if (${SnareCounter}<${SnareMaxTries1}) {
		/varset Snared FALSE
		/varcalc SnareCounter ${SnareCounter}+1
		/if (${SnareTotal} && ${SnareAnnounce} && ${AnnounceChannel.NotEqual[NULL]} && ${AnnounceEvents.Find[CAST_IMMUNE]}) /docommand /${AnnounceChannel} ${MobName} SNARE RESIST
	}
/return

Sub Event_SnareWornOff
	/if (!${Defined[SnareLoaded]}) /call SnareLoad
	/varset Snared FALSE
/return
|snare end

|stun start
#event StunGate                   "|${Target.DisplayName}| begins to cast the gate spell#*#"
#event StunCHeal                   "|${Target.DisplayName}| begins to cast a spell. <Complete Heal>#*#"
#event StunCHeal                   "|${Target.DisplayName}| begins to cast a spell. (Complete Heal)#*#"

Sub StunLoad
	/varset CurrentSub Stun
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/declare i int local 0
	/if (${Select[${Me.Class.ShortName},ENC,CLR]}) /varset i 4
	/if (${Select[${Me.Class.ShortName},PAL]}) /varset i 6
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/call SpellLoad "${CurrentSub}" ${i} "|1|2|3|4|6|7|8|9|30|" "|${i}|${i}|TRUE|----|----|100|1|9s|TRUE|"
	}
	|/call SpellLoad "${CurrentSub}"
	/call SpellLoad2 "${CurrentSub}" "3|4|6|7|8|9|30|"
	/declare Stunned int outer 0
	/declare StunCHeal bool outer TRUE
/return

Sub Stun
	/if (${Me.Hovering}) /return
	/varset CurrentSub Stun
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
    /if (${ImNotReady}||${Target.Distance}>${AttackRange}) /return
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/declare b int local
 	/declare i int local
 	/for i 1 to ${${CurrentSub}Total}
 		/if (!${Defined[${CurrentSub}Use${i}]}) /declare ${CurrentSub}Use${i} bool outer TRUE
	 	/if (!${${CurrentSub}Use${i}}) /continue
		/if (!${Defined[StunOn${i}]}) /declare StunOn${i} bool outer FALSE
		/if (!${Defined[StunMaxTries${i}]}) /declare StunMaxTries${i} int outer 2
		/if (!${Defined[StunResisted${i}]}) /declare StunResisted${i} bool outer FALSE
			/if (${${CurrentSub}Conditions${i}.NotEqual[123456]}) /varset StunConditions${i} ${Ini[MyIni,Stun,StunConditions${i},123456]}
     		/if (${ValidEnemy}  && !${StunImmuneList.Find[${Target.CleanName}]} && ${StunConditions${i}} && ${ShouldCastOnMob} && ${CanCastOnMob}) {
      			/if ((${Me.AltAbilityReady[${${CurrentSub}SpellName${i}}]}||${Me.SpellReady[${${CurrentSub}SpellName${i}}]}) && ${Me.FeetWet}==${Target.FeetWet} && ${CanCastOnMob} && ${ShouldCastOnMob}) {
      			/if (${ResistCheck}) {
					/call ${EchoSub} "${Orange} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
    				/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
    				/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 0 CheckStuff NULL
					/delay 3s !${Me.Casting.ID}
					/if (${CastCounts}) {
						/varcalc Hate ${Hate}+2
						/varset ${CurrentSub}Recast${i} ${${CurrentSub}Recast${i}.OriginalValue}
						/if (${ExitSubEarly}) /goto :exitstun
					}
    			}
 			}
		}
	:skip
 	/next i
 	:exitstun
/return

Sub Event_StunGate
    /declare i int local
    /if (${StunCHeal} && ${Me.AltAbilityReady[Translocational Anchor]}) {
     	/echo Translocational Anchor --> ${Target.CleanName}
     	/call Cast "Translocational Anchor" alt NULL NULL NULL
   	}
    /for i 1 to ${StunTotal}
    	/if (${StunCHeal}  && (${Me.AltAbilityReady[${StunSpellName${i}}]}||${Me.SpellReady[${StunSpellName${i}}]})) {
			/call Cast "${StunSpellName${i}}" "${StunSpellGem${i}}" NULL NULL NULL
			/echo ${StunSpellName${i}} --> ${Target.DisplayName}
		}
    /next i
/return

Sub Event_StunCHeal
    /declare i int local
    /for i 1 to ${StunTotal}
    	/if (${StunCHeal}  && (${Me.AltAbilityReady[${StunSpellName${i}}]}||${Me.SpellReady[${StunSpellName${i}}]})) {
			/call Cast "${StunSpellName${i}}" "${StunSpellGem${i}}" NULL NULL NULL
			/echo ${StunSpellName${i}} --> ${Target.DisplayName}
		}
    /next i
/return
|stun end

Sub SummonItemLoad
	/if (!${Defined[SummonItemLoaded]}) {
		/declare SummonItemLoaded bool outer FALSE
	}
	/if (${SummonItemLoaded}) /return
	/varset SummonItemLoaded TRUE
	/declare SummonItemTotal int outer ${Ini[MyIni,SummonItem,SummonItemTotal,0]}
	/declare i int local
	/if (!${SummonItemTotal}) {
		/mmoini "MyIni" "SummonItem" "SummonItemTotal" "0"
		/for i 1 to 2
			/mmoini "MyIni" "SummonItem" "SummonItemUse${i}"
			/mmoini "MyIni" "SummonItem" "SummonItemName${i}"
			/mmoini "MyIni" "SummonItem" "SummonItemSpellGem${i}"
			/mmoini "MyIni" "SummonItem" "SummonItemConditions${i}"
		/next i
	}
	/if (!${SummonItemTotal}) /return
	/for i 1 to ${SummonItemTotal}
		/if (!${Defined[SummonItemUse${i}]}) /declare SummonItemUse${i} bool outer ${Ini[MyIni,SummonItem,SummonItemUse${i},FALSE]}
		/if (!${Defined[SummonItemName${i}]}) /declare SummonItemName${i} string outer ${Ini[MyIni,SummonItem,SummonItemName${i}]}
		/if (!${Defined[SummonItemSpellGem${i}]}) /declare SummonItemSpellGem${i} string outer ${Ini[MyIni,SummonItem,SummonItemSpellGem${i}]}
		/if (!${Defined[SummonItemConditions${i}]}) /declare SummonItemConditions${i} string outer ${Ini[MyIni,SummonItem,SummonItemConditions${i}]}
	/next i
/return

Sub SummonItem
	/if (!${Defined[SummonItemLoaded]}) {
		/declare SummonItemLoaded bool outer FALSE
	}
	/if (!${SummonItemLoaded}) /call SummonItemLoad
	/varset CurrentSub SummonItem
	/if (${Me.Invis}||${Me.Moving}||${Me.Casting.ID}||!${SummonItemTotal}) /return
	/declare i int local
	/for i 1 to ${SummonItemTotal}
		/if (${Me.Book[${SummonItemName${i}}]}||${Me.AltAbilityReady[${SummonItemName${i}}]}||${FindItem[${SummonItemName${i}}].ItemSlot} && !${FindItem[${SummonItemName${i}}].Timer}) {
			/varset SummonItemConditions${i} ${Ini[MyIni,SummonItem,SummonItemConditions${i}]}
			/if (${SummonItemConditions${i}}) {
				/if (${Spell[${SummonItemName${i}}].TargetType.Equal[single]}) /tar myself
				/autoinv
				/call ${EchoSub} "${Orange} ${SummonItemName${i}} --> ${White} Summoning"
				/call Cast "${SummonItemName${i}}" ${SummonItemSpellGem${i}} NULL NULL NULL
				/delay 2s ${Cursor.ID}
				/delay 5
				/autoinv
				/return
			}
		}
	/next i
/return

|summontank start
#event SummonTankTarget "#*#SummonTankTarget #1#"
#event SummonTankTarget "#*#SummonTankTarget"

Sub Event_SummonTankTarget(line, int SumRange)
	/if (!${Defined[SummonTankLoaded]}) /call SummonTankLoad
	/if (${SumRange}) /varset SumTankRange ${SumRange}
	/varset SummonTankTarget ${Target}
	/echo Summon Tanking ${Target} at ${SumTankRange} distance.
/return

Sub SummonTankLoad
	/varset CurrentSub SummonTank
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	/if (!${Defined[SummonTankTarget]}) /declare SummonTankTarget string outer
	/declare SumTankRange int outer 10
/return

Sub SummonTank
	/if (!${Defined[SummonTankLoaded]}) /call SummonTankLoad
	/if (!${SpawnCount[${SummonTankTarget}]}) /varset SummonTankTarget
	/if (${Target.ID} && ${Target.ID}==${Spawn[${SummonTankTarget}].ID} && ${Target.Distance}<=${Math.Calc[${Target.MaxRange}+${SumTankRange}]}) {
		/if (${Melee.Sticking}) /stick off
		/if (!${Range.Between[0,5:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Me.Heading.Degrees}]}]}]} && ${Target.ID}) /face
		/keypress back hold
		/if (!${Me.Pet.Following.ID} && ${Me.Pet.ID} && ${Target.ID} && ${Target.PctHPs}<=${PetAttackAt} && ${Target.ID}==${TarID}) /pet attack		
		/delay 2s ${Target.Distance}>=${Math.Calc[${Target.MaxRange}+${SumTankRange}]}
		/keypress forward
		/if (!${Range.Between[0,5:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Me.Heading.Degrees}]}]}]} && ${Target.ID}) /face
	}
/return	

|summontank end

#event LeapTarget "#*#LeapTarget #1#"
#event LeapTarget "#*#LeapTarget"

Sub Event_LeapTarget(line, int LeapAtRange)
	/if (!${Defined[LeapLoaded]}) /call LeapLoad
	/if (${LeapAtRange}) /varset LeapRange ${LeapAtRange}
	/varset LeapTarget ${Target}
	/echo Leaping ${Target} at ${LeapAtRange} distance.
/return

Sub LeapLoad
	/if (!${Defined[LeapLoaded]}) /declare LeapLoaded bool outer FALSE
	/if (${LeapLoaded}) /return
	/varset LeapLoaded TRUE
	/if (!${Defined[AALeap]}) /declare AALeap string outer |1q2w3e|Hate Step|Leap of Faith|Lyre Leap|Netherstep|Dimensional Instability|Dimensional Shield|Neshika's Blink|Whisperwind|
	/if (!${Defined[LeapTarget]}) /declare LeapTarget string outer
	/if (!${Defined[LeapSkill]}) {
			/declare i int local
			/for i 1 to ${AALeap.Count[|]}
				/if (!${Defined[LeapSkill]} && ${Me.AltAbility[${AALeap.Arg[${i},|]}]}) /declare LeapSkill string outer ${AALeap.Arg[${i},|]}
			/next i
	}

	/declare LeapRange int outer 30
/return

Sub Leap
	/if (!${Defined[LeapLoaded]}) /call LeapLoad
	/if (!${SpawnCount[${LeapTarget}]}) /varset LeapTarget
	/if (${Target.ID} && ${Target.ID}==${Spawn[${LeapTarget}].ID} && ${Target.Distance}<=${Math.Calc[${Target.MaxRange}+${LeapRange}]}) {
		/if (${Melee.Sticking}) /stick off
		/if (${Target.ID}  && ${Target.ID}) /face
		/if (${Me.AltAbilityReady[${LeapSkill}]}) /alt act ${Me.AltAbility[${LeapSkill}].ID}
		/delay 2
		/if (${Target.ID}  && ${Target.ID}) /face
		/if (!${Range.Between[0,5:${Math.Abs[${Math.Calc[${Target.HeadingTo.Degrees}-${Me.Heading.Degrees}]}]}]}) /face
	}
/return

|xheal start
Sub XHealLoad
	/varset CurrentSub XHeal
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/declare x int local
	/declare xtemptarget int outer
	/if (!${Defined[currheal]})  /declare currheal int outer
	
	/declare i int 1
	/if (${Select[${Me.Class.ShortName},PAL,SHM]}) /varset i 3
	/if (${Select[${Me.Class.ShortName},RNG]}) /varset i 4
	/if (${Select[${Me.Class.ShortName},CLR]}) /varset i 8
	/varset tempsubtotal ${Ini[MyIni,${CurrentSub},${CurrentSub}Total]}
	/if (${NeedLoad} && !${tempsubtotal} && ${i}) {
		/mmoini "MyIni" "${CurrentSub}" "XHealPullerName" "${Group.Puller}"
		/mmoini "MyIni" "${CurrentSub}" "XHealPullerDist" "50"
		/call SpellLoad "${CurrentSub}" ${i} "|1|3|4|6|21|22|" "|${i}|TRUE|----|----|50|90|"
		/mmoini "MyIni" "Settings" "InterruptToXHealAt" "50"
		/if (${Me.Class.ShortName.Equal[NEC]}) {
			/mmoini "MyIni" "Settings" "InterruptToXHealAt" "1"
			/mmoini "MyIni" "XHeal" "XHealTotal" "0"
		}

	}
	/call SpellLoad2 "${CurrentSub}" "3|4|6|21|22|"
	/if (!${Defined[xtemptarget]}) /declare healtemptarget int outer
	/if (!${Defined[XHealPullerDist]}) /declare XHealPullerDist int outer ${Ini[MyIni,${CurrentSub},XHealPullerDist,50]}
	/declare XHealPullerName string outer ${Ini[MyIni,${CurrentSub},XHealPullerName,${Group.Puller}]}
	/if (!${Defined[InterruptToXHealAt]}) /declare InterruptToXHealAt int outer ${Ini[MyIni,Settings,InterruptToXHealAt,1]}
/return

Sub XHeal
	/if (${Me.Hovering}) /return
	/varset CurrentSub XHeal
	/if (!${Defined[${CurrentSub}Loaded]}) /call ${CurrentSub}Load
	/if (${${CurrentSub}Conditions.NotEqual[123456]}) /varset ${CurrentSub}Conditions ${Ini[MyIni,${CurrentSub},${CurrentSub}Conditions,123456]}
	/if (!${${CurrentSub}Conditions}) /return
	/if (${MMOBugs.ZoneSecs} && ${MMOBugs.ZoneSecs}<20) /return
	/varset xtemptarget 0
	/declare x int local
	/declare i int local
	/for x 1 to ${XTarget.Max}
		/for i 1 to ${${CurrentSub}Total}
			/if (!${Defined[${CurrentSub}Use${i}]}) /declare ${CurrentSub}Use${i} bool outer FALSE
			/if (!${${CurrentSub}Use${i}}) /continue
			/if (${Spawn[id ${Me.XTarget[${x}].ID}].PctHPs}<${${CurrentSub}UseAt${i}} && (${Spawn[id ${Me.XTarget[${x}].ID}].Type.Equal[pc]}||${Spawn[id ${Me.XTarget[${x}].ID}].Type.Equal[pet]}||${Spawn[id ${Me.XTarget[${x}].ID}].Type.Equal[mercenary]}) && ${Me.XTarget[${x}].Type.NotEqual[Auto Hater]}) {
				/if (${Me.CurrentMana}>=${Spell[${${CurrentSub}SpellName${i}}].Mana} && ${Me.SpellReady[${${CurrentSub}SpellName${i}}]} && ${Spawn[id ${Me.XTarget[${x}].ID}].Distance}<=${Spell[${${CurrentSub}SpellName${i}}].MyRange} && (${Me.XTarget[${x}].ID}!=${Spawn[id ${${CurrentSub}PullerName}].ID}||${Spawn[id ${Me.XTarget[${x}].ID}].Distance}<=${${CurrentSub}PullerDist})) {
					/if (${Target.ID}) /varset xtemptarget ${Target.ID}
					/if (${Me.XTarget[${x}].ID}) /squelch /tar id ${Me.XTarget[${x}].ID}
					/delay 10 ${Target.ID}
					|/bc ${${CurrentSub}${i}} => ${Target}
					/varset currheal ${i}
					/call ${EchoSub} "${Teal} ${${CurrentSub}SpellName${i}} --> ${White} ${Target}"
					/if (${Verbose} && ${MyChannel.NotEqual[NULL]}) /docommand /${MyChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/if (${${CurrentSub}Announce} && ${AnnounceChannel.NotEqual[NULL]}) /docommand /${AnnounceChannel} ${${CurrentSub}SpellName${i}} --> ${Target.CleanName}
					/call Cast "${${CurrentSub}SpellName${i}}" ${${CurrentSub}SpellGem${i}} 3s CheckXHP NULL 
				}
			}
		:skip
		/next i
	/next x
	/if (${xtemptarget}&&${Spawn[${xtemptarget}].Type.Equal[npc]}) /squelch /tar id ${xtemptarget}
/return

Sub CheckXHP
	/if (${Target.PctHPs}>=${${CurrentSub}StopAt${currheal}}) /call Interrupt
/return
|xheal end

|#######################  AA BUYING ####################
#event LoadAABuy "#*#Load include files#*#"

Sub Event_LoadAABuy
	/if (${AABuyLoaded}) /return
	/call AABuyLoad
/return

#event AASpew "#*#|AASpewList| #1#"
Sub AABuyLoad
	/varset CurrentSub AABuy
	/call Debug 3 "Entering Sub ${CurrentSub}"
	/if (!${Defined[${CurrentSub}Loaded]}) /declare ${CurrentSub}Loaded bool outer FALSE
	/if (${${CurrentSub}Loaded}) /return
	/varset ${CurrentSub}Loaded TRUE
	
	/if (${AABuyLoaded}) /return
	/varset AABuyLoaded TRUE
	/declare LowestAAToBuy int outer
   	/declare i int local
	/declare EPH int outer
	/declare AABuy bool outer ${Ini[MyIni,AAtoBuy,AABuy,FALSE]}
	/if (!${AABuy}) /mmoini "MyIni" "AAtoBuy" "AABuy" "FALSE"
	/declare AABuyChannel string outer ${Ini[MyIni,AAtoBuy,AABuyChannel,/echo]}
	/if (${AABuyChannel.Equal[/echo]}) /mmoini "MyIni" "AAtoBuy" "AABuyChannel" "/echo"
	/declare AABuyAt int outer ${Ini[MyIni,AAtoBuy,AABuyAt,0]}
	/if (!${AABuyAt}) /mmoini "MyIni" "AAtoBuy" "AABuyAt" "25"
	/declare AABuyMode string outer ${Ini[MyIni,AAtoBuy,AABuyMode,Classic]}
	/if (${AABuyMode.Equal[classic]}) /mmoini "MyIni" "AAtoBuy" "AABuyMode" "Classic"
	/declare AABuyPageOrder string outer ${Ini[MyIni,AAtoBuy,AABuyPageOrder,Class|Archetype|General|Special]}
	/if (${AABuyPageOrder.Equal[Class|Archetype|General|Special]}) /mmoini "MyIni" "AAtoBuy" "AABuyPageOrder" "Class|Archetype|General|Special"
	/declare AAActivatedOnly bool outer ${Ini[MyIni,AAtoBuy,AAActivatedOnly,FALSE]}
	/if (!${AAActivatedOnly}) /mmoini "MyIni" "AAtoBuy" "AAActivatedOnly" "FALSE"
	|/declare CanPurchaseFilter bool outer ${Ini[MyIni,AAtoBuy,CanPurchaseFilter,TRUE]}
	|/if (${CanPurchaseFilter}) /mmoini "MyIni" "AAtoBuy" "CanPurchaseFilter" "TRUE"
	/declare SetAAPctOnLevelTo int outer ${Ini[MyIni,AAtoBuy,SetAAPctOnLevelTo,0]}
	/if (!${SetAAPctOnLevelTo}) /mmoini "MyIni" "AAtoBuy" "SetAAPctOnLevelTo" "0"	
	/declare LimitedGeneral string outer ${Ini[MyIni,AAtoBuy,LimitedGeneral,NULL]}
	/if (!${LimitedGeneral.Length}||${LimitedGeneral.Equal[NULL]}) /mmoini "MyIni" "AAtoBuy" "LimitedGeneral"
	/declare LimitedArchetype string outer ${Ini[MyIni,AAtoBuy,LimitedArchetype,NULL]}
	/if (!${LimitedArchetype.Length}||${LimitedArchetype.Equal[NULL]}) /mmoini "MyIni" "AAtoBuy" "LimitedArchetype"
	/declare LimitedClass string outer ${Ini[MyIni,AAtoBuy,LimitedClass,NULL]}
	/if (!${LimitedClass.Length}||${LimitedClass.Equal[NULL]}) /mmoini "MyIni" "AAtoBuy" "LimitedClass"
	/declare LimitedSpecial string outer ${Ini[MyIni,AAtoBuy,LimitedSpecial,NULL]}
	/if (!${LimitedSpecial.Length}||${LimitedSpecial.Equal[NULL]}) /mmoini "MyIni" "AAtoBuy" "LimitedSpecial"
	/declare AACount int outer ${Ini[MyIni,AAtoBuy,AACount,0]}
	/if (!${AACount}) /mmoini "MyIni" "AAtoBuy" "AACount" "0"
	/declare maxPurchaseLevel int outer
	/declare AACurrentMaxed int outer
	/declare AABuyTimer timer outer
	/declare lvl_aa string outer
	/call Event_AASpew
/return
	
Sub Event_AASpew(line,int AASpew)
	/if (${AASpew}) /echo Building AAtoBuy INI, wait to finish.
	/declare i int local

	/if (${AACount} && ${AABuyMode.Equal[classic]} && !${AASpew}) {
		/declare AA[${AACount},4] string outer 100
      	/for i 1 to ${AACount}
			/declare AABuy${i} string outer ${Ini[MyIni,AAtoBuy,AA${i}]}
			/varset AA[${i},1] ${AABuy${i}.Arg[1,|]}
			/varset AA[${i},2] ${AABuy${i}.Arg[2,|]}
			/varset AA[${i},3] List${AABuy${i}.Arg[3,|]}
  	 	/next i
  	 }

   	/if (${AABuyMode.Equal[brute]}||${AABuyMode.Equal[limited]}||${AASpew}) {
	    /if (${Window[AAWindow].Child[AAW_PassiveFilter].GetCurSel}!=2 && ${AAActivatedOnly}) /nomodkey /notify AAWindow AAW_PassiveFilter listselect 2   	
		/declare AABuyPageNum string outer
		/if (${Defined[AA]}) /deletevar AA
		/declare AA[400,4] string outer 100
		/for i 1 to 4
			/declare AABuyPage${i} string outer ${AABuyPageOrder.Arg[${i},|]}
			|/echo AABuyPage${i} ${AABuyPage${i}}
			/declare AABuyList${i} string outer ${AABuyPageOrder.Arg[${i},|]}
			/declare AABuyPageNum${i}
			/if (${AABuyPageOrder.Arg[${i},|].Equal[general]}) /varset AABuyPageNum${i} 1
			/if (${AABuyPageOrder.Arg[${i},|].Equal[archetype]}) {
				/varset AABuyPageNum${i} 2
				/varset AABuyList${i} Arch
			}
			/if (${AABuyPageOrder.Arg[${i},|].Equal[class]}) /varset AABuyPageNum${i} 3
			/if (${AABuyPageOrder.Arg[${i},|].Equal[special]}) /varset AABuyPageNum${i} 4
		/next i
		/varset AACount 0
		/declare x int local
		/declare a int local
		/for a 1 to 4
			|/echo ${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[1,3].Length} && ${AABuyPage${a}} (${Limited${AABuyPage${a}}.Equal[NULL]}||${Limited${AABuyPage${a}}.Find[${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[1,1]}]})
			/if (${AABuyPageNum${a}}==1) /varset x 50
			/if (${AABuyPageNum${a}}==2) /varset x 100
			/if (${AABuyPageNum${a}}==3) /varset x 200
			/if (${AABuyPageNum${a}}==4) /varset x 20
			/for i 1 to ${x}
				/if (${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[${i},3].Length} && (${Limited${AABuyPage${a}}.Equal[NULL]}||${Limited${AABuyPage${a}}.Find[${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[${i},1]}]})) {
					/varcalc AACount ${AACount}+1
					/if (${Defined[AABuy${AACount}]}) /deletevar AABuy${AACount}
					/call Debug 3 "i:${i} || Declaring AABuy${AACount}: /declare AABuy${AACount} string outer ${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[${i},1]}|M|${AABuyPageNum${a}}"
					/declare AABuy${AACount} string outer ${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[${i},1]}|M|${AABuyPageNum${a}}
					/if (${AASpew}) /mmoini "MyIni" "AAtoBuy" "AA${AACount}" "${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[${i},1]}|${Window[AAWindow].Child[AAW_Subwindows].Child[AAW_${AABuyPage${a}}Page].Child[AAW_${AABuyList${a}}List].List[${i},2].Arg[2,"/"]}|${AABuyPageNum${a}}" 
					/varset AA[${i},1] ${AABuy${AACount}.Arg[1,|]}
					/varset AA[${i},2] ${AABuy${AACount}.Arg[2,|]}
					/varset AA[${i},3] List${AABuy${AACount}.Arg[3,|]}
				}
			/next i
		/next a
		/echo AACount for Brute: ${AACount}
	}
	/if (${AASpew}) {
		/mmoini "MyIni" "AAtoBuy" "AACount" "${AACount}"
		/echo ${AACount} AAs dumped to MyIni [AAtoBuy] section
	}
/return

Sub ECheck
	/declare x int local
	/declare ECheckPH int local 100
	|** Changed from (!${[AACount}) to current on below line to handle undefined variable. It's Declared in Sub AABuyLoad. **|
	/if (!${Defined[AACount]}) /return 
	/for x 1 to ${AACount}
		/if (${AA[${x},2].Equal[E]}) {
			/varset AA[${x},4] ${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[2,"/"]}
			/if (${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[1,"/"]}<${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[2,"/"]}) {
				/if (${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[1,"/"]}<${ECheckPH}) {
					/varset ECheckPH ${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[1,"/"]}
					/varset LowestAAToBuy ${x}
				}
			}    
		}
	/next x
/return

Sub AABuy
	/if (!${AABuyLoaded}) /call AABuyLoad
	/if (${AAMaxed} && ${Me.AAPoints}==${AAMaxed}||${AACurrentMaxed}||!${AACount}) /return
	/call ECheck
	| Declare local variables
	/declare x int local
	/if (!${Defined[Cost]}) /declare Cost int outer
	/declare z int local
	/declare y int local
	/declare AALevelStr string local
	/declare curAALevel int local
	/declare maxAALevel int local
	/declare requiredLevel int local
	/declare requiredExpansion string local
	/declare maxCounter int local 0
	/if (${Defined[maxPurchaseLevel]}) /varset maxPurchaseLevel 0
	| Declare and set lvlDigits to 2
	/declare lvlDigits int local 2
	| Change lvlDigits to 1 if your level is less than 10 (useful for using this with a shroud)
	/if (${Me.Level}<10) /varset lvlDigits 1
	| Start for/next loop.
	/for x 1 to ${AACount}
		| Bookmark           
		:BuyAdditional
		/if (${Me.AAPoints}<${AABuyAt}) /return
		| If Can Purchase is unselected, select it.
		/if (!${Window[AAWindow].Child[CanPurchaseFilter].Checked}) /nomodkey /notify AAWindow CanPurchaseFilter leftmouseup
		| Check if the skill is available.
		/for z 1 to 4
			/if (${AA[${x},3].Right[1].Equal[${z}]} && ${Window[AAWindow].Child[List${z}].List[${AA[${x},1]}]}) /varset y ${z}
		/next z
		/if (!${y}) /continue

		/nomodkey /notify AAWindow AAW_Subwindows tabselect ${y}
		/if (${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].NotEqual[NULL]}) {
			| Grab current level information from the AAWindow
			/varset curAALevel ${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[1,"/"]}
			| and the max AA level of the AA.
			/varset maxAALevel ${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 2].Arg[2,"/"]}
			| Check if we are leveling to max skill
			/if (${AA[${x},2].Equal[M]}) /varset maxPurchaseLevel ${maxAALevel}
			| or if we want to level evenly: no easy way around it. brute force check
			/if (${x}==${LowestAAToBuy}) 	/varset maxPurchaseLevel ${Math.Calc[${AA[${x},4]}+1]}
			| or set to the max skill we want to train to
			/if (!${AA[${x},2].Equal[M]} && !${AA[${x},2].Equal[E]}) /varset maxPurchaseLevel ${AA[${x},2]}
			| and if the max skill we want to train is valid.
			/if (${maxPurchaseLevel}<=0  && !${AA[${x},2].Equal[E]}) {
				/docommand ${AABuyChannel} Error. ${AA[${x},1]} is set to an invalid level to train to. Skipping.
				/continue
			}
			/if (${maxPurchaseLevel}<${curAALevel}  && ${AA[${x},2].Equal[E]} && ${Me.AAPoints}>=${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 3]}) {
				/echo Skipping ${AA[${x},1]} to equalize.
				/continue
			}
			/if (${maxPurchaseLevel}<${curAALevel}  && ${AA[${x},2].Equal[E]} && ${Me.AAPoints}<${Window[AAWindow].Child[${AA[${x},3]}].List[${Window[AAWindow].Child[${AA[${x},3]}].List[=${AA[${x},1]}]}, 3]}) {
				/continue
			}
		}
		/if (!${maxPurchaseLevel}) /continue
		:aaselect
		| Select the AA so that we can
		/call AASelect ${x}
		/call AAPurchase
		/varcalc curAALevel ${curAALevel}+1
		/docommand ${AABuyChannel} Purchased level ${curAALevel}/${maxAALevel} of ${AA[${x},1]} for ${Cost} points.
		/delay 5
		/if (${Me.AAPoints}>=${AABuyAt}) {
				/call ECheck
				/goto :BuyAdditional
		}
	/next x
	| If all skills are maxed or you do not have the right expansions.
	/if (${maxCounter}==${AACount}) {
		/if (!${Defined[AACurrentMaxed]}) /declare AACurrentMaxed int outer 1
		/docommand ${AABuyChannel} All defined skills maxed or unable to be purchased due to expansion/prerequisite issues. You should define new ones.
		/varset AACurrentMaxed 1
	| Else, if not, wait for next round.
	} else {
		/docommand ${AABuyChannel} Cycled through all AA and nothing to purchase this round.
		/varset AACurrentMaxed 1
	}
	| If banked AA is greater than or equal to 27 and less than 30, issue a warning.
	/if (${Range.Between[27,30:${Me.AAPoints}]} && ${Me.Level}<91||${Range.Between[47,50:${Me.AAPoints}]} && ${Range.Between[91,95:${Me.Level}]}||${Range.Between[68,70:${Me.AAPoints}]} && ${Range.Between[95,100:${Me.Level}]}) /docommand ${AABuyChannel} WARNING!!! You are at ${Me.AAPoints} banked AA.
	| If banked AA equals 30, turn off alt exp.

	/if (${Me.AAPoints}>=30 && ${Me.Level}<91||${Me.AAPoints}>=50 && ${Range.Between[91,95:${Me.Level}]}||${Range.Between[68,70:${Me.AAPoints}]} && ${Range.Between[95,100:${Me.Level}]}) {
		/docommand ${AABuyChannel} You have maxed your AAs and are unable to purchase any of your defined AAs.
		/if (!${Defined[AAMaxed]}) /declare AAMaxed int outer ${Me.AAPoints}
		|**     
		/docommand ${AABuyChannel} Changing you to full level XP. Hopefully you are not max level yet.
		/alt off
		**|
		/if (!${Defined[lvl_aa]}) /declare lvl_aa string outer
		/varset lvl_aa ${Me.Level}_${Me.AAPoints}
	}
/return

Sub AASelect(string AANum)
	| Code to select the AA passed into it by AAName.
   	/nomodkey /notify AAWindow AAW_Subwindows tabselect ${AA[${AANum},3].Right[1]}
   	/nomodkey /notify AAWindow ${AA[${AANum},3]} listselect ${Window[AAWindow].Child[${AA[${AANum},3]}].List[=${AA[${AANum},1]}]}
   	/nomodkey /notify AAWindow ${AA[${AANum},3]} leftmouse ${Window[AAWindow].Child[${AA[${AANum},3]}].List[=${AA[${AANum},1]}]}
   	/varset Cost ${Window[AAWindow].Child[${AA[${AANum},3]}].List[${Window[AAWindow].Child[${AA[${AANum},3]}].List[=${AA[${AANum},1]}]}, 3]}
/return

Sub AAPurchase
	| The actual purchase code.
   	/nomodkey /notify AAWindow TrainButton leftmouseup
   	/delay 1s
	| If fast AA purchase is not on, accept the purchase.
   	/if (!${Window[OptionsWindow].Child[OptionsGeneralPage].Child[OGP_AANoConfirmCheckbox].Checked}) {
		:ConfirmWait
		/delay 10s ${Window[ConfirmationDialogBox].Open}
		/if (!${Window[ConfirmationDialogBox].Open}) /goto :ConfirmWait
		/delay 2s
		/nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
		/delay 5
   	}
/return

Sub GroupHealthChk
	/varset ${CurrentSub} "GroupHealthCheck"
	/if (!${Me.Combat}) {
		/if (${Verbose}) /echo Checking Health!
		/if (${Me.PctHPs} < ${WaitForHealth}) { 
			/echo YOU are low on Health! 
			:WaitForHealth0
			/if (!${XTarget[1].ID}) {
				/if (${Math.Distance[${Me.Y}, ${Me.X}, ${Me.Z}: ${CampY}, ${CampX}, ${CampZ}]} > ${Me.MaxRange}) {
				
					:MovingToCamp
					/if (!${MoveTo.Moving}) /moveto loc ${CampY} ${CampX} ${CampZ}
					/if (${MoveTo.Moving} && ${Target.ID} && ${Target.Type.Equal[NPC]} && !${XTarget[1].ID}) {
						/delay 5
						/goto :MovingToCamp
					}
				} else /if ((${Me.Standing}) && (!${Me.Casting.ID}) && (!${Me.Mount.ID}) && ${sitTimer}) 

				/delay 5
				/if (${Me.PctHPs} <= ${HealTill}) {
					/goto :WaitForHealth0
				}
			}
		}
		/if (${Verbose}) /echo GroupHealthChk finished Group Member # 0
		/declare i int local
		/for i 1 to ${Group} {
			/if (${Group.Member[${i}].State.Equal[DEAD]} ) { 
				/echo ${Group.Member[${i}].Name} has died. Waiting for them to get off their face. 
				:WaitForRez1
				/if (!${XTarget[1].ID}) {
					/if ((${Me.Standing}) && (!${Me.Casting.ID}) && (!${Me.Mount.ID}) && !${sitTimer}) 
					/delay 5
					/if (${Group.Member[${i}].State.Equal[DEAD]} ) { 
						/goto :WaitForRez1
					}
				}
			}
			/if (${Group.Member[${i}].ID}) {
				/if (${Group.Member[${i}].PctHPs} < ${WaitForHealth}) {
					/echo ${Group.Member[${i}].Name} is low on Health! 
					/goto :WaitForHealth1
					:WaitForHealth1
					/if (!${XTarget[1].ID}) {
						/if (${UseEQBC}) {
							/if (${Group.Member[${i}].State.Equal[Stand]} && !{Group.Member[${i}].Type.Equal[Mercenary]} && !${sitTimer}) /bct ${Group.Member[${i}].Name} /
						}
						/delay 5
						/if (${Group.Member[${i}].PctHPs} <= ${HealTill}) {
							/goto :WaitForHealth1
						}
					}
				}
			}
		}
		/if (${Verbose}) /echo GroupHealthChk finished Group Member # ${i}!
		/next i
	}
	/return

Sub GroupManaChk
	/varset ${CurrentSub} "Group Mana Check"
	/if (!${Me.Combat}) {
		/if (${Verbose}) /echo Checking Mana!
			/if (${Me.State.Equal[DEAD]} ) {
				/echo \arYOU~ have died! Waiting for YOU to get off your face. 
				:WaitForRez0
				/if (${Me.STATE.Equal[DEAD]} ) {
					/delay 1
					/goto :WaitForRez0
				}
			}
		/if ((${Me.PctMana} < ${Med}) && (${Me.Class.CanCast})) { 
			/echo \arYOU are low on mana! 
			/goto :WaitForMana0
			:WaitForMana0
			/if (!${XTarget[1].ID}) {
				/if (${Me.Standing} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${Me.Moving} && !${sitTimer}) 
				/delay 5
				/if (${Me.PctMana} <= ${MedTill}) {
					/goto :WaitForMana0
				}
			}
		}
		/if (${Verbose}) /echo GroupManaChk finished Group Member # 0
		/declare i int local
		/for i 1 to ${Group} {
			/if (${Group.Member[${i}].State.Equal[DEAD]} ) { 
				/echo \ar${Group.Member[${i}].Name} has died. Waiting for them to get off their face. 
				:WaitForRez1
				/if (${Group.Member[${i}].State.Equal[DEAD]} ) {
					/delay 1
					/goto :WaitForRez1
				}
			}
			/if ((${Group.Member[${i}].PctMana} < ${Med}) && (${Group.Member[${i}].Class.CanCast})) { 
				/echo \ar${Group.Member[${i}].Name} is low on mana! 
				/goto :WaitForMana1
				:WaitForMana1
				/if (!${XTarget[1].ID}) {
					/delay 1
					/if (${Group.Member[${i}].PctMana} <= ${MedTill}) {
						/goto :WaitForMana1
					}
				}
			}
		}
		/if (${Verbose}) /echo GroupManaChk finished Group Member # ${i}!
		/next i
	}
	/return
